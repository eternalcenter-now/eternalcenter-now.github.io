<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Cloud Computing (云计算) &#8211; Eternal Center</title>
	<atom:link href="https://eternalcenter-now.github.io/category/cloud-computing/feed/" rel="self" type="application/rss+xml" />
	<link>https://eternalcenter-now.github.io/</link>
	<description></description>
	<lastBuildDate>Mon, 11 Apr 2022 16:17:04 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>[步骤] KVM 虚拟机模板的创建 （Rocky Linux 8 版）</title>
		<link>https://eternalcenter-now.github.io/kvm-template-install-rocky-linux-8/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 06 Feb 2022 09:08:24 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[KVM]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[System Installation (系统安装)]]></category>
		<category><![CDATA[Virtualization (虚拟化)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=21850</guid>

					<description><![CDATA[注意： 在创建 KVM 虚拟机之前要先安装 KVM 并创建 KVM 虚拟网络 软件准备： 在 Rocky Linux 官网上下载安装系统所需要的镜像： https://rockylinux.org/download 正文： 步骤目录： 步骤一：理解创建 KVM 虚拟机模板的目的 步骤二：为这个虚拟机创建硬盘文件2.1 创建硬盘文件2.2 确认硬盘文件已创建 步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机3.1 启动 KVM 的 virt-manager3.2 在 virt-manager 上的左上角点击文件之后点击 “新建虚拟机”3.2.1 选择以本地安装介质的方式安装系统3.2.2 选择安装系统的系统镜像3.2.3 设置内存大小和 CPU 核心数3.2.4 选择用刚刚创建的硬盘文件来安装系统3.2.5 给虚拟机命名并选择虚拟网络3.2.6 开始安装系统3.2.7 选择系统语言3.2.8 之后进行系统配置界面3.2.8.1 通过 “INSTALLATION DESTINATION” 对硬盘进行分区3.2.8.2 取消 “KDUMP”3.2.8.3 选择最小化安装系统3.2.8.4 设置 root 密码3.2.9 之后点击右下角的 “Begin &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/kvm-template-install-rocky-linux-8/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] KVM 虚拟机模板的创建 （Rocky Linux 8 版）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在创建 KVM 虚拟机之前要先安装 KVM 并创建 KVM 虚拟网络</p>



<div class="wp-container-1 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/kvm-install/">KVM 的安装</a></div>



<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/kvm-network-install/">KVM 虚拟网络的创建</a></div>
</div>



<h2 id="软件准备">软件准备：</h2>



<p>在 Rocky Linux 官网上下载安装系统所需要的镜像：</p>



<p class="has-text-align-center"><a href="https://rockylinux.org/download">https://rockylinux.org/download</a></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-理解创建-kvm-虚拟机模板的目的-1">步骤一：理解创建 KVM 虚拟机模板的目的</h4>



<h4 id="步骤二-为这个虚拟机创建硬盘文件-2-1-创建硬盘文件-2-2-确认硬盘文件已创建">步骤二：为这个虚拟机创建硬盘文件<br>2.1 创建硬盘文件<br>2.2 确认硬盘文件已创建</h4>



<h4 id="步骤三-使用-kvm-和刚刚创建的硬盘文件新安装一台虚拟机-3-1-启动-kvm-的-virt-manager-3-2-在-virt-manager-上的左上角点击文件之后点击-新建虚拟机-3-2-1-选择以本地安装介质的方式安装系统-3-2-2-选择安装系统的系统镜像-3-2-3-设置内存大小和处理器数量-3-2-4-选择用刚刚创建的硬盘文件来安装系统-3-2-5-给虚拟机命名并选择虚拟网络-3-2-6-开始安装系统-3-2-7-选择系统语言-3-2-8-之后进行系统配置界面-3-2-8-1-通过-installation-destination-对硬盘进行分区-3-2-8-2-取消-kdump-3-2-8-3-选择最小化安装系统-3-2-8-4-设置-root-密码-3-2-9-之后点击右下角的-begin-installation-3-2-10-安装完成后重启-3-2-11-在安装系统的过程中需要注意的内容总结">步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机<br>3.1 启动 KVM 的 virt-manager<br>3.2 在 virt-manager 上的左上角点击文件之后点击 “新建虚拟机”<br>3.2.1 选择以本地安装介质的方式安装系统<br>3.2.2 选择安装系统的系统镜像<br>3.2.3 设置内存大小和 CPU 核心数<br>3.2.4 选择用刚刚创建的硬盘文件来安装系统<br>3.2.5 给虚拟机命名并选择虚拟网络<br>3.2.6 开始安装系统<br>3.2.7 选择系统语言<br>3.2.8 之后进行系统配置界面<br>3.2.8.1 通过 “INSTALLATION DESTINATION” 对硬盘进行分区<br>3.2.8.2 取消 “KDUMP”<br>3.2.8.3 选择最小化安装系统<br>3.2.8.4 设置 root 密码<br>3.2.9 之后点击右下角的 “Begin installation”<br>3.2.10 安装完成后重启<br>3.2.11 在安装系统的过程中需要注意的内容总结</h4>



<h4 id="步骤四-进入新创建虚拟机修改配置-4-1-修改网卡个性化设置-4-1-1-修改网卡配置文件-4-1-2-使修改的网卡配置生效-4-2-禁用-selinux-4-3-禁用空路由-4-4-添加-console-配置-4-4-1-修改-grub-内核配置文件-4-4-2-使修改的-grub-内核配置生效-4-5-将系统自动挂载的硬盘从使用-uuid-换成硬件路径-4-5-1-显示根分区的-uuid-4-5-2-在自动挂载文件里将根分区的-uuid-换成硬件路径-4-6-删除不用的程序-4-7-对虚拟系统进行升级-4-8-进行分区扩展-4-8-1-安装分区扩展软件-4-8-2-给开机自启配置文件相应的权限-4-8-3-设置开机自动扩容根目录-4-9-修改虚拟机系统的名称-4-10-启用-serial-服务实现通过-virsh-console-命令控制虚拟机-4-11-清除虚拟系统的历史命令-4-12-关闭虚拟机">步骤四：进入新创建虚拟机修改配置<br>4.1 修改网卡个性化设置<br>4.1.1 修改网卡配置文件<br>4.1.2 使修改的网卡配置生效<br>4.2 禁用 SELinux<br>4.3 禁用空路由<br>4.4 添加 Console 配置<br>4.4.1 修改 grub 内核配置文件<br>4.4.2 使修改的 grub 内核配置生效<br>4.5 将系统自动挂载的硬盘从使用 UUID 换成硬件路径<br>4.5.1 显示根分区的 UUID<br>4.5.2 在自动挂载文件里将根分区的 UUID 换成硬件路径<br>4.6 删除不用的程序<br>4.7 对虚拟系统进行升级<br>4.8 进行分区扩展<br>4.8.1 安装分区扩展软件<br>4.8.2 给开机自启配置文件相应的权限<br>4.8.3 设置开机自动扩容根目录<br>4.9 修改虚拟机系统的名称<br>4.10 启用 serial 服务实现通过 virsh console 命令控制虚拟机<br>4.11 清除虚拟系统的历史命令<br>4.12 关闭虚拟机</h4>



<h4 id="步骤五-在真机上对虚拟机进行清理优化-1">步骤五：在真机上对虚拟机进行清理优化</h4>



<h4 id="步骤六-此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了-1">步骤六：此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-理解创建-kvm-虚拟机模板的目的">步骤一：理解创建 KVM 虚拟机模板的目的</h4>



<p>主要用于批量克隆出新的 KVM 机器，节约创建新虚拟机的时间</p>



<h4 id="步骤二-为这个虚拟机创建硬盘文件-template-centos-8-10g-qcow22-1-创建硬盘文件-template-centos-8-10g-qcow2">步骤二：为这个虚拟机创建硬盘文件<br>2.1 创建硬盘文件</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># qemu-img create -f qcow2 /var/lib/libvirt/images/rockylinux8.qcow2 10G</code></pre>



<p>（补充：这里以创建 10G 大小的 rockylinux8.qcow2 硬盘文件为例）</p>



<h4 id="2-2-确认硬盘文件已创建">2.2 确认硬盘文件已创建</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># ls /var/lib/libvirt/images/ | grep rockylinux8.qcow2</code></pre>



<p>（补充：这里以显示 rockylinux8.qcow2 硬盘文件为例）</p>



<h4 id="步骤三-使用-kvm-和刚刚创建的硬盘文件新安装一台虚拟机3-1-启动-kvm-的-virt-manager">步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机<br>3.1 启动 KVM 的 virt-manager</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># virt-manager</code></pre>



<h4 id="3-2-在-virt-manager-上的左上角点击文件之后点击-新建虚拟机">3.2 在 virt-manager 上的左上角点击文件之后点击 “新建虚拟机”</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（步骤略）</p>



<h4 id="3-2-1-选择以本地安装介质的方式安装系统">3.2.1 选择以本地安装介质的方式安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img width="494" height="530" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-1.png" alt="" class="wp-image-21851" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-1.png 494w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-1-280x300.png 280w" sizes="(max-width: 494px) 100vw, 494px" /><figcaption><em>（图：1）</em></figcaption></figure></div>



<h4 id="3-2-2-选择安装系统的系统镜像">3.2.2 选择安装系统的系统镜像</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="494" height="530" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-2.png" alt="" class="wp-image-21852" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-2.png 494w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-2-280x300.png 280w" sizes="(max-width: 494px) 100vw, 494px" /><figcaption><em>（图：2）</em></figcaption></figure></div>



<p>（补充：这里以使用 Rocky-8.5-x86_6-dvd1.iso 系统镜像为例）</p>



<h4 id="3-2-3-设置内存大小和处理器数量">3.2.3 设置内存大小和 CPU 核心数</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="494" height="530" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-3.png" alt="" class="wp-image-21853" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-3.png 494w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-3-280x300.png 280w" sizes="(max-width: 494px) 100vw, 494px" /><figcaption><em>（图：3）</em></figcaption></figure></div>



<p>（补充：这里以设置 2048 MiB 内容和 2 核 CPU 为例）</p>



<h4 id="3-2-4-选择用刚刚创建的硬盘文件来安装系统">3.2.4 选择用刚刚创建的硬盘文件来安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="494" height="530" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-4.png" alt="" class="wp-image-21854" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-4.png 494w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-4-280x300.png 280w" sizes="(max-width: 494px) 100vw, 494px" /><figcaption><em>（图：4）</em></figcaption></figure></div>



<p>（补充：这里以使用 rockylinux8.qcow2 硬盘文件为例）</p>



<h4 id="3-2-5-给虚拟机命名并选择虚拟网络">3.2.5 给虚拟机命名并选择虚拟网络</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（注意：虚拟网络必须提前创建好）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="494" height="533" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-5.png" alt="" class="wp-image-21855" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-5.png 494w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-5-278x300.png 278w" sizes="(max-width: 494px) 100vw, 494px" /><figcaption><em>（图：5）</em></figcaption></figure></div>



<p>（补充：这里以将虚拟机命名为 rockylinux8 并使用 0 网络为例）</p>



<h4 id="3-2-6-开始安装系统">3.2.6 开始安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="794" height="630" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-6.png" alt="" class="wp-image-21856" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-6.png 794w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-6-300x238.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-6-768x609.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：6）</em></figcaption></figure></div>



<h4 id="3-2-7-选择系统语言">3.2.7 选择系统语言</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="1016" height="762" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-7.png" alt="" class="wp-image-21857" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-7.png 1016w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-7-300x225.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-7-768x576.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：7）</em></figcaption></figure></div>



<h4 id="3-2-8-之后进行系统配置界面">3.2.8 之后进行系统配置界面</h4>



<p>（只在真机上执行以下步骤）</p>



<p>需要手动配置的地方有四个：<br>1) “INSTALLATION DESTINATION”<br>2) “KDUMP”<br>3) “SOFTWARE SELECTION”<br>4) “Root Password”<br>分别点击以后就可以配置了</p>



<h4 id="3-2-8-1-通过-installation-destination-对硬盘进行分区">3.2.8.1 通过 “INSTALLATION DESTINATION” 对硬盘进行分区</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（补充：完成后点击左上角的 “DONE”）</p>



<p>（注意：只分一个分区，只设置一个挂载点挂载到根，使用标准硬盘类型，硬盘格式设置为 XFS）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="1016" height="762" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-8.png" alt="" class="wp-image-21858" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-8.png 1016w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-8-300x225.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-8-768x576.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：8）</em></figcaption></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="1016" height="762" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-9.png" alt="" class="wp-image-21859" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-9.png 1016w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-9-300x225.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-9-768x576.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：9）</em></figcaption></figure></div>



<h4 id="3-2-8-2-取消-kdump">3.2.8.2 取消 “KDUMP”</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（补充：完成后点击左上角的 “DONE”）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="1016" height="762" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-10.png" alt="" class="wp-image-21860" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-10.png 1016w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-10-300x225.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-10-768x576.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：10）</em></figcaption></figure></div>



<h4 id="3-2-8-3-选择最小化安装系统">3.2.8.3 选择最小化安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（补充：完成后点击左上角的 “DONE”）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="1016" height="762" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-11.png" alt="" class="wp-image-21861" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-11.png 1016w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-11-300x225.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-11-768x576.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：11）</em></figcaption></figure></div>



<h4 id="3-2-8-4-设置-root-密码">3.2.8.4 设置 root 密码</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="1016" height="762" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-12.png" alt="" class="wp-image-21862" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-12.png 1016w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-12-300x225.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-12-768x576.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：12）</em></figcaption></figure></div>



<h4 id="3-2-9-之后点击右下角的-begin-installation">3.2.9 之后点击右下角的 “Begin installation”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="1016" height="762" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-13.png" alt="" class="wp-image-21863" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-13.png 1016w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-13-300x225.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-13-768x576.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：13）</em></figcaption></figure></div>



<h4 id="3-2-10-安装完成后重启">3.2.10 安装完成后重启</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="1016" height="762" src="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-14.png" alt="" class="wp-image-21864" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-14.png 1016w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-14-300x225.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2022/02/KVM-template-Rocky-Linux-8-14-768x576.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption><em>（图：14）</em></figcaption></figure></div>



<h4 id="3-2-11-在安装系统的过程中需要注意的内容总结">3.2.11 在安装系统的过程中需要注意的内容总结</h4>



<p>（只在真机上执行以下步骤）</p>



<p>1) 一定要使用刚刚创建的 /var/lib/libvirt/images/rockylinux8.qcow2 作为安装虚拟机的硬件文件<br>2) 虚拟机网络 “0” 要提前创建好<br>3) 只分一个分区，只设置一个挂载点挂载到根，使用标准硬盘，硬盘格式是 XFS<br>4) 取消 “KDUMP”<br>5) 选择最小化安装系统<br>6) 设置 root 密码</p>



<h4 id="步骤四-进入新创建虚拟机修改配置4-1-修改网卡个性化设置4-1-1-修改网卡配置文件">步骤四：进入新创建虚拟机修改配置<br>4.1 修改网卡个性化设置<br>4.1.1 修改网卡配置文件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/sysconfig/network-scripts/ifcfg-enp1s0</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code>TYPE=Ethernet
BOOTPROTO=dhcp
NAME=enp1s0
DEVICE=enp1s0
ONBOOT=yes</code></pre>



<h4 id="4-1-2-使修改的网卡配置生效">4.1.2 使修改的网卡配置生效</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># reboot</code></pre>



<h4 id="4-2-禁用-selinux">4.2 禁用 SELinux</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/selinux/config</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code># This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=disabled
# SELINUXTYPE= can take one of three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted</code></pre>



<h4 id="4-3-禁用空路由">4.3 禁用空路由</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/sysconfig/network</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code># Created by anaconda
NOZEROCONF="yes"</code></pre>



<h4 id="4-4-添加-console-配置4-4-1-修改-grub-内核配置文件">4.4 添加 Console 配置<br>4.4.1 修改 grub 内核配置文件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/default/grub</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code>GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL="serial console"
GRUB_SERIAL_COMMAND="serial --unit=1 --speed=115200"
GRUB_CMDLINE_LINUX="biosdevname=0 net.ifnames=0 console=tty0 console=ttyS0,115200n8"
GRUB_DISABLE_LINUX_UUID="true"
GRUB_ENABLE_LINUX_LABEL="true"
GRUB_DISABLE_RECOVERY="true"</code></pre>



<h4 id="4-4-2-使修改的-grub-内核配置生效">4.4.2 使修改的 grub 内核配置生效</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># grub2-mkconfig -o grub</code></pre>



<h4 id="4-5-将系统自动挂载的硬盘从使用-uuid-换成硬件路径4-5-1-显示根分区的-uuid">4.5 将系统自动挂载的硬盘从使用 UUID 换成硬件路径<br>4.5.1 显示根分区的 UUID</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># blkid
/dev/sda1: UUID="e76ed189-6d0f-49d5-8586-c5aae4bdc9b5" TYPE="xfs" PARTUUID="3d8377ef-01"</code></pre>



<p>（补充：这里的 UUID 是： e76ed189-6d0f-49d5-8586-c5aae4bdc9b5）</p>



<h4 id="4-5-2-在自动挂载文件里将根分区的-uuid-换成硬件路径">4.5.2 在自动挂载文件里将根分区的 UUID 换成硬件路径</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/fstab</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
UUID=e76ed189-6d0f-49d5-8586-c5aae4bdc9b5 /                   xfs     defaults        0 0</code></pre>



<p>（补充：这里的 UUID 是： e76ed189-6d0f-49d5-8586-c5aae4bdc9b5）</p>



<p>修改为：</p>



<pre class="wp-block-code"><code>/dev/sda1 /                   xfs     defaults        0 0</code></pre>



<h4 id="4-6-删除不用的程序">4.6 删除不用的程序</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y remove firewalld-* python-firewall</code></pre>



<h4 id="4-7-对虚拟系统进行升级">4.7 对虚拟系统进行升级</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y update</code></pre>



<h4 id="4-9-进行分区扩展4-9-1-安装分区扩展软件">4.8 进行分区扩展<br>4.8.1 安装分区扩展软件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum install -y cloud-utils-growpart</code></pre>



<h4 id="4-8-2-给开机自启配置文件相应的权限">4.8.2 给开机自启配置文件相应的权限</h4>



<pre class="wp-block-code"><code># chmod 755 /etc/rc.local</code></pre>



<h4 id="4-8-3-设置开机自动扩容根目录">4.8.3 设置开机自动扩容根目录</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/rc.local</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
/usr/bin/growpart /dev/sda1
/usr/sbin/xfs_growfs /</code></pre>



<h4 id="4-9-修改虚拟机系统的名称">4.9 修改虚拟机系统的名称</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/hostname</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code>rockylinux8</code></pre>



<h4 id="4-10-启用-serial-服务实现通过-virsh-console-命令控制虚拟机">4.10 启用 serial 服务实现通过 virsh console 命令控制虚拟机</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl start serial-getty@ttyS0
# systemctl enable serial-getty@ttyS0</code></pre>



<h4 id="4-11-清除虚拟系统的历史命令">4.11 清除虚拟系统的历史命令</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># history -c</code></pre>



<h4 id="4-12-关闭虚拟机">4.12 关闭虚拟机</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># poweroff</code></pre>



<h4 id="步骤五-在真机上对虚拟机进行清理优化">步骤五：在真机上对虚拟机进行清理优化</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># sudo virt-sysprep -d rockylinux8</code></pre>



<p>（补充：这里以清理 rockylinux8 虚拟机为例）</p>



<p>（<br>注意：如果此命令不存在<br>1) Rocky Linux 系统的话需要安装 libguestfs-tools<br>2) openSUSE 系统的话需要安装 guestfs-tools<br>）</p>



<h4 id="步骤六-此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了">步骤六：此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了</h4>



<p>（只在真机上执行以下步骤）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[排错] 解决 KVM 开启虚拟机时报错 “failed to set MSR 0xe1 to 0x0”</title>
		<link>https://eternalcenter-now.github.io/debug-failed-to-set-msr-0xe1-to-0x0/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 22 Aug 2021 14:09:42 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[KVM]]></category>
		<category><![CDATA[Virtualization (虚拟化)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=17549</guid>

					<description><![CDATA[报错代码： AMD CPU 在使用 KVM 开启虚拟机时可能会出现此类报错： 解决方法：]]></description>
										<content:encoded><![CDATA[
<h2>报错代码：</h2>



<p>AMD CPU 在使用 KVM 开启虚拟机时可能会出现此类报错：</p>



<pre class="wp-block-code"><code>failed to set MSR 0xe1 to 0x0</code></pre>



<h2>解决方法：</h2>



<pre class="wp-block-code"><code># echo Y &gt; /sys/module/kvm/parameters/ignore_msrs</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] VMware 命令行启动 （Linux 版）</title>
		<link>https://eternalcenter-now.github.io/vmware-command-start-linux/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 22 Aug 2021 11:34:44 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Virtualization (虚拟化)]]></category>
		<category><![CDATA[VMware]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=17547</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<pre class="wp-block-code"><code># /etc/init.d/vmware start
# vmplayer</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>分布式存储算法介绍</title>
		<link>https://eternalcenter-now.github.io/introduction-to-distributed-storage-algorithm/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 20 Aug 2021 07:45:22 +0000</pubDate>
				<category><![CDATA[Ceph]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[Distributed Cloud Storage Clusters (分布式云存储集群)]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[OpenStack]]></category>
		<category><![CDATA[Virtualization Clouds (虚拟化云)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=17540</guid>

					<description><![CDATA[章节一：传统的 Hash 存储算法1.1 传统的 Hash 存储算法简介 　　将数据进行切片，对每份切片进行 Hash 取值，并对获取的 Hash 值除以存储节点的数量以取余，余数是多少就将此切片存在第几个 OSD 节点里，主要是 Swift 在使用。 1.2 传统的 Hash 存储算法的缺点 　　如果要增加存或减少存储节点，需要对所有已存储数据切片的 Hash 值重新取余，大概 90% 的数据需要重新均衡数据（rebalance）。 章节二：一致性 Hash 算法2.1 一致性 Hash 算法简介 　　1) 给电脑也计算 Hash 值（可以是给电脑名计算 Hash 值，也可以给 IP 地址计算 Hash 值）　　2) 再给数据也计算 Hash 值，将数据存到比它的 Hash 值大，且与它的差值最小的一台电脑上，如果没有 Hash 值比它大的电脑就直接将数据存在 Hash 值最小的电脑上　　3) 整个架构类似一个环 2.2 一致性 Hash 算法的缺点 　　1) &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/introduction-to-distributed-storage-algorithm/" class="more-link">Continue reading<span class="screen-reader-text"> "分布式存储算法介绍"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4>章节一：传统的 Hash 存储算法<br>1.1 传统的 Hash 存储算法简介</h4>



<p>　　将数据进行切片，对每份切片进行 Hash 取值，并对获取的 Hash 值除以存储节点的数量以取余，余数是多少就将此切片存在第几个 OSD 节点里，主要是 Swift 在使用。</p>



<h4>1.2 传统的 Hash 存储算法的缺点</h4>



<p>　　如果要增加存或减少存储节点，需要对所有已存储数据切片的 Hash 值重新取余，大概 90% 的数据需要重新均衡数据（rebalance）。</p>



<h4>章节二：一致性 Hash 算法<br>2.1 一致性 Hash 算法简介</h4>



<p>　　1) 给电脑也计算 Hash 值（可以是给电脑名计算 Hash 值，也可以给 IP 地址计算 Hash 值）<br>　　2) 再给数据也计算 Hash 值，将数据存到比它的 Hash 值大，且与它的差值最小的一台电脑上，如果没有 Hash 值比它大的电脑就直接将数据存在 Hash 值最小的电脑上<br>　　3) 整个架构类似一个环</p>



<h4>2.2 一致性 Hash 算法的缺点</h4>



<p>　　1) 电脑太少时切换数据也会有较大的数据量，但是可以多设置几个虚拟节点，给以后新增加的节点使用，虚拟节点里的数据会影射到对应的物理节点里面去<br>　　2) 电脑太少时，两台电脑的 Hash 值比较接近导致，数据分配极度不平均</p>



<p>（注意：在开始创建数据架构时，要评估未来数据的规模，如果最后要添加的电脑数量超过了虚拟节点数量，那么这个架构就不能使用了。此时只能备份数据，然后新建一个架构出来）</p>



<h4>章节三：CRUSH<br>3.1 CRUSH 简介</h4>



<p>　　CRUSH（Controlled Replication Under Scalable Hashing）算法，在可扩展 Hash 算法下的可控制复制，主要是 Ceph 在使用。</p>



<h4>3.2 CRUSH 算法<br>3.2.1 CRUSH 算法的第一层</h4>



<p>　　由 Ceph 的 OSD（Object Storage Deivces）组成。</p>



<h4>3.2.2 CRUSH 算法的第二层<br>3.2.3 CRUSH 算法的第二层的组成</h4>



<p>　　由 Ceph 的 PG（Placement Group）归置组组成。</p>



<h4>3.2.4 CRUSH 算法的第二层的由来</h4>



<p>　　在 OSD 节点上虚拟出多个 PG，每个 PG 默认会被指定对应 3 个 OSD 节点（每个 OSD 节点同时可以属于多个 PG），其中第一个 OSD 节点为主要（primary）的硬盘，其他两 OSD 节点为从（second）硬盘，PG 会对应几个 OSD 节点取决于 Ceph 的存储副本被设置了几份。</p>



<h4>3.2.5 CRUSH 算法的第二层的算法</h4>



<p>　　1) 给每个 OSD 节点设置一个权重值，OSD 节点的容量越大则其权重值越大<br>　　2) 主要（primary）硬盘的 OSD 节点：将 PG 的 ID 值和 OSD 的 ID 值组合在一起并计算 Hash 值，将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时，此 PG 就和此 OSD 绑定在一起<br>　　3) 第一个从（second）硬盘的 OSD 节点：将 PG 的 ID 值逐一和 OSD 的 ID 值和一个随机的常数组合在一起并计算 Hash 值（这个值在 Ceph 的代码里被叫做 draw），将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时（这个值在 Ceph 的源代码里叫做 straw）则此 PG 就和此 OSD 绑定在一起<br>　　4) 第二个从（second）硬盘的 OSD 节点：将 PG 的 ID 值逐一和 OSD 的 ID 值和上一个随机常数加 1 的和组合在一起并计算 Hash 值（这个值在 Ceph 的代码里被叫做 draw），将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时（这个值在 Ceph 的源代码里叫做 straw），则此 PG 就和此 OSD 绑定在一起（如果找到的 OSD 节点和前面的 OSD 节点重复，则将这个随机常数再加 1 并进行重复操作，最终获得和前面不通的 OSD 节点为止）<br>……</p>



<h4>3.3 CRUSH 算法的第三层<br>3.3.1 CRUSH 算法的第三层的组成</h4>



<p>　　由池组成。</p>



<h4>3.3.2 CRUSH 算法的第三层的由来</h4>



<p>　　1) 在 PG 上虚拟出多个池，每个池对应多个 PG，数据可以存储到指定的池里<br>　　2) 总硬盘容量有多大，每个池最大可以使用的容量就有多大，但是如果如果一个池使用了一部分容量，其他的池就要少使用一部分容量</p>



<h4>3.4 CRUSH 算法的第四层<br>3.4.1 CRUSH 算法的第四层的组成</h4>



<p>　　由数据组成。</p>



<h4>3.4.2 CRUSH 算法的第四层的算法</h4>



<p>　　1) 对要放入某个池里的数据进行切片，默认每片 4M<br>　　2) 对每份切片进行 Hash 取值，并对获取的 Hash 值除以这个池里 PG 节点的数量以取余，余数是多少就存在第几个 OSD 节点里</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Ceph 介绍</title>
		<link>https://eternalcenter-now.github.io/introduction-of-ceph/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 20 Aug 2021 07:13:01 +0000</pubDate>
				<category><![CDATA[Ceph]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[Distributed Cloud Storage Clusters (分布式云存储集群)]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[OpenStack]]></category>
		<category><![CDATA[Virtualization Clouds (虚拟化云)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=17526</guid>

					<description><![CDATA[内容一：Ceph 简介 Ceph 是一种分布式存储架构和技术。此项目是 2004 年由 Sage Weil 在加州大学 Santa Cruz 分校攻读博士期间的创建和研究的课题，并于 2006 年将其开源，同时成立 Inktank 公司专注 Ceph 的研发。2014 年 5 月 Inktank 公司被 Red Hat 收购。 内容二：Ceph 的特点 1) 高性能（硬盘越多性能越高，所有硬盘可以同时读写）2) 高可用（硬盘越多高可用越高） 内容三：Ceph 使用的方式 1) 自己写程序：通过 C C++ Java Python Ruby PHP 等语言写程序调用 Ceph 底层存储 LIBRADOS，此方法性能最高2) 自己写脚本：写对象脚本，通过 RGW（RADOSGW）对象存储网关的 Rest API 接口去访问 Ceph 的底层存储 LIBRADOS，此方法性能第二高3) 挂载块存储：通过 Linux &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/introduction-of-ceph/" class="more-link">Continue reading<span class="screen-reader-text"> "[内容] Ceph 介绍"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4>内容一：Ceph 简介</h4>



<p>Ceph 是一种分布式存储架构和技术。此项目是 2004 年由 Sage Weil 在加州大学 Santa Cruz 分校攻读博士期间的创建和研究的课题，并于 2006 年将其开源，同时成立 Inktank 公司专注 Ceph 的研发。2014 年 5 月 Inktank 公司被 Red Hat 收购。</p>



<h4>内容二：Ceph 的特点</h4>



<p>1) 高性能（硬盘越多性能越高，所有硬盘可以同时读写）<br>2) 高可用（硬盘越多高可用越高）</p>



<h4>内容三：Ceph 使用的方式</h4>



<p>1) 自己写程序：通过 C C++ Java Python Ruby PHP 等语言写程序调用 Ceph 底层存储 LIBRADOS，此方法性能最高<br>2) 自己写脚本：写对象脚本，通过 RGW（RADOSGW）对象存储网关的 Rest API 接口去访问 Ceph 的底层存储 LIBRADOS，此方法性能第二高<br>3) 挂载块存储：通过 Linux 内核或者 KVM 等虚拟机存储驱动访问 Ceph 的块存储，此方法性能第三高<br>4) 挂载文件系统：通过 Linux 内核（POSIX 命令）挂载 Ceph 的文件系统存储，此方法性能最弱</p>



<h4>内容四：Ceph 的组成</h4>



<p>1) OSD（Object Storage Deivces）：负责存储、复制、恢复数据等，默认要有 3 台以上才能实现高可用，因为 Ceph 默认有三副本<br>2) MON（Monitor）：负责监控集群状态制作和更新存储地图（map），供客户端从下载，在生产环境里必须要有 3 台以上，且最好是奇数台，因为必须遵循过半原则<br>3) MDS（Metadata Servers）：实现文件系统存储，允许客户端通过 Linux 内核（POSIX 命令）挂载 Ceph 的文件系统存储<br>4) RGW（RADOSGW）：实现对象存储网关，允许客户端通过 RGW（RADOSGW）对象存储网关的 Rest API 接口去访问 Ceph 的底层存储 LIBRADOS<br>5) 客户端：使用从 MON 下载和更新的存储地图，通过算法，直接从 OSD 访问数据</p>



<h4>内容五：Ceph 架构<br>5.1 Ceph 使用架构<br>5.1.1 Ceph 的上层</h4>



<p>自己写程序、自己写脚本、挂载块存储、挂载文件系统 4 种使用方式。</p>



<h4>5.1.2 Ceph 的下层</h4>



<p>RADOS，基于对象的存储（比我们平时所说的对象存储更原始，更底层），通过软件实现自我检查、自我备份和自我修复的功能。</p>



<h4>5.2 Ceph 组成架构</h4>



<pre class="wp-block-code"><code>                                  File

                  Cut1(Objects1) Cut2(Objects2) Cut3(Objects3)......

                              choice Pool

              Pool1                                   Pool2
     PG1                PG2                  PG2               PG3
OSD1 OSD2 OSD3    OSD2 OSD5 OSD3        OSD1 OSD4 OSD3    OSD4 OSD5 OSD3
Disk Disk Disk    Disk Disk Disk        Disk Disk Disk    Disk Disk Disk</code></pre>



<h4>内容六：Ceph 的算法：CRUSH<br>6.1 CRUSH 简介</h4>



<p>CRUSH（Controlled Replication Under Scalable Hashing）算法，在可扩展 Hash 算法下的可控制复制</p>



<h4>6.2 CRUSH 算法的第一层</h4>



<p>由 OSD（Object Storage Deivces）组成。</p>



<h4>6.3 CRUSH 算法的第二层<br>6.3.1 CRUSH 算法的第二层的组成</h4>



<p>由 PG（Placement Group）归置组组成。</p>



<h4>6.3.2 CRUSH 算法的第二层的由来</h4>



<p>在 OSD 节点上虚拟出多个 PG，每个 PG 默认会被指定对应 3 个 OSD 节点（每个 OSD 节点同时可以属于多个 PG），其中第一个 OSD 节点为主要（primary）的硬盘，其他两 OSD 节点为从（second）硬盘，PG 会对应几个 OSD 节点取决于 Ceph 的存储副本被设置了几份。</p>



<h4>6.3.3 CRUSH 算法的第二层的算法</h4>



<p>1) 给每个 OSD 节点设置一个权重值，OSD 节点的容量越大则其权重值越大<br>2) 主要（primary）硬盘的 OSD 节点：将 PG 的 ID 值和 OSD 的 ID 值组合在一起并计算 Hash 值，将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时，此 PG 就和此 OSD 绑定在一起<br>3) 第一个从（second）硬盘的 OSD 节点：将 PG 的 ID 值逐一和 OSD 的 ID 值和一个随机的常数组合在一起并计算 Hash 值（这个值在 Ceph 的代码里被叫做 draw），将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时（这个值在 Ceph 的源代码里叫做 straw）则此 PG 就和此 OSD 绑定在一起<br>4) 第二个从（second）硬盘的 OSD 节点：将 PG 的 ID 值逐一和 OSD 的 ID 值和上一个随机常数加 1 的和组合在一起并计算 Hash 值（这个值在 Ceph 的代码里被叫做 draw），将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时（这个值在 Ceph 的源代码里叫做 straw），则此 PG 就和此 OSD 绑定在一起（如果找到的 OSD 节点和前面的 OSD 节点重复，则将这个随机常数再加 1 并进行重复操作，最终获得和前面不通的 OSD 节点为止）<br>5) 第三个从（second）硬盘的 OSD 节点：仿照第二个从（second）硬盘的 OSD 节点方式以此类推</p>



<h4>6.4 CRUSH 算法的第三层<br>6.4.1 CRUSH 算法的第三层的组成</h4>



<p>由池组成。</p>



<h4>6.4.2 CRUSH 算法的第三层的由来</h4>



<p>1) 在 PG 上虚拟出多个池，每个池对应多个 PG，数据可以存储到指定的池里<br>2) 总硬盘容量有多大，每个池最大可以使用的容量就有多大，但是如果如果一个池使用了一部分容量，其他的池就要少使用一部分容量</p>



<h4>6.5 CRUSH 算法的第四层<br>6.5.1 CRUSH 算法的第四层的组成</h4>



<p>由数据组成。</p>



<h4>6.5.2 CRUSH 算法的第四层的算法</h4>



<p>1) 对要放入某个池里的数据进行切片，默认每片 4M<br>2) 对每份切片进行 Hash 取值，并对获取的 Hash 值除以这个池里 PG 节点的数量以取余，余数是多少就存在第几个 OSD 节点里</p>



<h4>内容七：Ceph 的工作流程</h4>



<p>1) 客户端从 MON 上下载最新的存储地图（map）<br>2) 存储地图（map）把集群里所有 MON、OSD 和 MDS 的信息告诉客户端，但是客户端依然不知道想要找的数据存放在哪<br>3) 客户端通过 CRUSH 计算出所需要读写的数据存放的 OSD 节点位置<br>4) 客户端直接在 OSD 节点位置上读写数据<br>5) 用户只需要把数据数据写入主要 OSD 节点硬盘上，然后 Ceph 自动同步给其他的从 OSD 节点硬盘上</p>



<h4>内容八：Ceph 的维护</h4>



<p>1) PG 的个数肯定要大于 OSD 节点的数量，在生产的环境中 PG 设计的数量往往会远远大于 OSD 节点的数量，以满足未来可能几年的需求，可能会在 3 个硬盘上添加上百个 PG<br>2) 当增加存或减少存储节点时，PG 的数量不会发生变化，只有 PG 对应 OSD 节点有变化的数据才会需要重新均衡数据（rebalance）的数据<br>3) 当增加存或减少 PG 数量时，就需要像传统的 Hash 存储算法那样，对所有已存储数据切片的 Hash 值重新取余，大概 90 % 的数据需要重新均衡数据（rebalance）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] KVM 虚拟机模板的创建 （openSUSE Leap 15 版）</title>
		<link>https://eternalcenter-now.github.io/kvm-template-install-opensuse-leap-15/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 06 Feb 2021 14:23:47 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[KVM]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[System Installation (系统安装)]]></category>
		<category><![CDATA[Virtualization (虚拟化)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=13283</guid>

					<description><![CDATA[注意： 在创建 KVM 虚拟机之前要先安装 KVM 并创建 KVM 虚拟网络 软件准备： 在 openSUSE 官网上下载安装系统所需要的镜像： https://software.opensuse.org/distributions/leap 正文： 步骤目录： 步骤一：理解创建 KVM 虚拟机模板的目的 步骤二：为这个虚拟机创建硬盘文件1.1 创建硬盘文件1.2 确认硬盘文件已创建 步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机3.1 启动 KVM 的 virt-manager3.2 在 virt-manager 上的左上角点击文件之后 “点击新建虚拟机”3.2.1 选择以本地安装介质的方式安装系统3.2.2 选择安装系统的系统镜像3.2.3 设置内存大小和 CPU 核心数3.2.4 选择用刚刚创建的硬盘文件来安装系统3.2.5 给虚拟机命名并选择虚拟网络3.2.6 开始安装系统3.2.7 进入 “Language, Keyboard and License Agreement” 后选择系统语言，再点击 “Next”3.2.8 当出现 &#8220;Activate online repositories now?&#8221; 时，点击 “No”3.2.9 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/kvm-template-install-opensuse-leap-15/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] KVM 虚拟机模板的创建 （openSUSE Leap 15 版）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在创建 KVM 虚拟机之前要先安装 KVM 并创建 KVM 虚拟网络</p>



<div class="wp-container-2 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/kvm-install/">KVM 的安装</a></div>



<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/kvm-network-installation/">KVM 虚拟网络的创建</a></div>
</div>



<h2 id="软件准备">软件准备：</h2>



<p>在 openSUSE 官网上下载安装系统所需要的镜像：</p>



<p class="has-text-align-center"><a href="https://software.opensuse.org/distributions/leap" target="_blank" rel="noreferrer noopener">https://software.opensuse.org/distributions/leap</a></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-理解创建-kvm-虚拟机模板的目的">步骤一：理解创建 KVM 虚拟机模板的目的</h4>



<h4 id="步骤二-为这个虚拟机创建硬盘文件-template-opensuse-leap-15-10g-qcow21-1-创建硬盘文件-template-opensuse-leap-15-10g-qcow21-2-确认硬盘文件-template-opensuse-leap-15-10g-qcow2-已创建">步骤二：为这个虚拟机创建硬盘文件<br>1.1 创建硬盘文件<br>1.2 确认硬盘文件已创建</h4>



<h4 id="步骤三-使用-kvm-和刚刚创建的硬盘文件新安装一台虚拟机3-1-启动-kvm-的-virt-manager3-2-在-virt-manager-上的左上角点击文件之后-点击新建虚拟机-3-2-1-选择以本地安装介质的方式安装系统3-2-2-选择安装系统的系统镜像3-2-3-设置内存大小和处理器数量3-2-4-选择用刚刚创建的硬盘文件来安装系统3-2-5-给虚拟机命名为-template-centos-7-10g-并选择虚拟网络-0-3-2-6-开始安装系统3-2-7-进入-language-keyboard-and-license-agreement-后选择系统语言-再点击-next-3-2-8-当出现-activate-online-repositories-now-时-点击-no-3-2-9-进入-system-role-后选择-server-再点击-next-3-2-10-进入-suggested-partitioning-后点击-guided-setup-3-2-11-进入-partitioning-scheme-后点击-next-3-2-12-进入-filesystem-options-后-file-system-type-选择-xfs-再点击-next-3-2-13-回到-suggested-partitioning-后点击-next-3-2-14-进入-clock-and-time-zone-后选择时区-再点击-next-3-2-15-进入-local-user-后选择-skip-user-creation-并点击-next-3-2-16-进入-authentication-for-the-system-administrator-root-后给-root-设置密码-再点击-next-3-2-17-如果出现-yast2-the-password-is-too-simple-则点击-yes-3-2-18-进入-installation-settings-后点击-next-3-2-19-当出现-confirm-installation-时点击-install-3-2-20-当出现-the-system-will-reboot-now-时-点击-ok-3-2-21-在安装系统的过程中需要注意的内容总结">步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机<br>3.1 启动 KVM 的 virt-manager<br>3.2 在 virt-manager 上的左上角点击文件之后 “点击新建虚拟机”<br>3.2.1 选择以本地安装介质的方式安装系统<br>3.2.2 选择安装系统的系统镜像<br>3.2.3 设置内存大小和 CPU 核心数<br>3.2.4 选择用刚刚创建的硬盘文件来安装系统<br>3.2.5 给虚拟机命名并选择虚拟网络<br>3.2.6 开始安装系统<br>3.2.7 进入 “Language, Keyboard and License Agreement” 后选择系统语言，再点击 “Next”<br>3.2.8 当出现 &#8220;Activate online repositories now?&#8221; 时，点击 “No”<br>3.2.9 进入 “System Role” 后选择 “Server”，再点击 “Next”<br>3.2.10 进入 “Suggested Partitioning” 后点击 “Guided Setup”<br>3.2.11 进入 “Partitioning Scheme” 后点击 “Next”<br>3.2.12 进入 “Filesystem Options” 后 “File System Type“ 选择 “XFS”，再点击 “Next”<br>3.2.13 回到 “Suggested Partitioning” 后点击 “Next”<br>3.2.14 进入 “Clock and Time Zone” 后选择时区，再点击 “Next”<br>3.2.15 进入 “Local User” 后选择 “Skip User Creation” 并点击 “Next”<br>3.2.16 进入 “Authentication for the System Administrator &#8220;root&#8221;” 后给 root 设置密码，再点击 “Next”<br>3.2.17 如果出现 “YaST2 The password is too simple” 则点击 “Yes”<br>3.2.18 进入 “Installation Settings” 后点击 “Next”<br>3.2.19 当出现 “Confirm Installation” 时点击 “Install”<br>3.2.20 当出现 “The system will reboot now…” 时，点击 “Ok”<br>3.2.21 在安装系统的过程中需要注意的内容总结</h4>



<h4 id="步骤四-进入新创建虚拟机修改配置-4-1-添加-console-配置-4-1-1-修改-grub-内核配置文件-4-1-2-使修改的-grub-内核配置生效-4-2-将系统自动挂载的硬盘从使用-uuid-换成硬件路径-4-2-1-显示根分区的-uuid-4-2-2-在自动挂载文件里将根分区的-uuid-换成硬件路径-4-3-删除不用的软件-4-4-进行分区扩展-4-4-1-安装分区扩展软件-4-4-2-设置开机自动扩容根目录-4-4-2-1-创建开机自动扩容根目录的配置文件-4-4-2-2-给开机自启配置文件相应的权限-4-5-只使用本地软件源-选做-4-5-1-禁用所有软件源-选做-4-5-2-添加本地软件源-选做-4-5-3-添加本地软件源-选做-4-6-修改虚拟机系统的名称-4-7-启用-serial-服务实现通过-virsh-console-命令控制虚拟机-4-8-清除虚拟系统的历史命令-4-9-关闭虚拟机">步骤四：进入新创建虚拟机修改配置<br>4.1 添加 Console 配置<br>4.1.1 修改 grub 内核配置文件<br>4.1.2 使修改的 grub 内核配置生效<br>4.2 将系统自动挂载的硬盘从使用 uuid 换成硬件路径<br>4.2.1 显示根分区的 UUID<br>4.2.2 在自动挂载文件里将根分区的 UUID 换成硬件路径<br>4.3 删除不用的软件<br>4.4 进行分区扩展<br>4.4.1 安装分区扩展软件<br>4.4.2 设置开机自动扩容根目录<br>4.4.2.1 创建开机自动扩容根目录的配置文件<br>4.4.2.2 给开机自启配置文件相应的权限<br>4.5 只使用本地软件源（选做）<br>4.5.1 禁用所有软件源（选做）<br>4.5.2 添加本地软件源（选做）<br>4.5.3 添加本地软件源（选做）<br>4.6 修改虚拟机系统的名称<br>4.7 启用 serial 服务实现通过 virsh console 命令控制虚拟机<br>4.8 清除虚拟系统的历史命令<br>4.9 关闭虚拟机</h4>



<h4 id="步骤五-此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了">步骤五：修改新创建的虚拟机配置文件</h4>



<h4 id="步骤六-此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了">步骤六：此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-理解创建-kvm-虚拟机模板的目的">步骤一：理解创建 KVM 虚拟机模板的目的</h4>



<p>主要用于批量克隆出新的 KVM 机器，节约创建新虚拟机的时间</p>



<h4 id="步骤二-为这个虚拟机创建硬盘文件-template-opensuse-leap-15-10g-qcow21-1-创建硬盘文件-template-opensuse-leap-15-10g-qcow2">步骤二：为这个虚拟机创建硬盘文件<br>1.1 创建硬盘文件</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># qemu-img create -f qcow2 /var/lib/libvirt/images/template_opensuse_leap_15_10g.qcow2 10G</code></pre>



<p>（补充：这里以创建 10G 大小的 template_opensuse_leap_15_10g.qcow2 硬盘文件为例）</p>



<h4 id="1-2-确认硬盘文件已创建">1.2 确认硬盘文件已创建</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># ls /var/lib/libvirt/images/ | grep template_opensuse_leap_15_10g.qcow2</code></pre>



<p>（补充：这里以确认 template_opensuse_leap_15_10g.qcow2 硬盘文件为例）</p>



<h4 id="步骤三-使用-kvm-和刚刚创建的硬盘文件新安装一台虚拟机3-1-启动-kvm-的-virt-manager">步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机<br>3.1 启动 KVM 的 virt-manager</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># virt-manager</code></pre>



<h4 id="3-2-在-virt-manager-上的左上角点击文件之后-点击新建虚拟机">3.2 在 virt-manager 上的左上角点击文件之后 “点击新建虚拟机”</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（步骤略）</p>



<h4 id="3-2-1-选择以本地安装介质的方式安装系统">3.2.1 选择以本地安装介质的方式安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="502" height="539" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-1.png" alt="" class="wp-image-19725" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-1.png 502w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-1-279x300.png 279w" sizes="(max-width: 502px) 100vw, 502px" /><figcaption>（图：1）</figcaption></figure></div>



<h4 id="3-2-2-选择安装系统的系统镜像">3.2.2 选择安装系统的系统镜像</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="502" height="539" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-2.png" alt="" class="wp-image-19726" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-2.png 502w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-2-279x300.png 279w" sizes="(max-width: 502px) 100vw, 502px" /><figcaption>（图：2）</figcaption></figure></div>



<p>（补充：这里以使用 openSUSE-Leap-15.2-DVD-x86_64.iso 系统镜像为例）</p>



<h4 id="3-2-3-设置内存大小和处理器数量">3.2.3 设置内存大小和 CPU 核心数</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="502" height="539" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-3.png" alt="" class="wp-image-19727" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-3.png 502w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-3-279x300.png 279w" sizes="(max-width: 502px) 100vw, 502px" /><figcaption>（图：3）</figcaption></figure></div>



<p>（补充：这里以设置 2048 MiB 内容和 2 核 CPU 为例）</p>



<h4 id="3-2-4-选择用刚刚创建的硬盘文件来安装系统">3.2.4 选择用刚刚创建的硬盘文件来安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="502" height="539" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-4.png" alt="" class="wp-image-19728" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-4.png 502w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-4-279x300.png 279w" sizes="(max-width: 502px) 100vw, 502px" /><figcaption>（图：4）</figcaption></figure></div>



<p>（补充：这里以使用 template_opensuse_leap_15_10g.qcow2 硬盘文件为例）</p>



<h4 id="3-2-5-给虚拟机命名并选择虚拟网络">3.2.5 给虚拟机命名并选择虚拟网络</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（注意：虚拟网络必须提前创建好）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="502" height="539" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-5.png" alt="" class="wp-image-19729" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-5.png 502w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-5-279x300.png 279w" sizes="(max-width: 502px) 100vw, 502px" /><figcaption>（图：5）</figcaption></figure></div>



<p>（补充：这里以将虚拟机命名为 template_opensuse_leap_15_10g 并使用 0 网络为例）</p>



<h4 id="3-2-6-开始安装系统">3.2.6 开始安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="613" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-6.png" alt="" class="wp-image-19730" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-6.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-6-300x239.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：6）</figcaption></figure></div>



<h4 id="3-2-7-进入-language-keyboard-and-license-agreement-后选择系统语言-再点击-next">3.2.7 进入 “Language, Keyboard and License Agreement” 后选择系统语言，再点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-7.png" alt="" class="wp-image-19731" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-7.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-7-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：7）</figcaption></figure></div>



<h4 id="3-2-8-当出现-activate-online-repositories-now-时-点击-no">3.2.8 当出现 &#8220;Activate online repositories now?&#8221; 时，点击 “No”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-8.png" alt="" class="wp-image-19733" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-8.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-8-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：8）</figcaption></figure></div>



<h4 id="3-2-9-进入-system-role-后选择-server-再点击-next">3.2.9 进入 “System Role” 后选择 “Server”，再点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-9.png" alt="" class="wp-image-19734" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-9.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-9-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：9）</figcaption></figure></div>



<h4 id="3-2-10-进入-suggested-partitioning-后点击-guided-setup">3.2.10 进入 “Suggested Partitioning” 后点击 “Guided Setup”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-10.png" alt="" class="wp-image-19735" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-10.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-10-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：10）</figcaption></figure></div>



<h4 id="3-2-11-进入-partitioning-scheme-后点击-next">3.2.11 进入 “Partitioning Scheme” 后点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-11.png" alt="" class="wp-image-19736" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-11.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-11-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：11）</figcaption></figure></div>



<h4 id="3-2-12-进入-filesystem-options-后-file-system-type-选择-xfs-再点击-next">3.2.12 进入 “Filesystem Options” 后 “File System Type“ 选择 “XFS”，再点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-12.png" alt="" class="wp-image-19737" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-12.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-12-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：12）</figcaption></figure></div>



<h4 id="3-2-13-回到-suggested-partitioning-后点击-next">3.2.13 回到 “Suggested Partitioning” 后点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-13.png" alt="" class="wp-image-19738" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-13.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-13-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：13）</figcaption></figure></div>



<h4 id="3-2-14-进入-clock-and-time-zone-后选择时区-再点击-next">3.2.14 进入 “Clock and Time Zone” 后选择时区，再点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="266" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-14.png" alt="" class="wp-image-19739" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-14.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-14-300x104.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：14）</figcaption></figure></div>



<h4 id="3-2-15-进入-local-user-后选择-skip-user-creation-并点击-next">3.2.15 进入 “Local User” 后选择 “Skip User Creation” 并点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-15.png" alt="" class="wp-image-19740" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-15.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-15-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：15）</figcaption></figure></div>



<h4 id="3-2-16-进入-authentication-for-the-system-administrator-root-后给-root-设置密码-再点击-next">3.2.16 进入 “Authentication for the System Administrator &#8220;root&#8221;” 后给 root 设置密码，再点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-16.png" alt="" class="wp-image-19741" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-16.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-16-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：16）</figcaption></figure></div>



<h4 id="3-2-17-如果出现-yast2-the-password-is-too-simple-则点击-yes">3.2.17 如果出现 “YaST2 The password is too simple” 则点击 “Yes”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-17.png" alt="" class="wp-image-19742" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-17.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-17-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：17）</figcaption></figure></div>



<h4 id="3-2-18-进入-installation-settings-后点击-next">3.2.18 进入 “Installation Settings” 后点击 “Next”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-18.png" alt="" class="wp-image-19743" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-18.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-18-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：18）</figcaption></figure></div>



<h4 id="3-2-19-当出现-confirm-installation-时点击-install">3.2.19 当出现 “Confirm Installation” 时点击 “Install”</h4>



<p>（只在真机上执行以下步骤）</p>



<figure class="wp-block-image size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-19.png" alt="" class="wp-image-19744" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-19.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-19-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：19）</figcaption></figure>



<h4 id="3-2-20-当出现-the-system-will-reboot-now-时-点击-ok">3.2.20 当出现 “The system will reboot now…” 时，点击 “Ok”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-20.png" alt="" class="wp-image-19745" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-20.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-openSUSE-15-20-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：20）</figcaption></figure></div>



<h4 id="3-2-21-在安装系统的过程中需要注意的内容总结">3.2.21 在安装系统的过程中需要注意的内容总结</h4>



<p>（只在真机上执行以下步骤）</p>



<p>1)  一定要使用刚刚创建的 template_opensuse_leap_15_10g.qcow2 作为安装虚拟机的硬件文件<br>2)  虚拟机网络 “0” 要提前创建好<br>3)  只分一个分区，只设置一个挂载点挂载到根，使用标准硬盘，硬盘格式是 XFS<br>4)  选择最小化安装系统</p>



<h4 id="步骤四-进入新创建虚拟机修改配置4-1-添加-console-配置4-1-1-修改-grub-内核配置文件">步骤四：进入新创建虚拟机修改配置<br>4.1 添加 Console 配置<br>4.1.1 修改 grub 内核配置文件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/default/grub</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code># If you change this file, run 'grub2-mkconfig -o /boot/grub2/grub.cfg' afterwards to update
# /boot/grub2/grub.cfg.

# Uncomment to set your own custom distributor. If you leave it unset or empty, the default
# policy is to determine the value from /etc/os-release
GRUB_DISTRIBUTOR=
GRUB_DEFAULT=saved
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=8
GRUB_CMDLINE_LINUX_DEFAULT="splash=silent mitigations=auto quiet"
GRUB_SERIAL_COMMAND="serial --unit=1 --speed=115200"
GRUB_CMDLINE_LINUX="biosdevname=0 net.ifnames=0 console=tty0 console=ttyS0,115200n8"
GRUB_DISABLE_LINUX_UUID="true"
GRUB_ENABLE_LINUX_LABEL="true"
GRUB_DISABLE_RECOVERY="true"

# Uncomment to automatically save last booted menu entry in GRUB2 environment

# variable `saved_entry'
# GRUB_SAVEDEFAULT="true"
#Uncomment to enable BadRAM filtering, modify to suit your needs

# This works with Linux (no patch required) and with any kernel that obtains
# the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)
# GRUB_BADRAM="0x01234567,0xfefefefe,0x89abcdef,0xefefefef"
#Uncomment to disable graphical terminal (grub-pc only)

GRUB_TERMINAL="gfxterm"
# The resolution used on graphical terminal
#note that you can use only modes which your graphic card supports via VBE

# you can see them in real GRUB with the command `vbeinfo'
GRUB_GFXMODE="auto"
# Uncomment if you don't want GRUB to pass "root=UUID=xxx" parameter to Linux
# GRUB_DISABLE_LINUX_UUID=true
#Uncomment to disable generation of recovery mode menu entries

# GRUB_DISABLE_RECOVERY="true"
#Uncomment to get a beep at grub start

# GRUB_INIT_TUNE="480 440 1"
GRUB_BACKGROUND=
GRUB_THEME=/boot/grub2/themes/openSUSE/theme.txt
SUSE_BTRFS_SNAPSHOT_BOOTING="true"
GRUB_DISABLE_OS_PROBER="false"
GRUB_ENABLE_CRYPTODISK="n"
GRUB_CMDLINE_XEN_DEFAULT="vga=gfx-1024x768x16"</code></pre>



<h4 id="4-1-2-使修改的-grub-内核配置生效">4.1.2 使修改的 grub 内核配置生效</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># grub2-mkconfig -o grub</code></pre>



<h4 id="4-2-将系统自动挂载的硬盘从使用-uuid-换成硬件路径4-2-1-显示根分区的-uuid">4.2 将系统自动挂载的硬盘从使用 uuid 换成硬件路径<br>4.2.1 显示根分区的 UUID</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># blkid
/dev/vda1: UUID="53ee2f87-89b8-4cd7-a4dc-0957d28f4831" TYPE="xfs" PARTUUID="3d8377ef-01"</code></pre>



<p>（补充：这里的 UUID 是： 53ee2f87-89b8-4cd7-a4dc-0957d28f4831）</p>



<h4 id="4-2-2-在自动挂载文件里将根分区的-uuid-换成硬件路径">4.2.2 在自动挂载文件里将根分区的 UUID 换成硬件路径</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/fstab</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
UUID=53ee2f87-89b8-4cd7-a4dc-0957d28f4831 /                   xfs     defaults        0 0</code></pre>



<p>（补充：这里的 UUID 是： 53ee2f87-89b8-4cd7-a4dc-0957d28f4831）</p>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
/dev/vda1 /                   xfs     defaults        0 0</code></pre>



<h4 id="4-3-删除不用的软件">4.3 删除不用的软件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># zypper -n rm firewalld-*</code></pre>



<h4 id="4-4-进行分区扩展4-4-1-安装分区扩展软件">4.4 进行分区扩展<br>4.4.1 安装分区扩展软件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># zypper -n in growpart</code></pre>



<h4 id="4-4-2-设置开机自动扩容根目录-4-4-2-1-创建开机自动扩容根目录的配置文件">4.4.2 设置开机自动扩容根目录<br>4.4.2.1 创建开机自动扩容根目录的配置文件</h4>



<pre class="wp-block-code"><code># vim /etc/init.d/after.local</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>/usr/bin/growpart /dev/sda1
/usr/sbin/xfs_growfs /</code></pre>



<h4 id="4-4-2-2-给开机自启配置文件相应的权限">4.4.2.2 给开机自启配置文件相应的权限</h4>



<pre class="wp-block-code"><code># chmod 755 /etc/init.d/after.local</code></pre>



<h4 id="4-5-只使用本地软件源-选做-4-5-1-禁用所有软件源-选做">4.5 只使用本地软件源（选做）<br>4.5.1 禁用所有软件源（选做）</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># zypper mr -da</code></pre>



<h4 id="4-5-2-添加本地软件源-选做">4.5.2 添加本地软件源（选做）</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># zypper ar -fcg http://10.0.0.254/openSUSE-Leap-15/ lan</code></pre>



<p>(注意： http://10.0.0.254/openSUSE-Leap-15/ 需要根据真实环境的情况进行更改)</p>



<h4 id="4-5-3-添加本地软件源-选做">4.5.3 添加本地软件源（选做）</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># zypper ref</code></pre>



<h4 id="4-6-修改虚拟机系统的名称">4.6 修改虚拟机系统的名称</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># hostnamectl set-hostname template_opensuse_leap_15_10g</code></pre>



<h4 id="4-7-启用-serial-服务实现通过-virsh-console-命令控制虚拟机">4.7 启用 serial 服务实现通过 virsh console 命令控制虚拟机</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl start serial-getty@ttyS0
# systemctl enable serial-getty@ttyS0</code></pre>



<h4 id="4-8-清除虚拟系统的历史命令">4.8 清除虚拟系统的历史命令</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># history -c</code></pre>



<h4 id="4-9-关闭虚拟机">4.9 关闭虚拟机</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># poweroff</code></pre>



<h4 id="步骤五-修改新创建的虚拟机配置文件">步骤五：修改新创建的虚拟机配置文件</h4>



<p>删除配置文件里 cdrom 相关的部分</p>



<pre class="wp-block-code"><code># vim /etc/libvirt/qemu/template_opensuse_leap_15_10g.xml</code></pre>



<p>删除以下内容：</p>



<pre class="wp-block-code"><code>......
    &lt;disk type='file' device='cdrom'&gt;
      &lt;driver name='qemu' type='raw'/&gt;
      &lt;source file='/test/iso/openSUSE-Leap-15.2-DVD-x86_64.iso'/&gt;
      &lt;target dev='sda' bus='sata'/&gt;
      &lt;readonly/&gt;
      &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
    &lt;/disk&gt;
......</code></pre>



<h4 id="步骤五-此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了">步骤六：此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了</h4>



<p>（只在真机上执行以下步骤）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>云计算简介</title>
		<link>https://eternalcenter-now.github.io/introduction-to-cloud-computing/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 23 Oct 2020 11:17:59 +0000</pubDate>
				<category><![CDATA[Articles (文章)]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Container Clouds (容器云)]]></category>
		<category><![CDATA[Information Technology (IT) Articles (信息技术类文章)]]></category>
		<category><![CDATA[Kubernetes (K8s)]]></category>
		<category><![CDATA[OpenShift]]></category>
		<category><![CDATA[OpenStack]]></category>
		<category><![CDATA[Virtualization Clouds (虚拟化云)]]></category>
		<category><![CDATA[Writings (写作)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=11583</guid>

					<description><![CDATA[云计算最早起源于亚马逊公司，后来 NASA（美国国家航空航天局）模仿亚马逊云做了一个开源的 OpenStack 云计算平台，之后又将这个项目交给了 Apache 基金会管理。如今 OpenStack 已成为云计算的代名词之一。 云计算的种类分为三种： IaaS 全名为：Infrastructure as a Service，基础设施即服务。是硬件的云，类似于 CPU、内存、硬盘等硬件的资源池。主要技术架构是开源的 OpenStack，同时也存在亚马逊云、谷歌云、阿里云等非开源的云。 PaaS 全名为：Platform as a Service，基础即服务。是服务的云，类似于 Tomcat、Nginx 等服务的资源池。主要技术架构是开源的 OpenShift 和 kubernetes 等。 SaaS 全名为：Software as a Service，软件即服务。是软件的云，相关的软件已经完全开发完成并进行云部署，例如微软的 OneDrive。]]></description>
										<content:encoded><![CDATA[
<p>云计算最早起源于亚马逊公司，后来 NASA（美国国家航空航天局）模仿亚马逊云做了一个开源的 OpenStack 云计算平台，之后又将这个项目交给了 Apache 基金会管理。如今 OpenStack 已成为云计算的代名词之一。</p>



<p class="has-medium-font-size">云计算的种类分为三种：</p>



<h2>IaaS</h2>



<p>全名为：Infrastructure as a Service，基础设施即服务。是硬件的云，类似于 CPU、内存、硬盘等硬件的资源池。主要技术架构是开源的 OpenStack，同时也存在亚马逊云、谷歌云、阿里云等非开源的云。</p>



<h2>PaaS</h2>



<p>全名为：Platform as a Service，基础即服务。是服务的云，类似于 Tomcat、Nginx 等服务的资源池。主要技术架构是开源的 OpenShift 和 kubernetes 等。</p>



<h2>SaaS</h2>



<p>全名为：Software as a Service，软件即服务。是软件的云，相关的软件已经完全开发完成并进行云部署，例如微软的 OneDrive。</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Docker 本地镜像的导出和导入</title>
		<link>https://eternalcenter-now.github.io/docker-image-local/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 06 Oct 2020 07:47:36 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=11344</guid>

					<description><![CDATA[注意： 在导入和导出本地 Docker 镜像之前，要先安装 Docker 正文： 步骤一：导出 Docker 本地镜像 （补充：将 latest 版本的 centos Docker 镜像导出为 centos.tar） 步骤二：导入 Docker 本地镜像 （补充：导入 centos.tar）]]></description>
										<content:encoded><![CDATA[
<h2>注意：</h2>



<p>在导入和导出本地 Docker 镜像之前，要先安装 Docker</p>



<div class="wp-container-3 wp-block-buttons is-content-justification-center">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/docker-install/">Docker 的安装</a></div>
</div>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>正文：</h2>



<h4>步骤一：导出 Docker 本地镜像</h4>



<pre class="wp-block-code"><code># docker save centos:latest &gt; centos.tar</code></pre>



<p>（补充：将 latest 版本的 centos Docker 镜像导出为 centos.tar）</p>



<h4>步骤二：导入 Docker 本地镜像</h4>



<pre class="wp-block-code"><code># docker load</code></pre>



<p>（补充：导入 centos.tar）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Docker 私有镜像仓库的搭建</title>
		<link>https://eternalcenter-now.github.io/docker-repository/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 06 Oct 2020 07:41:53 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=11342</guid>

					<description><![CDATA[注意： 在搭建私有 Docker 镜像仓库之前，要先安装 Docker 正文： 内容目录： 内容一：搭建私有 Dokcer 镜像仓库1.1 下载 registry 镜像1.2 加载并启动 registry 镜像1.3 确认 Docker 镜像仓库搭建成功 内容二：私有 Dokcer 镜像库的使用方法2.1 将现有的 Docker 镜像上传到私有 Docker 镜像库2.1.1 给现有的 Docker 镜像在私有 Docker 镜像库中打上一个新的标签2.1.2 将现有的 Docker 镜像上传到私有 Docker 镜像库2.2 显示私有的 Docker 镜像库2.2.1 显示私有的 Docker 镜像库中有那些镜像2.2.2 显示私有的 Docker 镜像库中某个镜像有哪些版本2.3 从私有的 Docker 镜像库中下载镜像 具体的内容： 内容一：搭建私有 Dokcer 镜像仓库1.1 下载 registry &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/docker-repository/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Docker 私有镜像仓库的搭建"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在搭建私有 Docker 镜像仓库之前，要先安装 Docker</p>



<div class="wp-container-4 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/docker-install/">Docker 的安装</a></div>
</div>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="内容目录">内容目录：</h2>



<h4 id="内容一-搭建私有-dokcer-镜像仓库1-1-下载-registry-镜像1-2-加载并启动-registry-镜像1-3-确认-docker-镜像仓库搭建成功">内容一：搭建私有 Dokcer 镜像仓库<br>1.1 下载 registry 镜像<br>1.2 加载并启动 registry 镜像<br>1.3 确认 Docker 镜像仓库搭建成功</h4>



<h4 id="内容二-私有-dokcer-镜像库的使用方法2-1-将现有的-docker-镜像上传到私有-docker-镜像库2-1-1-给现有的-docker-镜像在私有-docker-镜像库中打上一个新的标签2-1-2-将现有的-docker-镜像上传到私有-docker-镜像库2-2-显示私有的-docker-镜像库2-2-1-显示私有的-docker-镜像库中有那些镜像2-2-2-显示私有的-docker-镜像库中某个镜像有哪些版本2-3-从私有的-docker-镜像库中下载镜像">内容二：私有 Dokcer 镜像库的使用方法<br>2.1 将现有的 Docker 镜像上传到私有 Docker 镜像库<br>2.1.1 给现有的 Docker 镜像在私有 Docker 镜像库中打上一个新的标签<br>2.1.2 将现有的 Docker 镜像上传到私有 Docker 镜像库<br>2.2 显示私有的 Docker 镜像库<br>2.2.1 显示私有的 Docker 镜像库中有那些镜像<br>2.2.2 显示私有的 Docker 镜像库中某个镜像有哪些版本<br>2.3 从私有的 Docker 镜像库中下载镜像</h4>



<h2 id="具体的内容">具体的内容：</h2>



<h4 id="内容一-搭建私有-dokcer-镜像仓库1-1-下载-registry-镜像">内容一：搭建私有 Dokcer 镜像仓库<br>1.1 下载 registry 镜像</h4>



<pre class="wp-block-code"><code># docker pull registry</code></pre>



<h4 id="1-2-加载并启动-registry-镜像">1.2 加载并启动 registry 镜像</h4>



<pre class="wp-block-code"><code># docker run -d -p 5000:5000 registry
43c6b8c581e9039c8b7df12bb11a89dbdc9ff0b7e00fd6d345068aa9b5af7d9f</code></pre>



<p>（补充：这里以使用宿主机的 5000 端口为例）</p>



<h4 id="1-3-确认-docker-镜像仓库搭建成功">1.3 确认 Docker 镜像仓库搭建成功</h4>



<pre class="wp-block-code"><code># curl 127.0.0.1:5000/v2/
{}</code></pre>



<p>（补充：这里以显示 127.0.0.1:5000/v2/ 为例，出现大括号 “{}” 则表示搭建成功）</p>



<h4 id="内容二-私有-dokcer-镜像库的使用方法2-1-将现有的-docker-镜像上传到私有-docker-镜像库2-1-1-给现有的-docker-镜像在私有-docker-镜像库中打上一个新的标签">内容二：私有 Dokcer 镜像库的使用方法<br>2.1 将现有的 Docker 镜像上传到私有 Docker 镜像库<br>2.1.1 给现有的 Docker 镜像在私有 Docker 镜像库中打上一个新的标签</h4>



<pre class="wp-block-code"><code># docker tag centos:latest 127.0.0.1:5000/v2/centos:latest</code></pre>



<p>（补充：这里以将现有的 centos:latest 镜像打成 127.0.0.1:5000/v2/centos:latest 标签为例）</p>



<h4 id="2-1-2-将现有的-docker-镜像上传到私有-docker-镜像库">2.1.2 将现有的 Docker 镜像上传到私有 Docker 镜像库</h4>



<pre class="wp-block-code"><code># docker push 127.0.0.1:5000/centos:latest
The push refers to repository &#91;127.0.0.1:5000/centos]
291f6e44771a: Pushed 
latest: digest: sha256:fc4a234b91cc4b542bac8a6ad23b2ddcee60ae68fc4dbd4a52efb5f1b0baad71 size: 529</code></pre>



<p>（补充：这里以上传 127.0.0.1:5000/v2/centos:latest 为例）</p>



<h4 id="2-2-显示私有的-docker-镜像库2-2-1-显示私有的-docker-镜像库中有那些镜像">2.2 显示私有的 Docker 镜像库<br>2.2.1 显示私有的 Docker 镜像库中有那些镜像</h4>



<pre class="wp-block-code"><code># curl  http://127.0.0.1:5000/v2/_catalog
{"repositories":&#91;"centos"]}</code></pre>



<p>（补充：这里以显示 127.0.0.1:5000/v2/ 为例）</p>



<h4 id="2-2-2-显示私有的-docker-镜像库中某个镜像有哪些版本">2.2.2 显示私有的 Docker 镜像库中某个镜像有哪些版本</h4>



<pre class="wp-block-code"><code># curl  http://127.0.0.1:5000/v2/centos/tags/list
{"name":"centos","tags":&#91;"latest"]}</code></pre>



<p>（补充：这里以显示 http://127.0.0.1:5000/v2 上 centos 镜像的版本为例）</p>



<h4 id="2-3-从私有的-docker-镜像库中下载镜像">2.3 从私有的 Docker 镜像库中下载镜像</h4>



<pre class="wp-block-code"><code># docker pull 127.0.0.1:5000/v2/centos:latest
latest: Pulling from v2/centos
Digest: sha256:fc4a234b91cc4b542bac8a6ad23b2ddcee60ae68fc4dbd4a52efb5f1b0baad71
Status: Image is up to date for 127.0.0.1:5000/v2/centos:latest
127.0.0.1:5000/v2/centos:latest</code></pre>



<p>（补充：这里以下载 127.0.0.1:5000/v2/centos:latest 为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Docker 自定义镜像的创建</title>
		<link>https://eternalcenter-now.github.io/docker-image-create/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 06 Oct 2020 07:26:41 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=11340</guid>

					<description><![CDATA[注意： 在创建 Docker 自定义镜像之前，要先安装 Docker 正文： 步骤目录： 步骤一：基于现有的镜像进行手动配置后再创建 1.1 加载并启动 Docker 镜像1.2 对镜像里的系统进行操作并退出1.3 显示刚刚创建的容器1.4 将刚刚创建的容器转换成新镜像1.5 测试刚刚创建的新镜像是否可用 步骤二：基于现有的镜像使用配置文件修改后在创建2.1 创建使用镜像配置文件的目录2.2 创建镜像配置文件2.4 编辑镜像配置文件2.5 使用刚刚创建的镜像配置文件创建新的镜像2.6 测试刚刚创建的新镜像是否可用 具体的操作步骤：步骤一：基于现有的镜像进行手动配置后再创建1.1 加载并启动 Docker 镜像 （补充：1) 这里以加载并启动 centos 镜像为例2) -t 代表要开启一个伪终端3) -i 代表要保持打开并且可以进行标准输入） 1.2 对镜像里的系统进行操作并退出 （步骤略） 1.3 显示刚刚创建的容器 （补充：这里以显示到的容器 ID 是 d5cd7496a72c） 1.4 将刚刚创建的容器转换成新镜像 （补充：这里以通过 d5cd7496a72c 生成 v1 版本的 newos 为例） 1.5 测试刚刚创建的新镜像是否可用 （补充：这里以运行 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/docker-image-create/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Docker 自定义镜像的创建"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在创建 Docker 自定义镜像之前，要先安装 Docker</p>



<div class="wp-container-5 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/docker-install/">Docker 的安装</a></div>
</div>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-基于现有的镜像进行手动配置后再创建">步骤一：基于现有的镜像进行手动配置后再创建</h4>



<h4 id="1-1-加载并启动-docker-镜像1-2-对镜像里的系统进行操作并退出1-3-显示刚刚创建的容器1-4-将刚刚创建的容器转换成新镜像1-5-测试刚刚创建的新镜像是否可用">1.1 加载并启动 Docker 镜像<br>1.2 对镜像里的系统进行操作并退出<br>1.3 显示刚刚创建的容器<br>1.4 将刚刚创建的容器转换成新镜像<br>1.5 测试刚刚创建的新镜像是否可用</h4>



<h4 id="步骤二-基于现有的镜像使用配置文件修改后在创建2-1-创建使用镜像配置文件的目录2-2-创建镜像配置文件2-4-编辑镜像配置文件2-5-使用刚刚创建的镜像配置文件创建新的镜像2-6-测试刚刚创建的新镜像是否可用">步骤二：基于现有的镜像使用配置文件修改后在创建<br>2.1 创建使用镜像配置文件的目录<br>2.2 创建镜像配置文件<br>2.4 编辑镜像配置文件<br>2.5 使用刚刚创建的镜像配置文件创建新的镜像<br>2.6 测试刚刚创建的新镜像是否可用</h4>



<h4 id="具体的操作步骤-步骤一-基于现有的镜像进行手动配置后再创建1-1-加载并启动-docker-镜像">具体的操作步骤：<br>步骤一：基于现有的镜像进行手动配置后再创建<br>1.1 加载并启动 Docker 镜像</h4>



<pre class="wp-block-code"><code># docker run -it centos</code></pre>



<p>（<br>补充：<br>1) 这里以加载并启动 centos 镜像为例<br>2) -t 代表要开启一个伪终端<br>3) -i 代表要保持打开并且可以进行标准输入<br>）</p>



<h4 id="1-2-对镜像里的系统进行操作并退出">1.2 对镜像里的系统进行操作并退出</h4>



<p>（步骤略）</p>



<h4 id="1-3-显示刚刚创建的容器">1.3 显示刚刚创建的容器</h4>



<pre class="wp-block-code"><code># docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS               NAMES
d5cd7496a72c        centos              "/bin/bash"              37 seconds ago      Exited (0) 14 seconds ago                       ecstatic_bassi</code></pre>



<p>（补充：这里以显示到的容器 ID 是 d5cd7496a72c）</p>



<h4 id="1-4-将刚刚创建的容器转换成新镜像">1.4 将刚刚创建的容器转换成新镜像</h4>



<pre class="wp-block-code"><code># docker commit d5cd7496a72c newos:v1 </code></pre>



<p>（补充：这里以通过 d5cd7496a72c 生成 v1 版本的 newos 为例）</p>



<h4 id="1-5-测试刚刚创建的新镜像是否可用">1.5 测试刚刚创建的新镜像是否可用</h4>



<pre class="wp-block-code"><code># docker run -it newos</code></pre>



<p>（补充：这里以运行 newos 镜像为例）</p>



<h4 id="步骤二-基于现有的镜像使用配置文件修改后在创建2-1-创建使用镜像配置文件的目录">步骤二：基于现有的镜像使用配置文件修改后在创建<br>2.1 创建使用镜像配置文件的目录</h4>



<pre class="wp-block-code"><code># mkdir -p ~/newhttpd</code></pre>



<p>（补充：这里以创建 newhttpd 目录为例）</p>



<h4 id="2-3-将-yum-的从库文件放到镜像配置文件的目录">2.3 将 yum 的从库文件放到镜像配置文件的目录</h4>



<pre class="wp-block-code"><code># cp /etc/yum.repos.d/local.repo ~/newhttpd</code></pre>



<p>（补充：这里以将在次环境里可用的 yum 配置文件 /etc/yum.repos.d/local.repo 拷贝到 ~/newhttpd/ 为例）</p>



<h4 id="2-3-创建镜像配置文件">2.3 创建镜像配置文件</h4>



<pre class="wp-block-code"><code># touch ~/newhttpd/Dockerfile</code></pre>



<p>（补充：这里以创建 ~/newhttpd/Dockerfile 文件为例）</p>



<h4 id="2-4-编辑镜像配置文件">2.4 编辑镜像配置文件</h4>



<pre class="wp-block-code"><code># vim ~/newhttpd/Dockerfile</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>FROM centos:latest
RUN yum -y install httpd
ENV EnvironmentFile=/etc/sysconfig/httpd
WORKDIR /var/www/html/
RUN echo "test" &gt; /var/www/html/index.html
EXPOSE 80
CMD &#91;"/usr/sbin/httpd", "-DFOREGROUND"]</code></pre>



<p>（<br>补充：<br>1) FROM 要从哪一个镜像克隆而来，这里以从 centos:latest 克隆为例<br>2) MAINTAINER 要说明的信息<br>3) ENV 要设置的环境变量，这里以使用以下文件作为配置文件为例：</p>



<pre class="wp-block-code"><code>/etc/sysconfig/httpd</code></pre>



<p>4) WORKDIR 要设置的工作目录，这里以使用以下目录作为工作目录为例：<br>/var/www/html/<br>5) RUN 在生成镜像时要执行的命令，可以有多条，这里以执行以下命令为例：</p>



<pre class="wp-block-code"><code>echo "test" &gt; /var/www/html/index.html</code></pre>



<p>6) CMD 容器启动时要执行的命令，只能有一条，这里以执行以下命令为例：</p>



<pre class="wp-block-code"><code>"/usr/sbin/httpd", "-DFOREGROUND"</code></pre>



<p>7) ADD 要复制的文件<br>8) EXPOSE 要开放的端口，这里以使用 80 端口为例<br>）</p>



<h4 id="2-5-使用刚刚创建的镜像配置文件创建新的镜像">2.5 使用刚刚创建的镜像配置文件创建新的镜像</h4>



<pre class="wp-block-code"><code># docker build -t newos:httpd ~/newhttpd</code></pre>



<p>（补充：这里以通过 ~/newhttpd 里的配置信息生成为名 newos 版本为 httpd 的容器为例）</p>



<h4 id="2-6-测试刚刚创建的新镜像是否可用">2.6 测试刚刚创建的新镜像是否可用</h4>



<pre class="wp-block-code"><code># docker run -d newos:http</code></pre>



<p>（补充：这里以测试名为 newos 版本为 httpd 的容器为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Docker 虚拟网桥的创建</title>
		<link>https://eternalcenter-now.github.io/docker-network/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 06 Oct 2020 07:20:02 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=11338</guid>

					<description><![CDATA[注意： 在创建 Docker 虚拟网桥之前，要先安装 Docker 正文： 步骤一：创建 Docker 的虚拟网桥 （补充：这里以创建网段为 172.16.0.0/24 名为 dockernetwork 为例） 步骤二：显示创建的虚拟网桥 步骤三：使用创建的虚拟网桥加载并启动 Docker 镜像 （补充：这里以使用 dockernetwork 开启 nginx 镜像为例） 步骤四：创建端口映射 （补充：这里以将宿主机的 8080 端口映射到 nginx 容器的 80 端口为例） 步骤五：显示端口映射是否实现 （补充：这里以显示宿主机的 8080 端口为例）]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在创建 Docker 虚拟网桥之前，要先安装 Docker</p>



<div class="wp-container-6 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/docker-install/">Docker 的安装</a></div>
</div>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h4 id="步骤一-创建-docker-的虚拟网桥">步骤一：创建 Docker 的虚拟网桥</h4>



<pre class="wp-block-code"><code># docker network create --subnet=172.16.0.0/24 dockernetwork</code></pre>



<p>（补充：这里以创建网段为 172.16.0.0/24 名为 dockernetwork 为例）</p>



<h4 id="步骤二-显示创建的虚拟网桥">步骤二：显示创建的虚拟网桥</h4>



<pre class="wp-block-code"><code># docker network list</code></pre>



<h4 id="步骤三-使用创建的虚拟网桥加载并启动-docker-镜像">步骤三：使用创建的虚拟网桥加载并启动 Docker 镜像</h4>



<pre class="wp-block-code"><code># docker run --network=dockernetwork -id nginx</code></pre>



<p>（补充：这里以使用 dockernetwork 开启 nginx 镜像为例）</p>



<h4 id="步骤四-创建端口映射">步骤四：创建端口映射</h4>



<pre class="wp-block-code"><code># docker run -p 8080:80 -id nginx</code></pre>



<p>（补充：这里以将宿主机的 8080 端口映射到 nginx 容器的 80 端口为例）</p>



<h4 id="步骤五-显示端口映射是否实现">步骤五：显示端口映射是否实现</h4>



<pre class="wp-block-code"><code># curl 127.0.0.1:8080</code></pre>



<p>（补充：这里以显示宿主机的 8080 端口为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Docker 容器的使用</title>
		<link>https://eternalcenter-now.github.io/docker-use/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 06 Oct 2020 07:09:05 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=11335</guid>

					<description><![CDATA[注意： 在使用 Docker 容器之前，要先安装 Docker 正文： 内容目录： 内容一：加载并启动 Docker 镜像1.1 在前台启动 Docker 镜像1.1.1 在非交互模式下在前台加载并启动 Docker 镜像1.1.1.1 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令1.1.1.1.1 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令的格式1.1.1.1.2 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令的案例1.1.1.2 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令1.1.1.2.1 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令的格式1.1.1.2.2 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令的案例1.1.2 在交互模式下在前台加载并启动 Docker 镜像1.1.2.1 在交互模式下在前台加载并启动 Docker 镜像的格式1.1.2.2 在交互模式下在前台启动 Docker 镜像的案例1.2 在后台启动 Docker 镜像1.2.1 在后台启动 Docker 镜像的格式1.2.2 在后台启动 Docker 镜像的案例 步骤二：将容器的端口号映射宿主机的端口号2.1 将容器的端口号映射宿主机的端口号的格式2.2 将容器的端口映射宿主机的端口的案例 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/docker-use/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Docker 容器的使用"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在使用 Docker 容器之前，要先安装 Docker</p>



<div class="wp-container-7 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/docker-install/">Docker 的安装</a></div>
</div>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="内容目录">内容目录：</h2>



<h4 id="内容一-加载并启动-docker-镜像1-1-在前台启动-docker-镜像1-1-1-在非交互模式下在前台加载并启动-docker-镜像1-1-1-1-在非交互模式下在前台加载并启动-docker-镜像但不执行命令1-1-1-1-1-在非交互模式下在前台加载并启动-docker-镜像但不执行命令的格式1-1-1-1-2-在非交互模式下在前台加载并启动-docker-镜像但不执行命令的案例1-1-1-2-在非交互模式下在前台加载并启动-docker-镜像同时执行命令1-1-1-2-1-在非交互模式下在前台加载并启动-docker-镜像同时执行命令的格式1-1-1-2-2-在非交互模式下在前台加载并启动-docker-镜像同时执行命令的案例1-1-2-在交互模式下在前台加载并启动-docker-镜像1-1-2-1-在交互模式下在前台加载并启动-docker-镜像的格式1-1-2-2-在交互模式下在前台启动-docker-镜像的案例1-2-在后台启动-docker-镜像1-2-1-在后台启动-docker-镜像的格式1-2-2-在后台启动-docker-镜像的案例">内容一：加载并启动 Docker 镜像<br>1.1 在前台启动 Docker 镜像<br>1.1.1 在非交互模式下在前台加载并启动 Docker 镜像<br>1.1.1.1 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令<br>1.1.1.1.1 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令的格式<br>1.1.1.1.2 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令的案例<br>1.1.1.2 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令<br>1.1.1.2.1 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令的格式<br>1.1.1.2.2 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令的案例<br>1.1.2 在交互模式下在前台加载并启动 Docker 镜像<br>1.1.2.1 在交互模式下在前台加载并启动 Docker 镜像的格式<br>1.1.2.2 在交互模式下在前台启动 Docker 镜像的案例<br>1.2 在后台启动 Docker 镜像<br>1.2.1 在后台启动 Docker 镜像的格式<br>1.2.2 在后台启动 Docker 镜像的案例</h4>



<h4 id="步骤二-将容器的端口号映射宿主机的端口号2-1-将容器的端口号映射宿主机的端口号的格式2-2-将容器的端口映射宿主机的端口的案例">步骤二：将容器的端口号映射宿主机的端口号<br>2.1 将容器的端口号映射宿主机的端口号的格式<br>2.2 将容器的端口映射宿主机的端口的案例</h4>



<h4 id="步骤三-将宿主机上的文件或目录映射到容器的文件或目录里3-1-将宿主机上的文件或目录映射到容器的文件或目录里的格式3-2-将宿主机上的文件或目录映射到容器的文件或目录里的案例">步骤三：将宿主机上的文件或目录映射到容器的文件或目录里<br>3.1 将宿主机上的文件或目录映射到容器的文件或目录里的格式<br>3.2 将宿主机上的文件或目录映射到容器的文件或目录里的案例</h4>



<h4 id="步骤四-显示容器列表4-1-显示正在运行的容器列表4-2-显示所有加载并运行过或正在运行的容器列表">步骤四：显示容器列表<br>4.1 显示正在运行的容器列表<br>4.2 显示所有加载并运行过或正在运行的容器列表</h4>



<h4 id="步骤五-显示容器的信息5-1-显示容器在运行的进程5-2-显示容器的-ip-地址5-3-显示容器的-mac-地址">步骤五：显示容器的信息<br>5.1 显示容器在运行的进程<br>5.2 显示容器的 IP 地址<br>5.3 显示容器的 MAC 地址</h4>



<h4 id="步骤六-连接某一个容器6-1-连接接某一个容器但是退出时会关闭这个容器6-2-连接某一个容器且退出时不会关闭这个容器6-3-以非交互的形式连接一个容器">步骤六：连接某一个容器<br>6.1 连接接某一个容器但是退出时会关闭这个容器<br>6.2 连接某一个容器且退出时不会关闭这个容器<br>6.3 以非交互的形式连接一个容器</h4>



<h4 id="步骤七-重启某一个容器">步骤七：重启某一个容器</h4>



<h4 id="步骤八-启动某一个已经停止的容器">步骤八：启动某一个已经停止的容器</h4>



<h4 id="步骤九-删除某一个容器">步骤九：删除某一个容器</h4>



<h2 id="具体的内容">具体的内容：</h2>



<h4 id="内容一-加载并启动-docker-镜像1-1-在前台启动-docker-镜像1-1-1-在非交互模式下在前台加载并启动-docker-镜像1-1-1-1-在非交互模式下在前台加载并启动-docker-镜像但不执行命令1-1-1-1-1-在非交互模式下在前台加载并启动-docker-镜像但不执行命令的格式">内容一：加载并启动 Docker 镜像<br>1.1 在前台启动 Docker 镜像<br>1.1.1 在非交互模式下在前台加载并启动 Docker 镜像<br>1.1.1.1 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令<br>1.1.1.1.1 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令的格式</h4>



<pre class="wp-block-code"><code># docker run &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>3) 镜像启动了之后就变成容器了<br>）</p>



<h4 id="1-1-1-1-2-在非交互模式下在前台加载并启动-docker-镜像但不执行命令的案例">1.1.1.1.2 在非交互模式下在前台加载并启动 Docker 镜像但不执行命令的案例</h4>



<pre class="wp-block-code"><code># docker run centos</code></pre>



<p>（补充：这里以非交互式加载并启动 centos 镜像 为例）</p>



<h4 id="1-1-1-2-在非交互模式下在前台加载并启动-docker-镜像同时执行命令1-1-1-2-1-在非交互模式下在前台加载并启动-docker-镜像同时执行命令的格式">1.1.1.2 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令<br>1.1.1.2.1 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令的格式</h4>



<pre class="wp-block-code"><code># docker run &lt;image ID or image name&gt; &lt;command in image&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>3) 镜像启动了之后就变成容器了<br>）</p>



<h4 id="1-1-1-2-2-在非交互模式下在前台加载并启动-docker-镜像同时执行命令的案例">1.1.1.2.2 在非交互模式下在前台加载并启动 Docker 镜像同时执行命令的案例</h4>



<pre class="wp-block-code"><code># docker run centos /bin/echo 'Hello world'
Hello world</code></pre>



<p>（补充：这里以非交互式加载并启动 centos 镜像，并执行 /bin/echo &#8216;Hello world&#8217; 为例）</p>



<h4 id="1-1-2-在交互模式下在前台加载并启动-docker-镜像1-1-2-1-在交互模式下在前台加载并启动-docker-镜像的格式">1.1.2 在交互模式下在前台加载并启动 Docker 镜像<br>1.1.2.1 在交互模式下在前台加载并启动 Docker 镜像的格式</h4>



<pre class="wp-block-code"><code># docker run centos -t -i &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>3) 镜像启动了之后就变成容器了<br>4) -i 代表要保持打开并且可以进行标准输入<br>5) -t 代表要开启一个伪终端<br>）</p>



<h4 id="1-1-2-2-在交互模式下在前台启动-docker-镜像的案例">1.1.2.2 在交互模式下在前台启动 Docker 镜像的案例</h4>



<pre class="wp-block-code"><code># docker run -t -i centos
&#91;root@1a7d6f4fd45c /]# exit
exit</code></pre>



<p>（<br>补充：<br>1) 这里以交互式加载并启动 centos 镜像，再退出为例<br>2) -i 代表要保持打开并且可以进行标准输入<br>3) -t 代表要开启一个伪终端<br>4) 默认会进入 bash 环境<br>）</p>



<p>或者：</p>



<pre class="wp-block-code"><code># docker run -it centos
 bash
&#91;root@1a7d6f4fd45c /]# exit
exit</code></pre>



<p>（<br>补充：<br>1) 这里以交互式加载并启动 centos 镜像，再退出为例<br>2) -i 代表要保持打开并且可以进行标准输入<br>3) -t 代表要开启一个伪终端<br>4) bash 代表通过 bash 命令来进入 bash 环境<br>）</p>



<h4 id="1-2-在后台启动-docker-镜像1-2-1-在后台启动-docker-镜像的格式">1.2 在后台启动 Docker 镜像<br>1.2.1 在后台启动 Docker 镜像的格式</h4>



<pre class="wp-block-code"><code># docker run -tid &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>3) 镜像启动了之后就变成容器了<br>4) -i 代表要保持打开并且可以进行标准输入<br>5) -t 代表要开启一个伪终端<br>6) -d 代表放在后台运行<br>）</p>



<h4 id="1-2-2-在后台启动-docker-镜像的案例">1.2.2 在后台启动 Docker 镜像的案例</h4>



<pre class="wp-block-code"><code># docker run -itd centos</code></pre>



<p>（<br>补充：<br>1) 这里以在后台加载并启动 centos 镜像为例<br>2) -i 代表要保持打开并且可以进行标准输入<br>3) -t 代表要开启一个伪终端<br>4) -d 代表放在后台运行<br>）</p>



<h4 id="步骤二-将容器的端口号映射宿主机的端口号2-1-将容器的端口号映射宿主机的端口号的格式">步骤二：将容器的端口号映射宿主机的端口号<br>2.1 将容器的端口号映射宿主机的端口号的格式</h4>



<pre class="wp-block-code"><code># docker run -d -p &lt;the port number of the host&gt;:&lt;the port number of the container&gt; -it &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 需要在加载并启动镜像时执行此步骤<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的容器，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>3) 镜像启动了之后就变成容器了<br>4) -d 代表放在后台运行<br>5) -p 代表要做端口映射<br>6) -i 代表要保持打开并且可以进行标准输入<br>7) -t 代表要开启一个伪终端<br>）</p>



<h4 id="2-2-将容器的端口映射宿主机的端口的案例">2.2 将容器的端口映射宿主机的端口的案例</h4>



<pre class="wp-block-code"><code># docker run -d -p 8080:80 -it nginx</code></pre>



<p>（补充：这里以启动 nginx 镜像，并将宿主机的 8080 端口映射到容器的 80 端口为例）</p>



<h4 id="步骤三-将宿主机上的文件或目录映射到容器的文件或目录里3-1-将宿主机上的文件或目录映射到容器的文件或目录里的格式">步骤三：将宿主机上的文件或目录映射到容器的文件或目录里<br>3.1 将宿主机上的文件或目录映射到容器的文件或目录里的格式</h4>



<pre class="wp-block-code"><code># docker run -d -v &lt;a file or directory on the host&gt;:&lt;a file or directory on the container&gt; -it &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 需要在加载并启动镜像时执行此步骤<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的容器，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>3) 镜像启动了之后就变成容器了<br>4) -d 代表放在后台运行<br>5) -v 代表要做文件或目录映射<br>6) -i 代表要保持打开并且可以进行标准输入<br>7) -t 代表要开启一个伪终端<br>）</p>



<h4 id="3-2-将宿主机上的文件或目录映射到容器的文件或目录里的案例">3.2 将宿主机上的文件或目录映射到容器的文件或目录里的案例</h4>



<pre class="wp-block-code"><code># docker run  -d -v /tmp/web:/var/www/html -it nginx</code></pre>



<p>（补充：这里以启动 nginx 镜像，并将宿主机的目录/tmp/web 映射到容器的目录 /var/www/html 为例）</p>



<h4 id="步骤四-显示容器列表4-1-显示正在运行的容器列表">步骤四：显示容器列表<br>4.1 显示正在运行的容器列表</h4>



<pre class="wp-block-code"><code># docker ps</code></pre>



<h4 id="4-2-显示所有加载并运行过或正在运行的容器列表">4.2 显示所有加载并运行过或正在运行的容器列表</h4>



<pre class="wp-block-code"><code># docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
e145ad3588ed        centos              "/bin/bash"         19 seconds ago      Exited (0) 17 seconds ago                       thirsty_mcnulty</code></pre>



<h4 id="步骤五-显示容器的信息5-1-显示容器在运行的进程">步骤五：显示容器的信息<br>5.1 显示容器在运行的进程</h4>



<pre class="wp-block-code"><code># docker top &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>



<h4 id="5-2-显示容器的-ip-地址">5.2 显示容器的 IP 地址</h4>



<pre class="wp-block-code"><code># docker inspect -f '{{.NetworkSettings.IPAddress}}' &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>



<h4 id="5-3-显示容器的-mac-地址">5.3 显示容器的 MAC 地址</h4>



<pre class="wp-block-code"><code># docker inspect -f '{{.NetworkSettings.MacAddress}}' &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>



<h4 id="步骤六-连接某一个容器6-1-连接某一个容器但是退出时会关闭这个容器">步骤六：连接某一个容器<br>6.1 连接某一个容器但是退出时会关闭这个容器</h4>



<pre class="wp-block-code"><code># docker attach &lt;image ID or image name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>



<h4 id="6-2-连接某一个容器且退出时不会关闭这个容器">6.2 连接某一个容器且退出时不会关闭这个容器</h4>



<pre class="wp-block-code"><code># docker exec -it &lt;image ID or image name&gt; /bin/bash</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) -i 代表要保持打开并且可以进行标准输入<br>3) -t 代表要开启一个伪终端<br>4) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>



<h4 id="6-3-以非交互的形式连接一个容器">6.3 以非交互的形式连接一个容器</h4>



<pre class="wp-block-code"><code># docker exec -t &lt;image ID or image name&gt; &lt;command&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用镜像名无效就使用镜像的 ID<br>2) -t 代表要开启一个伪终端<br>3) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的镜像，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>



<h4 id="步骤七-重启某一个容器">步骤七：重启某一个容器</h4>



<pre class="wp-block-code"><code># docker restart &lt;container ID or container name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用容器名无效就使用容器的 ID<br>2) 如果容器的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的容器，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>



<h4 id="步骤八-启动某一个已经停止的容器">步骤八：启动某一个已经停止的容器</h4>



<pre class="wp-block-code"><code># docker stop &lt;container ID or container name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用容器名无效就使用容器的 ID<br>2) 如果镜像的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的容器，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>



<h4 id="步骤九-删除某一个容器">步骤九：删除某一个容器</h4>



<pre class="wp-block-code"><code># docker rm &lt;container ID or container name&gt;</code></pre>



<p>（<br>补充：<br>1) 如果使用容器名无效就使用容器的 ID<br>2) 如果容器的 ID 只有一个 9 开头，那就只用使用 9 ，如果有 94 和 95 开头的容器，就需要使用 94 或 95，反正需要保证它们的唯一性，否则会一次性操作所有相关的镜像<br>）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Docker 官方镜像的下载</title>
		<link>https://eternalcenter-now.github.io/docker-image-download/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 06 Oct 2020 07:03:56 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=11331</guid>

					<description><![CDATA[注意： 在下载 Docker 官方镜像之前，要先安装 Docker 正文： 步骤目录： 步骤一：使用 Docker 官方的代理加速器1.1 修改 Docker 的配置文件1.2 重启 Docker 服务 步骤二：显示本地已有的 Docker 镜像 步骤三：查找某一个官方库里的 Docker 镜像3.1 查找某一个官方库里的 Docker 镜像的格式3.2 查找某一个官方库里的 Docker 镜像名的案例 步骤四：下载某一个官方库里的 Docker 镜像4.1 下载某一个官方库里的 Docker 镜像的格式4.1.1 下载某一个官方库里最新版的 Docker 镜像的格式4.1.2 下载某一个官方库里旧的指定版的 Docker 镜像的格式4.2 下载某一个官方库里的 Docker 镜像的案例4.2.1 下载某一个官方库里最新版的 Docker 镜像的案例4.2.2 下载某一个官方库里旧的指定版的 Docker 镜像的案例 步骤五：显示官方库里 Docker 镜像是否成功下载到本地 步骤六：删除 Docker 本地镜像 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/docker-image-download/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Docker 官方镜像的下载"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在下载 Docker 官方镜像之前，要先安装 Docker</p>



<div class="wp-container-8 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/docker-install/">Docker 的安装</a></div>
</div>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-使用-docker-官方的代理加速器1-1-修改-docker-的配置文件1-2-重启-docker-服务">步骤一：使用 Docker 官方的代理加速器<br>1.1 修改 Docker 的配置文件<br>1.2 重启 Docker 服务</h4>



<h4 id="步骤二-查看本地已有的-docker-镜像">步骤二：显示本地已有的 Docker 镜像</h4>



<h4 id="步骤三-查找某一个官方库里的-docker-镜像3-1-查找某一个官方库里的-docker-镜像的格式3-2-查找某一个官方库里的-docker-镜像名的案例">步骤三：查找某一个官方库里的 Docker 镜像<br>3.1 查找某一个官方库里的 Docker 镜像的格式<br>3.2 查找某一个官方库里的 Docker 镜像名的案例</h4>



<h4 id="步骤四-下载某一个官方库里的-docker-镜像4-1-下载某一个官方库里的-docker-镜像的格式4-1-1-下载某一个官方库里最新版的-docker-镜像的格式4-1-2-下载某一个官方库里旧的指定版的-docker-镜像的格式4-2-下载某一个官方库里的-docker-镜像的案例4-2-1-下载某一个官方库里最新版的-docker-镜像的案例4-2-2-下载某一个官方库里旧的指定版的-docker-镜像的案例">步骤四：下载某一个官方库里的 Docker 镜像<br>4.1 下载某一个官方库里的 Docker 镜像的格式<br>4.1.1 下载某一个官方库里最新版的 Docker 镜像的格式<br>4.1.2 下载某一个官方库里旧的指定版的 Docker 镜像的格式<br>4.2 下载某一个官方库里的 Docker 镜像的案例<br>4.2.1 下载某一个官方库里最新版的 Docker 镜像的案例<br>4.2.2 下载某一个官方库里旧的指定版的 Docker 镜像的案例</h4>



<h4 id="步骤五-查看官方库里-docker-镜像是否成功下载到本地">步骤五：显示官方库里 Docker 镜像是否成功下载到本地</h4>



<h4 id="步骤六-删除-docker-本地镜像">步骤六：删除 Docker 本地镜像</h4>



<h4 id="步骤七-上传-docker-本地镜像">步骤七： 上传 Docker 本地镜像</h4>



<h4 id="具体的操作步骤-步骤一-使用-docker-官方的代理加速器1-1-修改-docker-的配置文件">具体的操作步骤：<br>步骤一：使用 Docker 官方的代理加速器<br>1.1 修改 Docker 的配置文件</h4>



<pre class="wp-block-code"><code># vim /etc/docker/daemon.json</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
}</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
  "registry-mirrors": &#91;"https://registry.docker-cn.com/"],
}</code></pre>



<p>（<br>补充：<br>1) 此步骤是为了避免因网络问题导致下载官方 Docker 镜像不成功的情况<br>2) 主要目的是为了将 &#8220;registry-mirrors&#8221;: [&#8220;https://registry.docker-cn.com&/#8221;], 放在大括号 “{}” 内<br>）</p>



<h4 id="1-2-重启-docker-服务">1.2 重启 Docker 服务</h4>



<pre class="wp-block-code"><code># systemctl restart docker</code></pre>



<h4 id="步骤二-查看本地已有的-docker-镜像">步骤二：显示本地已有的 Docker 镜像</h4>



<pre class="wp-block-code"><code># docker images</code></pre>



<h4 id="步骤三-查找某一个官方库里的-docker-镜像3-1-查找某一个官方库里的-docker-镜像的格式">步骤三：查找某一个官方库里的 Docker 镜像<br>3.1 查找某一个官方库里的 Docker 镜像的格式</h4>



<pre class="wp-block-code"><code># docker search &lt;image&gt; </code></pre>



<h4 id="3-2-查找某一个官方库里的-docker-镜像名的案例">3.2 查找某一个官方库里的 Docker 镜像名的案例</h4>



<pre class="wp-block-code"><code># docker search centos</code></pre>



<p>（<br>补充：<br>1) 这里以查找 centos 镜像为例<br>2) 这里默认会从公网 docker.io 的官方镜像库里查找<br>3) 如果在查找的 DESCRIPTION 里出现了类似 The official build 的字样，则表示这个镜像是由官方制作的<br>）</p>



<h4 id="步骤四-下载某一个官方库里的-docker-镜像4-1-下载某一个官方库里的-docker-镜像的格式4-1-1-下载某一个官方库里最新版的-docker-镜像的格式">步骤四：下载某一个官方库里的 Docker 镜像<br>4.1 下载某一个官方库里的 Docker 镜像的格式<br>4.1.1 下载某一个官方库里最新版的 Docker 镜像的格式</h4>



<pre class="wp-block-code"><code># docker pull &lt;image&gt;</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># docker pull &lt;image&gt;:latest</code></pre>



<h4 id="4-1-2-下载某一个官方库里旧的指定版的-docker-镜像的格式">4.1.2 下载某一个官方库里旧的指定版的 Docker 镜像的格式</h4>



<pre class="wp-block-code"><code># docker pull &lt;image&gt;:&lt;version&gt;</code></pre>



<h4 id="4-2-下载某一个官方库里的-docker-镜像的案例4-2-1-下载某一个官方库里最新版的-docker-镜像的案例">4.2 下载某一个官方库里的 Docker 镜像的案例<br>4.2.1 下载某一个官方库里最新版的 Docker 镜像的案例</h4>



<pre class="wp-block-code"><code># docker pull centos
Using default tag: latest
latest: Pulling from library/centos
3c72a8ed6814: Pull complete 
Digest: sha256:76d24f3ba3317fa945743bb3746fbaf3a0b752f10b10376960de01da70685fbd
Status: Downloaded newer image for centos:latest
docker.io/library/centos:latest</code></pre>



<p>（<br>补充：<br>1) 这里以下载 centos 镜像为例<br>2) 这里默认会从公网 docker.io 的官方镜像库里下载<br>）</p>



<h4 id="4-2-2-下载某一个官方库里旧的指定版的-docker-镜像的案例">4.2.2 下载某一个官方库里旧的指定版的 Docker 镜像的案例</h4>



<pre class="wp-block-code"><code># docker pull nginx:1
1: Pulling from library/nginx
d121f8d1c412: Downloading &#91;============&gt;                                      ]  6.728MB/27.09MB
ebd81fc8c071: Downloading &#91;===============&gt;                                   ]  8.289MB/26.4MB
655316c160af: Download complete                                                                                                                                 d121f8d1c412: Pull complete 
ebd81fc8c071: Pull complete 
655316c160af: Pull complete 
d15953c0e0f8: Pull complete 
2ee525c5c3cc: Pull complete 
Digest: sha256:c628b67d21744fce822d22fdcc0389f6bd763daac23a6b77147d0712ea7102d0
Status: Downloaded newer image for nginx:1
docker.io/library/nginx:1</code></pre>



<p>（<br>补充：<br>1) 这里以下载 nginx 的 1 版本为例<br>2) 这里默认会从公网 docker.io 的官方镜像库里下载<br>）</p>



<h4 id="步骤五-查看官方库里-docker-镜像是否成功下载到本地">步骤五：显示官方库里 Docker 镜像是否成功下载到本地</h4>



<pre class="wp-block-code"><code># docker images
REPOSITORY                                    TAG                 IMAGE ID            CREATED             SIZE
centos                                        latest              0d120b6ccaa8        7 weeks ago         215MB
nginx                                         1                   7e4d58f0e5f3        3 weeks ago         133MB</code></pre>



<h4 id="步骤六-删除-docker-本地镜像">步骤六：删除 Docker 本地镜像</h4>



<pre class="wp-block-code"><code># docker rmi &lt;image&gt;</code></pre>



<h4 id="步骤七-上传-docker-本地镜像">步骤七： 上传 Docker 本地镜像</h4>



<pre class="wp-block-code"><code># docker push &lt;image&gt;</code></pre>



<p>（补充：这里默认会往公网 docker.io 的官方镜像库里上传）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Docker 信息的显示</title>
		<link>https://eternalcenter-now.github.io/docker-info/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 04 Oct 2020 09:50:40 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=10625</guid>

					<description><![CDATA[注意： 在显示 Docker 信息之前要先安装 Docker 正文： 内容一：显示 Docker 软件的基本信息 内容二：显示 Docker 软件命令的帮助信息]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在显示 Docker 信息之前要先安装 Docker</p>



<div class="wp-container-9 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/docker-install/">Docker 的安装</a></div>
</div>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h4 id="内容一-显示-docker-软件的基本信息">内容一：显示 Docker 软件的基本信息</h4>



<pre class="wp-block-code"><code># docker info</code></pre>



<h4 id="内容二-显示-docker-软件命令的帮助信息">内容二：显示 Docker 软件命令的帮助信息</h4>



<pre class="wp-block-code"><code># docker help</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Docker 的安装</title>
		<link>https://eternalcenter-now.github.io/docker-install/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 04 Oct 2020 09:38:01 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=10623</guid>

					<description><![CDATA[步骤一：系统环境要求 服务器系统要配置好可用的软件源 步骤二：安装 Docker2.1 CentOS&#38;RHEL 安装 Docker 2.2 openSUSE&#38;SUSE 安装 Docker （注意：从 CentOS&#38;RHEL 8 开始，CentOS&#38;RHEL 将用 podman 替代 Docker，所以 CentOS&#38;RHEL 官方库中不再包含 Docker 的软件包） 步骤三：启动 Docker 步骤四：显示 Docker 的信息]]></description>
										<content:encoded><![CDATA[
<h4 id="步骤一-系统环境要求">步骤一：系统环境要求</h4>



<p>服务器系统要配置好可用的软件源</p>



<h4 id="步骤二-安装-docker2-1-centos-rhel-安装-docker">步骤二：安装 Docker<br>2.1 CentOS&amp;RHEL 安装 Docker</h4>



<pre class="wp-block-code"><code># yum -y install docker</code></pre>



<h4 id="2-2-opensuse-suse-安装-docker">2.2 openSUSE&amp;SUSE 安装 Docker</h4>



<pre class="wp-block-code"><code># zypper -n install docker</code></pre>



<p>（注意：从 CentOS&amp;RHEL 8 开始，CentOS&amp;RHEL 将用 podman 替代 Docker，所以 CentOS&amp;RHEL 官方库中不再包含 Docker 的软件包）</p>



<h4 id="步骤三-启动-docker">步骤三：启动 Docker</h4>



<pre class="wp-block-code"><code># systemctl start docker</code></pre>



<h4 id="步骤四-显示-docker-的信息">步骤四：显示 Docker 的信息</h4>



<pre class="wp-block-code"><code># docker info</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Docker 容器简介</title>
		<link>https://eternalcenter-now.github.io/introduction-of-docker-container/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 04 Oct 2020 09:31:51 +0000</pubDate>
				<category><![CDATA[Articles (文章)]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Containers (容器)]]></category>
		<category><![CDATA[Docker]]></category>
		<category><![CDATA[Information Technology (IT) Articles (信息技术类文章)]]></category>
		<category><![CDATA[Writings (写作)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=10621</guid>

					<description><![CDATA[章节一：什么是容器 Docker 主要是由 Linux 内核的三个部分组成：1. namesapce 用于将各个服务隔离开，并按需求分成一个个隔离组，每个隔离组就可以看作一个容器，各个隔离组之间相互隔离2. CGroup 用于限制各个隔离组的可用资源，避免各个隔离组之间进行硬件资源争抢3. SELinux 用于安全，也可以不要让资源裸奔 章节二：容器和虚拟机 容器和虚拟机类似，但是容器有很多部分公用着宿主机系统的环境和软件，而虚拟机系统和宿主机系统之间是完全隔离的]]></description>
										<content:encoded><![CDATA[
<h2>章节一：什么是容器</h2>



<p>Docker 主要是由 Linux 内核的三个部分组成：<br>1. namesapce 用于将各个服务隔离开，并按需求分成一个个隔离组，每个隔离组就可以看作一个容器，各个隔离组之间相互隔离<br>2. CGroup 用于限制各个隔离组的可用资源，避免各个隔离组之间进行硬件资源争抢<br>3. SELinux 用于安全，也可以不要让资源裸奔</p>



<h2>章节二：容器和虚拟机</h2>



<p>容器和虚拟机类似，但是容器有很多部分公用着宿主机系统的环境和软件，而虚拟机系统和宿主机系统之间是完全隔离的</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] 远程虚拟化平台的搭建</title>
		<link>https://eternalcenter-now.github.io/remote-virtual-platform/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 26 Sep 2020 10:10:37 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[KVM]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer (系统电脑)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[Virtualization (虚拟化)]]></category>
		<category><![CDATA[VNC]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=10587</guid>

					<description><![CDATA[步骤目录： 步骤一：规划拓扑1.1 电脑列表1.2 服务器列表简介 步骤二：给电脑安装 CentOS 8.2 系统 步骤三：安装图形系统桌面 步骤四：安装中文输入法4.1 安装中文库4.2 确认中文库已经安装4.3 安装中文输入法 步骤五：创建用户5.1 创建用户5.2 给用户设置密码 步骤六：增加 CentOS 8.2 系统的稳定性6.1 延长看门狗喂狗间隔以减少系统被软锁出现 softlockup 的几率6.1.1 临时延长看门狗喂狗间隔的时间6.1.2 永久延长看门狗喂狗间隔的时间6.1.2.1 添加延长看门狗喂狗间隔的设置6.1.2.2 让添加延长看门狗喂狗间隔的设置生效6.1.3 让 softlockup 触发后直接宕机6.2 禁止图形系统桌面的 DNS 和路由以避免系统崩溃6.2.1 添加禁止图形系统桌面的 DNS 和路由的设置6.2.2 让禁止图形系统桌面的 DNS 和路由的设置生效6.3 禁止图形系统界面自动黑屏或自动挂起6.4 让 SSH 联接永久不超时6.4.1 让 SSH 服务端的连接不超时6.4.2 让用户登陆永不超时6.4.2.1 在系统文件里添加让用户登陆永不超时的设置6.4.2.2 让用户登陆永不超时的设置立刻生效6.5 删除不需要的软件包以避免 CPU 占用过高而崩溃（选做） 步骤七：搭建虚拟化平台 步骤八：实现文件共享8.1 安装 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/remote-virtual-platform/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] 远程虚拟化平台的搭建"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-规划拓扑1-1-电脑列表1-2-服务器列表简介">步骤一：规划拓扑<br>1.1 电脑列表<br>1.2 服务器列表简介</h4>



<h4 id="步骤二-给电脑安装-centos-8-2-系统">步骤二：给电脑安装 CentOS 8.2 系统</h4>



<h4 id="步骤三-安装图形系统桌面">步骤三：安装图形系统桌面</h4>



<h4 id="步骤四-安装中文输入法4-1-安装中文库4-2-确认中文库已经安装4-3-安装中文输入法">步骤四：安装中文输入法<br>4.1 安装中文库<br>4.2 确认中文库已经安装<br>4.3 安装中文输入法</h4>



<h4 id="步骤五-创建用户5-1-创建用户5-2-给用户设置密码">步骤五：创建用户<br>5.1 创建用户<br>5.2 给用户设置密码</h4>



<h4 id="步骤六-增加-centos-8-2-系统的稳定性6-1-延长看门狗喂狗间隔以减少系统被软锁出现-softlockup-的几率6-1-1-临时延长看门狗喂狗间隔的时间6-1-2-永久延长看门狗喂狗间隔的时间6-1-2-1-添加延长看门狗喂狗间隔的设置6-1-2-2-让添加延长看门狗喂狗间隔的设置生效6-1-3-让-softlockup-触发后直接宕机6-2-禁止图形系统桌面的-dns-和路由以避免系统崩溃6-2-1-添加禁止图形系统桌面的-dns-和路由的设置6-2-2-让禁止图形系统桌面的-dns-和路由的设置生效6-3-禁止图形系统界面自动黑屏或自动挂起6-4-让-ssh-联接永久不超时6-4-1-让-ssh-服务端的连接不超时6-4-2-让用户登陆永不超时6-4-2-1-在系统文件里添加让用户登陆永不超时的设置6-4-2-2-让用户登陆永不超时的设置立刻生效6-5-删除不需要的软件包以避免-cpu-占用过高而崩溃-选做">步骤六：增加 CentOS 8.2 系统的稳定性<br>6.1 延长看门狗喂狗间隔以减少系统被软锁出现 softlockup 的几率<br>6.1.1 临时延长看门狗喂狗间隔的时间<br>6.1.2 永久延长看门狗喂狗间隔的时间<br>6.1.2.1 添加延长看门狗喂狗间隔的设置<br>6.1.2.2 让添加延长看门狗喂狗间隔的设置生效<br>6.1.3 让 softlockup 触发后直接宕机<br>6.2 禁止图形系统桌面的 DNS 和路由以避免系统崩溃<br>6.2.1 添加禁止图形系统桌面的 DNS 和路由的设置<br>6.2.2 让禁止图形系统桌面的 DNS 和路由的设置生效<br>6.3 禁止图形系统界面自动黑屏或自动挂起<br>6.4 让 SSH 联接永久不超时<br>6.4.1 让 SSH 服务端的连接不超时<br>6.4.2 让用户登陆永不超时<br>6.4.2.1 在系统文件里添加让用户登陆永不超时的设置<br>6.4.2.2 让用户登陆永不超时的设置立刻生效<br>6.5 删除不需要的软件包以避免 CPU 占用过高而崩溃（选做）</h4>



<h4 id="步骤七-搭建虚拟化平台">步骤七：搭建虚拟化平台</h4>



<h4 id="步骤八-实现文件共享8-1-安装-samba-服务8-2-配置-samba-服务的配置文件8-3-设置-samba-服务共享用户8-3-1-给-samba-服务共享用户设置-samba-共享密码8-3-2-显示-samba-服务共享用户是否可用8-4-生成-samba-服务共享目录8-4-1-生成-samba-服务共享目录8-4-2-给-samba-服务共享目录设置权限8-4-3-给-samba-服务共享目录设置所属主和所属组8-4-4-给-samba-服务共享目录设置-selinux-标签8-4-5-让-samba-服务共享目录上的-selinux-标签立刻生效8-5-启动-samba-服务并设置为开机自动启动8-6-在系统防火墙开放-samba-的端口8-6-1-在系统防火墙开放-samba-的端口8-6-2-让系统防火墙重新加载">步骤八：实现文件共享<br>8.1 安装 Samba 服务<br>8.2 配置 Samba 服务的配置文件<br>8.3 设置 Samba 服务共享用户<br>8.3.1 给 Samba 服务共享用户设置 Samba 共享密码<br>8.3.2 显示 Samba 服务共享用户是否可用<br>8.4 生成 Samba 服务共享目录<br>8.4.1 生成 Samba 服务共享目录<br>8.4.2 给 Samba 服务共享目录设置权限<br>8.4.3 给 Samba 服务共享目录设置所属主和所属组<br>8.4.4 给 Samba 服务共享目录设置 selinux 标签<br>8.4.5 让 Samba 服务共享目录上的 selinux 标签立刻生效<br>8.5 启动 Samba 服务并设置为开机自动启动<br>8.6 在系统防火墙开放 Samba 的端口<br>8.6.1 在系统防火墙开放 Samba 的端口<br>8.6.2 让系统防火墙重新加载</h4>



<h4 id="步骤九-实现远程桌面9-1-安装-vnc-服务9-2-设置-vnc-服务共享用户9-2-1-进入用户9-2-2-给-vnc-服务共享用户设置-vnc-远程密码9-2-3-退出用户9-3-启动-vnc-并设置为开机自动启动9-3-1-创建开启-vnc-的脚本-vnc-sh9-3-1-1-进入到用户9-3-1-2-创建开启-vnc-的脚本-vnc-sh9-3-1-3-退出用户9-3-2-执行开启-vnc-的脚本9-3-2-1-开机执行开启-vnc-的脚本9-3-2-1-1-配置开机执行的文件9-3-2-1-2-给开机执行的文件执行权限9-3-2-2-定期执行开启-vnc-的脚本9-3-2-2-1-进入到用户9-3-2-2-2-配置定期执行的文件9-3-2-2-3-退出用户">步骤九：实现远程桌面<br>9.1 安装 vnc 服务<br>9.2 设置 VNC 服务共享用户<br>9.2.1 进入用户<br>9.2.2 给 VNC 服务共享用户设置 VNC 远程密码<br>9.2.3 退出用户<br>9.3 启动 VNC 并设置为开机自动启动<br>9.3.1 创建开启 VNC 的脚本 ~/vnc.sh<br>9.3.1.1 进入到用户<br>9.3.1.2 创建开启 VNC 的脚本 ~/vnc.sh<br>9.3.1.3 退出用户<br>9.3.2 执行开启 VNC 的脚本<br>9.3.2.1 开机执行开启 VNC 的脚本<br>9.3.2.1.1 配置开机执行的文件<br>9.3.2.1.2 给开机执行的文件执行权限<br>9.3.2.2 定期执行开启 VNC 的脚本<br>9.3.2.2.1 进入到用户<br>9.3.2.2.2 配置定期执行的文件<br>9.3.2.2.3 退出用户</h4>



<h4 id="步骤十-设置-ssh-内网穿透10-1-生成-ssh-密钥10-1-1-进入到用户10-1-2-生成-ssh-密钥10-1-3-退出用户10-2-实现无密钥-ssh10-2-1-进入到用户10-2-2-让电脑可以无密钥-ssh-vps10-2-3-让-vps-可以无密钥-ssh-自己10-2-4-让客户端可以远程-vps-和电脑10-2-5-退出用户10-3-建立电脑到-vps-的-ssh-隧道并设置为开机自启10-3-1-创建建立电脑到-vps-的-ssh-隧道的脚本-ssh-sh10-3-1-1-进入到用户10-3-1-2-创建建立电脑到-vps-的-ssh-隧道的脚本-ssh-sh10-3-1-3-退出用户10-3-2-执行电脑到-vps-的-ssh-隧道的脚本10-3-2-1-开机执行开启电脑到-vps-的-ssh-隧道的脚本10-3-2-1-1-配置开机执行的文件10-3-2-1-2-给开机执行的文件执行权限10-3-3-定期执行电脑到-vps-的-ssh-隧道的脚本10-3-3-1-进入到用户10-3-3-2-配置定期执行的文件10-3-3-3-退出用户10-4-建立-vps-的-ssh-隧道端口映射并设置为开机自启10-4-1-创建建立-vps-的-ssh-隧道端口映射的脚本10-4-1-1-进入到用户10-4-1-2-创建建立-vps-的-ssh-隧道端口映射的脚本10-4-1-3-退出用户10-4-2-执行电脑到-vps-的-ssh-隧道的脚本10-4-2-1-开机执行开启电脑到-vps-的-ssh-隧道的脚本10-4-2-1-1-配置开机执行的文件10-4-2-1-2-给开机执行的文件执行权限10-4-3-定期执行电脑到-vps-的-ssh-隧道的脚本10-4-3-1-进入到用户10-4-3-2-配置定期执行的文件10-4-4-退出用户10-4-5-打开外网-vps-对应端口的防火墙10-4-5-1-打开外网-vps-对应端口的防火墙10-4-5-2-让刚刚外网-vps-刚刚配置的防火墙生效">步骤十：设置 SSH 内网穿透<br>10.1 生成 SSH 密钥<br>10.1.1 进入到用户<br>10.1.2 生成 SSH 密钥<br>10.1.3 退出用户<br>10.2 实现无密钥 SSH<br>10.2.1 进入到用户<br>10.2.2 让电脑可以无密钥 SSH VPS<br>10.2.3 让 VPS 可以无密钥 SSH 自己<br>10.2.4 让客户端可以远程 VPS 和电脑<br>10.2.5 退出用户<br>10.3 建立电脑到 VPS 的 SSH 隧道并设置为开机自启<br>10.3.1 创建建立电脑到 VPS 的 SSH 隧道的脚本 ～/ssh.sh<br>10.3.1.1 进入到用户<br>10.3.1.2 创建建立电脑到 VPS 的 SSH 隧道的脚本 ～/ssh.sh<br>10.3.1.3 退出用户<br>10.3.2 执行电脑到 VPS 的 SSH 隧道的脚本<br>10.3.2.1 开机执行开启电脑到 VPS 的 SSH 隧道的脚本<br>10.3.2.1.1 配置开机执行的文件<br>10.3.2.1.2 给开机执行的文件执行权限<br>10.3.3 定期执行电脑到 VPS 的 SSH 隧道的脚本<br>10.3.3.1 进入到用户<br>10.3.3.2 配置定期执行的文件<br>10.3.3.3 退出用户<br>10.4 建立 VPS 的 SSH 隧道端口映射并设置为开机自启<br>10.4.1 创建建立 VPS 的 SSH 隧道端口映射的脚本<br>10.4.1.1 进入到用户<br>10.4.1.2 创建建立 VPS 的 SSH 隧道端口映射的脚本<br>10.4.1.3 退出用户<br>10.4.2 执行电脑到 VPS 的 SSH 隧道的脚本<br>10.4.2.1 开机执行开启电脑到 VPS 的 SSH 隧道的脚本<br>10.4.2.1.1 配置开机执行的文件<br>10.4.2.1.2 给开机执行的文件执行权限<br>10.4.3 定期执行电脑到 VPS 的 SSH 隧道的脚本<br>10.4.3.1 进入到用户<br>10.4.3.2 配置定期执行的文件<br>10.4.4 退出用户<br>10.4.5 打开外网 VPS 对应端口的防火墙<br>10.4.5.1 打开外网 VPS 对应端口的防火墙<br>10.4.5.2 让刚刚外网 VPS 刚刚配置的防火墙生效</h4>



<h4 id="步骤十一-加强-ssh-的安全性-选做-11-1-禁止-root-被-ssh-选做-11-2-禁止使用密码被-ssh-选做">步骤十一：加强 SSH 的安全性（选做）<br>11.1 禁止 root 被 SSH（选做）<br>11.2 禁止使用密码被 SSH（选做）</h4>



<h4 id="步骤十二-私有远程桌面和虚拟化平台的使用12-1-客户端-ssh-联接电脑的方法12-1-1-客户端和电脑不在同一内网时12-1-2-客户端和电脑在同一内网时12-2-客户端使用电脑虚拟化平台的的方法12-2-1-客户端和电脑不在同一内网时12-2-1-1-在客户端上联接电脑12-2-1-2-通过-ssh-开启虚拟化图形管理平台12-2-2-客户端和电脑在同一内网时12-2-2-1-在客户端上联接电脑12-2-2-2-通过-ssh-开启虚拟化图形管理平台12-3-客户端使用私有远程桌面的方法12-3-1-客户端和电脑不在同一内网时12-3-2-客户端和电脑在同一内网时12-4-客户端在内网和电脑互传数据的方法12-4-1-在-windows-图形客户端上和电脑互传数据的方法12-4-2-在-linux-图形客户端上和电脑互传数据的方法">步骤十二：私有远程桌面和虚拟化平台的使用<br>12.1 客户端 SSH 联接电脑的方法<br>12.1.1 客户端和电脑不在同一内网时<br>12.1.2 客户端和电脑在同一内网时<br>12.2 客户端使用电脑虚拟化平台的的方法<br>12.2.1 客户端和电脑不在同一内网时<br>12.2.1.1 在客户端上联接电脑<br>12.2.1.2 通过 ssh 开启虚拟化图形管理平台<br>12.2.2 客户端和电脑在同一内网时<br>12.2.2.1 在客户端上联接电脑<br>12.2.2.2 通过 ssh 开启虚拟化图形管理平台<br>12.3 客户端使用私有远程桌面的方法<br>12.3.1 客户端和电脑不在同一内网时<br>12.3.2 客户端和电脑在同一内网时<br>12.4 客户端在内网和电脑互传数据的方法<br>12.4.1 在 Windows 图形客户端上和电脑互传数据的方法<br>12.4.2 在 Linux 图形客户端上和电脑互传数据的方法</h4>



<h4 id="步骤十三-客户端直接使用公网-ip-地址联接电脑13-1-实现此步骤所需环境13-2-在路由器上将电脑上的-22-端口映射到路由器上的公网-ip-地址上-这样路由器上的公网-ip-地址就变成电脑的公网-ip-地址了13-3-将电脑的公网-ip-地址放到-vps-上13-3-1-将电脑的公网-ip-地址放到-vps-上的意义13-3-2-创建将电脑的公网-ip-地址放到-vps-上的脚本13-3-2-1-进入到用户用户13-3-2-2-创建将电脑的公网-ip-地址放到-vps-上的脚本13-3-2-3-退出用户用户13-3-3-执行将电脑的公网-ip-地址放到-vps-上的脚本13-3-3-1-进入到用户用户13-3-3-2-配置定期执行的文件13-3-3-3-退出用户用户13-4-通过-ddns-服务显示电脑的公网-ip13-4-1-通过-ddns-服务显示电脑的公网-ip13-4-2-有些-ddns-服务可以在网关路由器上设置-并且通过手机-app-显示现在的公网-ip-地址">步骤十三：客户端直接使用公网 IP 地址联接电脑<br>13.1 实现此步骤所需环境<br>13.2 在路由器上将电脑上的 22 端口映射到路由器上的公网 IP 地址上，这样路由器上的公网 IP 地址就变成电脑的公网 IP 地址了<br>13.3 将电脑的公网 IP 地址放到 VPS 上<br>13.3.1 将电脑的公网 IP 地址放到 VPS 上的意义<br>13.3.2 创建将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.2.1 进入到用户用户<br>13.3.2.2 创建将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.2.3 退出用户用户<br>13.3.3 执行将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.3.1 进入到用户用户<br>13.3.3.2 配置定期执行的文件<br>13.3.3.3 退出用户用户<br>13.4 通过 DDNS 服务显示电脑的公网 IP<br>13.4.1 通过 DDNS 服务显示电脑的公网 IP<br>13.4.2 有些 DDNS 服务可以在网关路由器上设置，并且通过手机 APP 显示现在的公网 IP 地址</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-规划拓扑1-1-电脑列表">步骤一：规划拓扑<br>1.1 电脑列表</h4>



<p>1) 一台可以联接公网的电脑<br>2) 一个 CentOS 8.2 系统的安装 U 盘<br>3) 一台可以联接公网并且有公网 IP 地址的 VPS<br>4) 一个可以联接公网并使用 SSH 和 VNC 的客户端</p>



<h4 id="1-2-服务器列表简介">1.2 服务器列表简介</h4>



<p>1) 电脑通过 SSH 建立联接到 VPS 的隧道，此操作会占用 VPS 的一个端口<br>2) VPS 通过 SSH 将联接电脑的隧道端口映射到一个新的端口<br>3) 客户端通过 SSH 联接到 VPS 映射出来的新端口，通过 SSH 或远程桌面使用虚拟化平台<br>4) 客户端和电脑如果在同一内网里则可以通过 Samba 互传数据</p>



<h4 id="步骤二-centos-8-2-系统的安装-u-盘给电脑安装系统">步骤二：CentOS 8.2 系统的安装 U 盘给电脑安装系统</h4>



<p>（只在电脑上执行以下步骤）<br>（步骤略）</p>



<p>（<br>补充：<br>安装系统时可选择以下选项：<br>1) 系统起动方式：BIOS<br>2) Keyboard：English(US)<br>3) Language Support：English(United States)<br>4) Time &amp; Date：Asia/ShangHai<br>5) Installation Source：Local media<br>6) Software Selection：Minial Install<br>7) Installation Destination：将主硬盘里的所有空间都分配给根分区<br>8) KDUMP：Kdump is disabled<br>9) Network &amp; Host Name：开启网络联接并设置好固定 DNS<br>10) SECURITY POLICY：No controller found<br>）</p>



<p>（这里以将 IP 地址设置为固定 IP 地址 192.168.0.1，DNS 设置为固定 DNS 8.8.8.8 为例）</p>



<h4 id="步骤三-安装图形系统桌面">步骤三：安装图形系统桌面</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum groupinstall -y "Server with GUI"</code></pre>



<h4 id="步骤四-安装中文输入法4-1-安装中文库">步骤四：安装中文输入法<br>4.1 安装中文库</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install langpacks-zh_CN</code></pre>



<h4 id="4-2-确认中文库已经安装">4.2 确认中文库已经安装</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># locale -a</code></pre>



<h4 id="4-3-安装中文输入法">4.3 安装中文输入法</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install ibus ibus-libpinyin</code></pre>



<h4 id="步骤五-创建用户用户5-1-创建用户用户">步骤五：创建用户用户<br>5.1 创建用户用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># useradd zhumingyu</code></pre>



<p>（补充：这里创建用户 zhumingyu 为例）</p>



<h4 id="5-2-给用户用户设置密码">5.2 给用户用户设置密码</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># passwd zhumingyu</code></pre>



<p>（补充：这里创建用户 zhumingyu 为例）</p>



<h4 id="步骤六-增加-centos-系统的稳定性6-1-延长看门狗喂狗间隔以减少系统被软锁出现-softlockup-的几率6-1-1-临时延长看门狗喂狗间隔的时间">步骤六：增加 CentOS 系统的稳定性<br>6.1 延长看门狗喂狗间隔以减少系统被软锁出现 softlockup 的几率<br>6.1.1 临时延长看门狗喂狗间隔的时间</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># sysctl -w kernel.watchdog_thresh=60</code></pre>



<h4 id="6-1-2-永久延长看门狗喂狗间隔的时间6-1-2-1-添加延长看门狗喂狗间隔的设置">6.1.2 永久延长看门狗喂狗间隔的时间<br>6.1.2.1 添加延长看门狗喂狗间隔的设置</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/sysctl.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
kernel.watchdog_thresh=60</code></pre>



<h4 id="6-1-2-2-让添加延长看门狗喂狗间隔的设置生效">6.1.2.2 让添加延长看门狗喂狗间隔的设置生效</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># sysctl -p</code></pre>



<h4 id="6-1-3-让-softlockup-触发后直接宕机">6.1.3 让 softlockup 触发后直接宕机</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># echo 1 &gt; /proc/sys/kernel/softlockup_panic</code></pre>



<h4 id="6-2-禁止图形系统桌面的-dns-和路由以避免系统崩溃6-2-1-添加禁止图形系统桌面的-dns-和路由的设置">6.2 禁止图形系统桌面的 DNS 和路由以避免系统崩溃<br>6.2.1 添加禁止图形系统桌面的 DNS 和路由的设置</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/sysconfig/network-scripts/ifcfg-enp9s0</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
PEERDNS=no
PEERROUTES=no</code></pre>



<p>（补充：这里的 ifcfg-enp9s0 是指网卡对应的配置文件，不同的网卡对应的配置文件不同，这里以网卡名 ifcfg-enp9s0 为例，需要给所有网卡添加此参数，这一步也可以在系统图形系统桌面上设置）</p>



<h4 id="6-2-2-让禁止图形系统桌面的-dns-和路由的设置生效">6.2.2 让禁止图形系统桌面的 DNS 和路由的设置生效</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl restart NetworkManager</code></pre>



<h4 id="6-3-禁止图形系统界面自动黑屏或自动挂起">6.3 禁止图形系统界面自动黑屏或自动挂起</h4>



<p>（只在电脑上执行以下步骤）</p>



<h4 id="6-4-让-ssh-联接永久不超时6-4-1-让-ssh-服务端的连接不超时">6.4 让 SSH 联接永久不超时<br>6.4.1 让 SSH 服务端的连接不超时</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/ssh/sshd_config</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
#ClientAliveInterval 0
#ClientAliveCountMax 3
......</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
ClientAliveInterval 60
ClientAliveCountMax 525600
......</code></pre>



<p>（补充：这样设置会让 SSH 服务端每 60s 就会尝试连接一次客户端，如果 525600 次后没有回应，则断开）</p>



<h4 id="6-4-2-让用户登陆永不超时6-4-2-1-在系统文件里添加让用户登陆永不超时的设置">6.4.2 让用户登陆永不超时<br>6.4.2.1 在系统文件里添加让用户登陆永不超时的设置</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/bashrc</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
export TMOUT=0</code></pre>



<pre class="wp-block-code"><code># vim /etc/profile</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
export TMOUT=0</code></pre>



<h4 id="6-4-2-2-让用户登陆永不超时的设置立刻生效">6.4.2.2 让用户登陆永不超时的设置立刻生效</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># source /etc/bashrc
# source /etc/profile</code></pre>



<h4 id="6-5-删除不需要的软件包以避免-cpu-占用过高而崩溃-选做">6.5 删除不需要的软件包以避免 CPU 占用过高而崩溃（选做）</h4>



<p>（步骤略）</p>



<h4 id="步骤七-搭建虚拟化平台">步骤七：搭建虚拟化平台</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install qemu-kvm libvirt-daemon libvirt-client libvirt-daemon-driver-qemu virt-install virt-manager virt-viewer virt-v2v</code></pre>



<h4 id="步骤八-实现文件共享8-1-安装-samba-服务">步骤八：实现文件共享<br>8.1 安装 Samba 服务</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install samba
</code></pre>



<h4 id="8-2-配置-samba-服务的配置文件">8.2 配置 Samba 服务的配置文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/samba/smb.conf</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code># See smb.conf.example for a more detailed config file or
# read the smb.conf manpage.
# Run 'testparm' to verify the config is correct after
# you modified it.

&#91;global]
workgroup = WORKGROUP
realm = zhumingyu
netbios name = zhumingyu
#encrypt passwords = yes
map to guest = NEVER
security = user
password server = *
name resolve order = bcast host
restrict anonymous = 2
#null passwords = no
#guest account = smb_nobody
#use spnego = yes
client use spnego = yes
server string = ""
host msdfs = no
msdfs root = no
domain master = no
preferred master = no
local master = no
os level = 0
browse list = no
browseable = no
dns proxy = no
wide links = no
public= no
guest ok = no
hosts deny = ALL EXCEPT 192.168.0.2

&#91;share]
valid users = zhumingyu
write list = zhumingyu
read list = zhumingyu
path = /share
guest ok = no
read only = no
browseable = no
writable = yes
public = no
create mask = 0755
directory mask = 0755</code></pre>



<p>（<br>补充：<br>1) 这里以 Samba 服务器的 IP 地址是 192.168.0.1 为例<br>2) 这里的 workgroup = WORKGROUP 是让 Samba 服务属于 WORKGROUP<br>3) 这里的 hosts deny = ALL EXCEPT 192.168.0.2 是只让客户端 192.168.0.3 能够访问服务端的 Samba<br>4) 这里的 sharetest 是这个 Samba 挂载点的名称，挂载这个挂载点的格式就是：//192.168.0.1/share<br>5) 这里的 valid users = zhumingyu 是 Samba 服务共享用户需要手动生成<br>6) 这里的 path = /share 是 Samba 服务共享目录需要手动生成<br>）</p>



<h4 id="8-3-设置-samba-服务共享用户8-3-1-给-samba-服务共享用户设置-samba-共享密码">8.3 设置 Samba 服务共享用户<br>8.3.1 给 Samba 服务共享用户设置 Samba 共享密码</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># smbpasswd -a zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="8-3-2-显示-samba-服务共享用户是否可用">8.3.2 显示 Samba 服务共享用户是否可用</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># pdbedit -L</code></pre>



<h4 id="8-4-生成-samba-服务共享目录8-4-1-生成-samba-服务共享目录">8.4 生成 Samba 服务共享目录<br>8.4.1 生成 Samba 服务共享目录</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># mkdir /share</code></pre>



<h4 id="8-4-2-给-samba-服务共享目录设置权限">8.4.2 给 Samba 服务共享目录设置权限</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod 755 /share/</code></pre>



<h4 id="8-4-3-给-samba-服务共享目录设置所属主和所属组">8.4.3 给 Samba 服务共享目录设置所属主和所属组</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># chown zhumingyu:zhumingyu /share/</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="8-4-4-给-samba-服务共享目录设置-selinux-标签">8.4.4 给 Samba 服务共享目录设置 selinux 标签</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># semanage fcontext -a -t samba_share_t '/share(/.*)?'</code></pre>



<h4 id="8-4-5-让-samba-服务共享目录上的-selinux-标签立刻生效">8.4.5 让 Samba 服务共享目录上的 selinux 标签立刻生效</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># restorecon -RFvv /share/</code></pre>



<h4 id="8-5-启动-samba-服务并设置为开机自动启动">8.5 启动 Samba 服务并设置为开机自动启动</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl enable --now smb</code></pre>



<h4 id="8-6-在系统防火墙开放-samba-的端口8-6-1-在系统防火墙开放-samba-的端口">8.6 在系统防火墙开放 Samba 的端口<br>8.6.1 在系统防火墙开放 Samba 的端口</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># firewall-cmd --add-service=samba --permanent</code></pre>



<h4 id="8-6-2-让系统防火墙重新加载">8.6.2 让系统防火墙重新加载</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># firewall-cmd --reload</code></pre>



<h4 id="步骤九-实现远程桌面9-1-安装-vnc-服务">步骤九：实现远程桌面<br>9.1 安装 vnc 服务</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install tigervnc tigervnc-server</code></pre>



<h4 id="9-2-设置-vnc-服务共享用户9-2-1-进入用户">9.2 设置 VNC 服务共享用户<br>9.2.1 进入用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="9-2-2-给-vnc-服务共享用户设置-vnc-远程密码">9.2.2 给 VNC 服务共享用户设置 VNC 远程密码</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vncpasswd</code></pre>



<h4 id="9-2-3-退出用户">9.2.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="9-3-启动-vnc-并设置为开机自动启动9-3-1-创建开启-vnc-的脚本-vnc-sh9-3-1-1-进入到用户">9.3 启动 VNC 并设置为开机自动启动<br>9.3.1 创建开启 VNC 的脚本 ~/vnc.sh<br>9.3.1.1 进入到用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="9-3-1-2-创建开启-vnc-的脚本-vnc-sh">9.3.1.2 创建开启 VNC 的脚本 ~/vnc.sh</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vim ~/vnc.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash

vncserver -list | grep :1 &amp;&gt; /dev/null || vncserver :1 -localhost -nolisten tcp</code></pre>



<p>（补充：此命令会检查 vncserver :1 会话是否存在，如果不存在，就以禁止非安全远程登陆的方式创建一个）</p>



<h4 id="9-3-1-3-退出用户">9.3.1.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="9-3-2-执行开启-vnc-的脚本9-3-2-1-开机执行开启-vnc-的脚本9-3-2-1-1-配置开机执行的文件">9.3.2 执行开启 VNC 的脚本<br>9.3.2.1 开机执行开启 VNC 的脚本<br>9.3.2.1.1 配置开机执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rc.local</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
su - zhumingyu -c '/home/zhumingyu/vnc.sh'</code></pre>



<p>（补充：这里以用户 zhumingyu 的身份运行）</p>



<p>或者：</p>



<pre class="wp-block-code"><code>......
su - zhumingyu -c 'vncserver -list | grep :1' &amp;&gt; /dev/null || su - zhumingyu -c 'vncserver :1 -localhost -nolisten tcp'</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 以用户 zhumingyu 的身份运行<br>3) 此命令会检查 vncserver :1 会话是否存在，如果不存在，就以禁止非安全远程登陆的方式创建一个<br>）</p>



<h4 id="9-3-2-1-2-给开机执行的文件执行权限">9.3.2.1.2 给开机执行的文件执行权限</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod u+x /home/zhumingyu/vnc.sh</code></pre>



<h4 id="9-3-2-2-定期执行开启-vnc-的脚本9-3-2-2-1-进入到用户">9.3.2.2 定期执行开启 VNC 的脚本<br>9.3.2.2.1 进入到用户</h4>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="9-3-2-2-2-配置定期执行的文件">9.3.2.2.2 配置定期执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ crontab -e</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * /home/zhumingyu/vnc.sh</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * vncserver -list | grep :1' &amp;&gt; /dev/null || su - zhumingyu -c 'vncserver :1 -localhost -nolisten tcp</code></pre>



<p>（<br>补充：<br>1) 这里以用户 zhumingyu 的身份运行<br>2) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>3) 此命令会检查 vncserver :1 会话是否存在，如果不存在，就以禁止非安全远程登陆的方式创建一个<br>）</p>



<h4 id="9-3-2-2-3-退出用户">9.3.2.2.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="步骤十-设置-ssh-内网穿透10-1-生成-ssh-密钥10-1-1-进入到用户">步骤十：设置 SSH 内网穿透<br>10.1 生成 SSH 密钥<br>10.1.1 进入到用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-1-2-生成-ssh-密钥">10.1.2 生成 SSH 密钥</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ ssh-keygen -b 2048 -t rsa</code></pre>



<p>（补充：建议在创建 SSH 密钥时为 SSH 密钥添加一个密码）</p>



<h4 id="10-1-3-退出用户">10.1.3 退出用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-2-实现无密钥-ssh10-2-1-进入到用户">10.2 实现无密钥 SSH<br>10.2.1 进入到用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-2-2-让电脑可以无密钥-ssh-vps">10.2.2 让电脑可以无密钥 SSH VPS</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ ssh-copy-id &lt;public IP address of VPS&gt;</code></pre>



<h4 id="10-2-3-让-vps-可以无密钥-ssh-自己">10.2.3 让 VPS 可以无密钥 SSH 自己</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ ssh-copy-id localhost</code></pre>



<h4 id="10-2-4-让客户端可以远程-vps-和电脑">10.2.4 让客户端可以远程 VPS 和电脑</h4>



<pre class="wp-block-code"><code>$ ssh-copy-id &lt;IP address of computer&gt;
$ ssh-copy-id &lt;public IP address of VPS&gt;</code></pre>



<h4 id="10-2-5-退出用户">10.2.5 退出用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-3-建立电脑到-vps-的-ssh-隧道并设置为开机自启10-3-1-创建建立电脑到-vps-的-ssh-隧道的脚本-ssh-sh10-3-1-1-进入到用户">10.3 建立电脑到 VPS 的 SSH 隧道并设置为开机自启<br>10.3.1 创建建立电脑到 VPS 的 SSH 隧道的脚本 ～/ssh.sh<br>10.3.1.1 进入到用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-3-1-2-创建建立电脑到-vps-的-ssh-隧道的脚本-ssh-sh">10.3.1.2 创建建立电脑到 VPS 的 SSH 隧道的脚本 ～/ssh.sh</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vim ～/ssh.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>ps -aux | grep -v grep | grep "11000:localhost:22 &lt;IP address of computer&gt;" &amp;&gt; /dev/null || ssh -X -fCNR 11000:localhost:22 &lt;IP address of computer&gt;</code></pre>



<p>（<br>补充：<br>1) 这里以用户 zhumingyu 的身份运行<br>2) 如果 11000 端口没有影射到 22 端口则影射<br>）</p>



<h4 id="10-3-1-3-退出用户">10.3.1.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-3-2-执行电脑到-vps-的-ssh-隧道的脚本10-3-2-1-开机执行开启电脑到-vps-的-ssh-隧道的脚本10-3-2-1-1-配置开机执行的文件">10.3.2 执行电脑到 VPS 的 SSH 隧道的脚本<br>10.3.2.1 开机执行开启电脑到 VPS 的 SSH 隧道的脚本<br>10.3.2.1.1 配置开机执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rc.local</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
su - zhumingyu -c '/home/zhumingyu/ssh.sh'</code></pre>



<p>（补充：这里以用户 zhumingyu 的身份运行）</p>



<p>或者：</p>



<pre class="wp-block-code"><code>......
ps -aux | grep -v grep | grep "11000:localhost:22 &lt;IP address of computer&gt;" &amp;&gt; /dev/null || su - zhumingyu -c 'ssh -X -fCNR 11000:localhost:22 &lt;IP address of computer&gt;'</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 这里以用户 zhumingyu 的身份运行<br>3) 如果 11000 端口没有影射到 22 端口则影射<br>）</p>



<h4 id="10-3-2-1-2-给开机执行的文件执行权限">10.3.2.1.2 给开机执行的文件执行权限</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod +x /etc/rc.local</code></pre>



<h4 id="10-3-3-定期执行电脑到-vps-的-ssh-隧道的脚本10-3-3-1-进入到用户">10.3.3 定期执行电脑到 VPS 的 SSH 隧道的脚本<br>10.3.3.1 进入到用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以 zhumingyu 为例）</p>



<h4 id="10-3-3-2-配置定期执行的文件">10.3.3.2 配置定期执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ crontab -e</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * /home/zhumingyu/ssh.sh</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * ps -aux | grep -v grep | grep "11000:localhost:22 &lt;IP address of computer&gt;" &amp;&gt; /dev/null || ssh -X -fCNR 11000:localhost:22 &lt;IP address of computer&gt;</code></pre>



<p>（补充：如果 11000 端口影射到 22 端口则影射）</p>



<h4 id="10-3-3-3-退出用户">10.3.3.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-4-建立-vps-的-ssh-隧道端口映射并设置为开机自启10-4-1-创建建立-vps-的-ssh-隧道端口映射的脚本10-4-1-1-进入到用户">10.4 建立 VPS 的 SSH 隧道端口映射并设置为开机自启<br>10.4.1 创建建立 VPS 的 SSH 隧道端口映射的脚本<br>10.4.1.1 进入到用户</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-4-1-2-创建建立-vps-的-ssh-隧道端口映射的脚本">10.4.1.2 创建建立 VPS 的 SSH 隧道端口映射的脚本</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vim ~/sshd.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash

ps -aux | grep -v grep | grep "*:10000:localhost:11000 localhost" || ssh -X -fCNL *:10000:localhost:11000 localhost</code></pre>



<p>（补充：如果 11000 端口没有影射成 10000 端口则影射）</p>



<h4 id="10-4-1-3-退出用户">10.4.1.3 退出用户</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-4-2-执行电脑到-vps-的-ssh-隧道的脚本10-4-2-1-开机执行开启电脑到-vps-的-ssh-隧道的脚本10-4-2-1-1-配置开机执行的文件">10.4.2 执行电脑到 VPS 的 SSH 隧道的脚本<br>10.4.2.1 开机执行开启电脑到 VPS 的 SSH 隧道的脚本<br>10.4.2.1.1 配置开机执行的文件</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rc.local</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
su - zhumingyu -c '/home/zhumingyu/sshd.sh'</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<p>或者：</p>



<pre class="wp-block-code"><code>......
ps -aux | grep -v grep | grep "*:10000:localhost:11000 localhost" || su - zhumingyu -c 'ssh -X -fCNL *:10000:localhost:11000 localhost'</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 以用户 zhumingyu 的身份运行<br>3) 如果 11000 端口没有影射成 10000 端口则影射<br>）</p>



<h4 id="10-4-2-1-2-给开机执行的文件执行权限">10.4.2.1.2 给开机执行的文件执行权限</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod +x /etc/rc.local</code></pre>



<h4 id="10-4-3-定期执行电脑到-vps-的-ssh-隧道的脚本10-4-3-1-进入到用户用户">10.4.3 定期执行电脑到 VPS 的 SSH 隧道的脚本<br>10.4.3.1 进入到用户用户</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-4-3-2-配置定期执行的文件">10.4.3.2 配置定期执行的文件</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ crontab -e</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * /home/zhumingyu/sshd.sh</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * ps -aux | grep -v grep | grep "*:10000:localhost:11000 localhost" || ssh -X -fCNL *:10000:localhost:11000 localhost</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 如果 11000 端口没有影射成 10000 端口则影射<br>）</p>



<h4 id="10-4-4-退出用户">10.4.4 退出用户</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-4-5-打开外网-vps-对应端口的防火墙10-4-5-1-打开外网-vps-对应端口的防火墙">10.4.5 打开外网 VPS 对应端口的防火墙<br>10.4.5.1 打开外网 VPS 对应端口的防火墙</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># firewall-cmd --add-port=10000/tcp --permanent</code></pre>



<p>（补充：这里打开的端口号，是根据前面的设置而定的）</p>



<h4 id="10-4-5-2-让刚刚外网-vps-刚刚配置的防火墙生效">10.4.5.2 让刚刚外网 VPS 刚刚配置的防火墙生效</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># firewall-cmd --reload</code></pre>



<h4 id="步骤十一-加强-ssh-的安全性-选做-11-1-禁止-root-被-ssh-选做">步骤十一：加强 SSH 的安全性（选做）<br>11.1 禁止 root 被 SSH（选做）</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/ssh/sshd_config</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
PermitRootLogin no
......</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
PermitRootLogin yes
......</code></pre>



<h4 id="11-2-禁止使用密码被-ssh-选做">11.2 禁止使用密码被 SSH（选做）</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/ssh/sshd_config</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
# PasswordAuthentication yes
......</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
PasswordAuthentication no
......</code></pre>



<h4 id="步骤十二-私有远程桌面和虚拟化平台的使用12-1-客户端-ssh-联接电脑的方法12-1-1-客户端和电脑不在同一内网时">步骤十二：私有远程桌面和虚拟化平台的使用<br>12.1 客户端 SSH 联接电脑的方法<br>12.1.1 客户端和电脑不在同一内网时</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -X -p &lt;SSH non standard port number&gt; &lt;user of computer&gt;@&lt;public IP address of VPS&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的 VPS 每小时会生成一个新的 SSH 非标准端口号以用于联接电脑，比如说现在是 14 点，那就会自动生成一个 11014 的 SSH 非标准端口号<br>2) 如果按照前面的步骤操作，这里的用户是 zhumingyu<br>）</p>



<h4 id="12-1-2-客户端和电脑在同一内网时">12.1.2 客户端和电脑在同一内网时</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -X &lt;user of computer&gt;@&lt;IP address of computer&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的用户用户是 zhumingyu<br>2) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>）</p>



<h4 id="12-2-客户端使用电脑虚拟化平台的的方法12-2-1-客户端和电脑不在同一内网时12-2-1-1-在客户端上联接电脑">12.2 客户端使用电脑虚拟化平台的的方法<br>12.2.1 客户端和电脑不在同一内网时<br>12.2.1.1 在客户端上联接电脑</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -X -p &lt;SSH non standard port number&gt; &lt;user of computer&gt;@&lt;public IP address of VPS&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的 VPS 每小时会生成一个新的 SSH 非标准端口号以用于联接电脑，比如说现在是 14 点，那就会自动生成一个 11014 的 SSH 非标准端口号<br>2) 如果按照前面的步骤操作，这里的用户用户是 zhumingyu<br>）</p>



<h4 id="12-2-1-2-通过-ssh-开启虚拟化图形管理平台">12.2.1.2 通过 ssh 开启虚拟化图形管理平台</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># virt-manager</code></pre>



<p>（注意：网络带宽很小则远程桌面会比较卡，建议电脑、客户端和 VPS 的带宽 2m 以上）</p>



<h4 id="12-2-2-客户端和电脑在同一内网时12-2-2-1-在客户端上联接电脑">12.2.2 客户端和电脑在同一内网时<br>12.2.2.1 在客户端上联接电脑</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -X &lt;user of computer&gt;@&lt;IP address of computer&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的用户用户是 zhumingyu<br>2) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>）</p>



<h4 id="12-2-2-2-通过-ssh-开启虚拟化图形管理平台">12.2.2.2 通过 ssh 开启虚拟化图形管理平台</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># virt-manager</code></pre>



<p>（注意：网络带宽很小则远程桌面会比较卡，建议电脑、客户端和 VPS 的带宽 2m 以上）</p>



<h4 id="12-3-客户端使用私有远程桌面的方法12-3-1-客户端和电脑不在同一内网时">12.3 客户端使用私有远程桌面的方法<br>12.3.1 客户端和电脑不在同一内网时</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -p &lt;SSH non standard port number&gt; -L &lt;port number of VNC&gt;:localhost:&lt;port number of VNC&gt; -l &lt;user of computer&gt; &lt;public IP address of VPS&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的 VPS 每小时会生成一个新的 SSH 非标准端口号以用于联接电脑，比如说现在是 14 点，那就会自动生成一个 11014 的 SSH 非标准端口号<br>2) 如果按照前面的步骤操作，这里的 VNC 的端口号是 5901<br>3) 如果按照前面的步骤操作，这里的电脑的用户用户是 zhumingyu<br>）</p>



<p>另开启一个命令行终端：</p>



<pre class="wp-block-code"><code># vncviewer localhost :&lt;number of VNC service&gt;</code></pre>



<p>（补充：如果按照前面的步骤操作，这里的 VNC 服务的编号是 1）</p>



<p>（注意：网络带宽很小则远程桌面会比较卡，建议电脑、客户端和 VPS 的带宽 2m 以上）</p>



<h4 id="12-3-2-客户端和电脑在同一内网时">12.3.2 客户端和电脑在同一内网时</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># vncviewer -via &lt;user of computer&gt;@&lt;IP address of computer&gt; localhost :&lt;number of VNC service&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的电脑的用户是 zhumingyu<br>2) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>3) 如果按照前面的步骤操作，这里的 VNC 服务的编号是 1<br>）</p>



<h4 id="12-4-客户端在内网和电脑互传数据的方法12-4-1-在-windows-图形客户端上和电脑互传数据的方法">12.4 客户端在内网和电脑互传数据的方法<br>12.4.1 在 Windows 图形客户端上和电脑互传数据的方法</h4>



<p>（只在客户端上执行以下步骤）</p>



<p>在文件目录下栏输入以下内容：</p>



<pre class="wp-block-code"><code>\\&lt;IP address of computer&gt;\&lt;samba directory&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>2) 如果按照前面的步骤操作，这里的 Samba 项目是 share<br>）</p>



<p>（<br>注意：<br>1) 如果按照前面的步骤操作，只有 IP 地址是 192.168.0.2 和 192.168.0.3 的客户端才能够执行以上步骤<br>2) Windows 客户端建议安装 SecureCRT、Xmanager 和 VNC 客户端以实现 ssh、ssh 调用 virt-manager 和 VNC<br>）</p>



<h4 id="12-4-2-在-linux-图形客户端上和电脑互传数据的方法">12.4.2 在 Linux 图形客户端上和电脑互传数据的方法</h4>



<p>（只在客户端上执行以下步骤）</p>



<p>在文件 &#8211;&gt; 其他位置 &#8211;&gt; 连接到服务器的地址栏里输入以下内容：</p>



<pre class="wp-block-code"><code>smb://&lt;IP address of computer&gt;/&lt;samba directory&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>2) 如果按照前面的步骤操作，这里的 Samba 项目是 share<br>）</p>



<p>（注意：如果按照前面的步骤操作，只有 IP 地址是 192.168.0.2 和 192.168.0.3 的客户端才能够执行以上步骤）</p>



<h4 id="步骤十三-客户端直接使用公网-ip-地址联接电脑13-1-实现此步骤所需环境">步骤十三：客户端直接使用公网 IP 地址联接电脑<br>13.1 实现此步骤所需环境</h4>



<p>网关路由器拥有 IP 地址（可以通过给宽带申请公网 IP 地址并将光纤盒设置为桥接模式，在路由器上添加用户和密码实现）</p>



<h4 id="13-2-在路由器上将电脑上的-22-端口映射到路由器上的公网-ip-地址上-这样路由器上的公网-ip-地址就变成电脑的公网-ip-地址了">13.2 在路由器上将电脑上的 22 端口映射到路由器上的公网 IP 地址上，这样路由器上的公网 IP 地址就变成电脑的公网 IP 地址了</h4>



<p>（步骤略）</p>



<h4 id="13-3-将电脑的公网-ip-地址放到-vps-上13-3-1-将电脑的公网-ip-地址放到-vps-上的意义">13.3 将电脑的公网 IP 地址放到 VPS 上<br>13.3.1 将电脑的公网 IP 地址放到 VPS 上的意义</h4>



<p>由于大多数的公网 IP 地址都是动态，定期会变，所以可以通过此方法知道近期的公网 IP 地址是多少</p>



<h4 id="13-3-2-创建将电脑的公网-ip-地址放到-vps-上的脚本13-3-2-1-进入到用户">13.3.2 创建将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.2.1 进入到用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="13-3-2-2-创建将电脑的公网-ip-地址放到-vps-上的脚本">13.3.2.2 创建将电脑的公网 IP 地址放到 VPS 上的脚本</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vim /root/computerip.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash

computerip=`curl ifconfig.me`
domain=&lt;public IP address of VPS&gt;

ssh athenadb.com \"echo `curl ifconfig.me` &gt; /home/zhumingyu/serverip.txt\"</code></pre>



<p>（补充：将电脑的公网 IP 地址拷贝到 VPS 的 /tmp/computerip.txt 文件里为例）</p>



<h4 id="13-3-2-3-退出用户用户">13.3.2.3 退出用户用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="13-3-3-执行将电脑的公网-ip-地址放到-vps-上的脚本13-3-3-1-进入到用户用户">13.3.3 执行将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.3.1 进入到用户用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="13-3-3-2-配置定期执行的文件">13.3.3.2 配置定期执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ crontab -e</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
0 */10 * * * /home/zhumingyu/.crontab/computerip.txt</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
ssh &lt;public IP address of VPS&gt; \"echo `curl ifconfig.me` &gt; /home/zhumingyu/serverip.txt\"</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 将电脑的公网 IP 地址拷贝到 VPS 的 /home/zhumingyu/serverip.txt 文件里<br>）</p>



<h4 id="13-3-3-3-退出用户用户">13.3.3.3 退出用户用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="13-4-通过-ddns-服务显示电脑的公网-ip13-4-1-通过-ddns-服务显示电脑的公网-ip">13.4 通过 DDNS 服务显示电脑的公网 IP<br>13.4.1 通过 DDNS 服务显示电脑的公网 IP</h4>



<p>由于大多数的公网 IP 地址都是动态，定期会变，所以可以通过此方法知道近期的公网 IP 地址是多少</p>



<h4 id="13-4-2-有些-ddns-服务可以在网关路由器上设置-并且通过手机-app-显示现在的公网-ip-地址">13.4.2 有些 DDNS 服务可以在网关路由器上设置，并且通过手机 APP 显示现在的公网 IP 地址</h4>



<p>（步骤略）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] VMware Workstation Player 的安装 （CentOS Linux &#038; RHEL 版）</title>
		<link>https://eternalcenter-now.github.io/vmware-workstation-player-install-centos-linux-rhel/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 19 Sep 2020 07:09:07 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Virtualization (虚拟化)]]></category>
		<category><![CDATA[VMware]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=10565</guid>

					<description><![CDATA[软件准备： 在 VMware 的官网上下载软件 VMware Workstation Player（本次使用的是 VMware-Player-15.5.6-16341506.x86_64.bundle）： https://my.vmware.com/cn/web/vmware/downloads/info/slug/desktop_end_user_computing/vmware_workstation_player/16_0 正文： 步骤一：系统环境要求 服务器系统要配置好可用的软件源 步骤二：安装 VMware 虚拟化平台的依赖软件 步骤三：给 VMware 安装包执行权限 （补充：本次添加权限的是 VMware-Player-15.5.6-16341506.x86_64.bundle） 步骤四：安装 VMware 虚拟化平台 （补充：本次安装的是 VMware-Player-15.5.6-16341506.x86_64.bundle）]]></description>
										<content:encoded><![CDATA[
<h2>软件准备：</h2>



<p>在 VMware 的官网上下载软件 VMware Workstation Player（本次使用的是 VMware-Player-15.5.6-16341506.x86_64.bundle）：</p>



<p class="has-text-align-center"><a href="https://my.vmware.com/cn/web/vmware/downloads/info/slug/desktop_end_user_computing/vmware_workstation_player/16_0" target="_blank" rel="noreferrer noopener">https://my.vmware.com/cn/web/vmware/downloads/info/slug/desktop_end_user_computing/vmware_workstation_player/16_0</a></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2>正文：</h2>



<h4>步骤一：系统环境要求</h4>



<p>服务器系统要配置好可用的软件源</p>



<h4>步骤二：安装 VMware 虚拟化平台的依赖软件</h4>



<pre class="wp-block-code"><code># yum -y install perl gcc kernel-devel libX11 libXinerama libXcursor libXtst elfutils-libelf-devel</code></pre>



<h4>步骤三：给 VMware 安装包执行权限</h4>



<pre class="wp-block-code"><code># chmod u+x VMware-Player-15.5.6-16341506.x86_64.bundle</code></pre>



<p>（补充：本次添加权限的是 VMware-Player-15.5.6-16341506.x86_64.bundle）</p>



<h4>步骤四：安装 VMware 虚拟化平台</h4>



<pre class="wp-block-code"><code># ./VMware-Player-15.5.6-16341506.x86_64.bundle</code></pre>



<p>（补充：本次安装的是 VMware-Player-15.5.6-16341506.x86_64.bundle）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] KVM  虚拟机模板的创建 （CentOS Linux 8 版）</title>
		<link>https://eternalcenter-now.github.io/kvm-template-install-centos-linux-8/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Thu, 31 Oct 2019 14:21:44 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[KVM]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[System Installation (系统安装)]]></category>
		<category><![CDATA[Virtualization (虚拟化)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=6392</guid>

					<description><![CDATA[注意： 在创建 KVM 虚拟机之前要先安装 KVM 并创建 KVM 虚拟网络 软件准备： 在 CentOS 官网上下载安装系统所需要的镜像： https://centos.org/download/ 正文： 步骤目录： 步骤一：创建 KVM 虚拟机模板的目的 步骤二：为这个虚拟机创建硬盘文件2.1 创建硬盘文件2.2 确认硬盘文件已创建 步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机3.1 启动 KVM 的 virt-manager3.2 在 virt-manager 上的左上角点击文件之后点击“新建虚拟机”3.2.1 选择以本地安装介质的方式安装系统3.2.2 选择安装系统的系统镜像3.2.3 设置内存大小和 CPU 核心数3.2.4 选择用刚刚创建的硬盘文件来安装系统3.2.5 给虚拟机命名并选择虚拟网络3.2.6 开始安装系统3.2.7 选择系统语言3.2.8 之后进行系统配置界面3.2.8.1 通过 “INSTALLATION DESTINATION” 对硬盘进行分区3.2.8.2 取消 “KDUMP”3.2.8.3 选择最小化安装系统3.2.9 之后点击右下角的 “Begin installation”3.2.10 在安装的过程中设置 root 密码，安装完成后重启3.2.11 在安装系统的过程中需要注意的内容总结 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/kvm-template-install-centos-linux-8/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] KVM  虚拟机模板的创建 （CentOS Linux 8 版）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="注意">注意：</h2>



<p>在创建 KVM 虚拟机之前要先安装 KVM 并创建 KVM 虚拟网络</p>



<div class="wp-container-10 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/kvm-install/">KVM 的安装</a></div>



<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/kvm-network-install/">KVM 虚拟网络的创建</a></div>
</div>



<h2 id="软件准备">软件准备：</h2>



<p>在 CentOS 官网上下载安装系统所需要的镜像：</p>



<p class="has-text-align-center"><a href="https://centos.org/download/" target="_blank" rel="noreferrer noopener">https://centos.org/download/</a></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-创建-kvm-虚拟机模板的目的">步骤一：创建 KVM 虚拟机模板的目的</h4>



<h4 id="步骤二-为这个虚拟机创建硬盘文件-template-centos-8-10g-qcow22-1-创建硬盘文件-template-centos-8-10g-qcow22-2-确认硬盘文件-template-centos-8-10g-qcow2-已创建">步骤二：为这个虚拟机创建硬盘文件<br>2.1 创建硬盘文件<br>2.2 确认硬盘文件已创建</h4>



<h4 id="步骤三-使用-kvm-和刚刚创建的硬盘文件新安装一台虚拟机3-1-启动-kvm-的-virt-manager3-2-在-virt-manager-上的左上角点击文件之后点击-新建虚拟机-3-2-1-选择以本地安装介质的方式安装系统3-2-2-选择安装系统的系统镜像3-2-3-设置内存大小和处理器数量3-2-4-选择用刚刚创建的硬盘文件来安装系统3-2-5-给虚拟机命名为-template-centos-8-10g-并选择虚拟网络-vlan001-3-2-6-开始安装系统3-2-7-选择系统语言3-2-8-之后进行系统配置界面3-2-8-1-通过-installation-destination-对硬盘进行分区3-2-8-2-取消-kdump-3-2-8-3-选择最小化安装系统3-2-9-之后点击右下角的-begin-installation-3-2-10-在安装的过程中设置-root-密码-安装完成后重启3-2-11-在安装系统的过程中需要注意的内容总结">步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机<br>3.1 启动 KVM 的 virt-manager<br>3.2 在 virt-manager 上的左上角点击文件之后点击“新建虚拟机”<br>3.2.1 选择以本地安装介质的方式安装系统<br>3.2.2 选择安装系统的系统镜像<br>3.2.3 设置内存大小和 CPU 核心数<br>3.2.4 选择用刚刚创建的硬盘文件来安装系统<br>3.2.5 给虚拟机命名并选择虚拟网络<br>3.2.6 开始安装系统<br>3.2.7 选择系统语言<br>3.2.8 之后进行系统配置界面<br>3.2.8.1 通过 “INSTALLATION DESTINATION” 对硬盘进行分区<br>3.2.8.2 取消 “KDUMP”<br>3.2.8.3 选择最小化安装系统<br>3.2.9 之后点击右下角的 “Begin installation”<br>3.2.10 在安装的过程中设置 root 密码，安装完成后重启<br>3.2.11 在安装系统的过程中需要注意的内容总结</h4>



<h4 id="步骤四-进入新创建虚拟机修改配置4-1-修改网卡个性化设置4-1-1-修改网卡配置文件4-1-2-使修改的网卡配置生效4-2-禁用-selinux4-3-禁用空路由4-4-添加-console-配置4-4-1-修改-grub-内核配置文件4-4-2-使修改的-grub-内核配置生效4-5-将系统自动挂载的硬盘从使用-uuid-换成硬件路径4-5-1-显示根分区的-uuid4-5-2-在自动挂载文件里将根分区的-uuid-换成硬件路径4-6-删除不用的程序4-7-配置虚拟系统的-yum-源4-7-1-备份旧-yum-源4-7-1-1-创建备份目录4-7-1-2-备份旧-yum-源4-7-2-创建新的-yum-源文件4-7-3-删除旧的-yum-源数据4-7-4-刷新新的-yum-源4-8-对虚拟系统进行升级4-9-进行分区扩展4-9-1-安装分区扩展软件4-9-2-给开机自启配置文件相应的权限4-9-3-设置开机自动扩容根目录4-10-修改虚拟机系统的名称4-11-启用-serial-服务实现通过-virsh-console-命令控制虚拟机4-12-清除虚拟系统的历史命令4-13-关闭虚拟机">步骤四：进入新创建虚拟机修改配置<br>4.1 修改网卡个性化设置<br>4.1.1 修改网卡配置文件<br>4.1.2 使修改的网卡配置生效<br>4.2 禁用 selinux<br>4.3 禁用空路由<br>4.4 添加 Console 配置<br>4.4.1 修改 grub 内核配置文件<br>4.4.2 使修改的 grub 内核配置生效<br>4.5 将系统自动挂载的硬盘从使用 UUID 换成硬件路径<br>4.5.1 显示根分区的 UUID<br>4.5.2 在自动挂载文件里将根分区的 UUID 换成硬件路径<br>4.6 删除不用的程序<br>4.7 配置虚拟系统的 yum 源<br>4.7.1 备份旧 yum 源<br>4.7.1.1 创建备份目录<br>4.7.1.2 备份旧 yum 源<br>4.7.2 创建新的 yum 源文件<br>4.7.3 删除旧的 yum 源数据<br>4.7.4 刷新新的 yum 源<br>4.8 对虚拟系统进行升级<br>4.9 进行分区扩展<br>4.9.1 安装分区扩展软件<br>4.9.2 给开机自启配置文件相应的权限<br>4.9.3 设置开机自动扩容根目录<br>4.10 修改虚拟机系统的名称<br>4.11 启用 serial 服务实现通过 virsh console 命令控制虚拟机<br>4.12 清除虚拟系统的历史命令<br>4.13 关闭虚拟机</h4>



<h4 id="步骤五-在真机上对虚拟机进行清理优化">步骤五：在真机上对虚拟机进行清理优化</h4>



<h4 id="步骤六-此时就可以将此虚拟机的硬件文件作为模块批量克隆虚拟机了">步骤六：此时就可以将此虚拟机的硬件文件作为模块批量克隆虚拟机了</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-理解创建-kvm-虚拟机模板的目的">步骤一：理解创建 KVM 虚拟机模板的目的</h4>



<p>主要用于批量克隆出新的 KVM 机器，节约创建新虚拟机的时间</p>



<h4 id="步骤二-为这个虚拟机创建硬盘文件-template-centos-8-10g-qcow22-1-创建硬盘文件-template-centos-8-10g-qcow2">步骤二：为这个虚拟机创建硬盘文件<br>2.1 创建硬盘文件</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># qemu-img create -f qcow2 /var/lib/libvirt/images/template_centos_8_10g.qcow2 10G</code></pre>



<p>（补充：这里以创建 10G 大小的 template_centos_8_10g.qcow2 硬盘文件为例）</p>



<h4 id="2-2-确认硬盘文件已创建">2.2 确认硬盘文件已创建</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># ls /var/lib/libvirt/images/ | grep template_centos_8_10g.qcow2</code></pre>



<p>（补充：这里以确认 template_centos_8_10g.qcow2 硬盘文件为例）</p>



<h4 id="步骤三-使用-kvm-和刚刚创建的硬盘文件新安装一台虚拟机3-1-启动-kvm-的-virt-manager">步骤三：使用 KVM 和刚刚创建的硬盘文件新安装一台虚拟机<br>3.1 启动 KVM 的 virt-manager</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># virt-manager</code></pre>



<h4 id="3-2-在-virt-manager-上的左上角点击文件之后点击-新建虚拟机">3.2 在 virt-manager 上的左上角点击文件之后点击 “新建虚拟机”</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（步骤略）</p>



<h4 id="3-2-1-选择以本地安装介质的方式安装系统">3.2.1 选择以本地安装介质的方式安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="448" height="482" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-1.png" alt="" class="wp-image-19710" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-1.png 448w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-1-279x300.png 279w" sizes="(max-width: 448px) 100vw, 448px" /><figcaption>（图：1）</figcaption></figure></div>



<h4 id="3-2-2-选择安装系统的系统镜像">3.2.2 选择安装系统的系统镜像</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="458" height="448" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-2.png" alt="" class="wp-image-19711" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-2.png 458w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-2-300x293.png 300w" sizes="(max-width: 458px) 100vw, 458px" /><figcaption>（图：2）</figcaption></figure></div>



<p>（补充：这里以使用 CentOS-8-x86_64-1905-dvd1.iso 系统镜像为例）</p>



<h4 id="3-2-3-设置内存大小和处理器数量">3.2.3 设置内存大小和 CPU 核心数</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="448" height="448" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-3.png" alt="" class="wp-image-19712" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-3.png 448w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-3-300x300.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-3-150x150.png 150w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-3-100x100.png 100w" sizes="(max-width: 448px) 100vw, 448px" /><figcaption>（图：3）</figcaption></figure></div>



<p>（补充：这里以设置 2048 MiB 内容和 2 核 CPU 为例）</p>



<h4 id="3-2-4-选择用刚刚创建的硬盘文件来安装系统">3.2.4 选择用刚刚创建的硬盘文件来安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="448" height="448" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-4.png" alt="" class="wp-image-19713" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-4.png 448w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-4-300x300.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-4-150x150.png 150w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-4-100x100.png 100w" sizes="(max-width: 448px) 100vw, 448px" /><figcaption>（图：4）</figcaption></figure></div>



<p>（补充：这里以使用 template_centos_8_10g.qcow2 硬盘文件为例）</p>



<h4 id="3-2-5-给虚拟机命名并选择虚拟网络">3.2.5 给虚拟机命名并选择虚拟网络</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（注意：虚拟网络必须提前创建好）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="448" height="499" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-5.png" alt="" class="wp-image-19714" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-5.png 448w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-5-269x300.png 269w" sizes="(max-width: 448px) 100vw, 448px" /><figcaption>（图：5）</figcaption></figure></div>



<p>（补充：这里以将虚拟机命名为 template_centos_8_10g 并使用 vlan001 网络为例）</p>



<h4 id="3-2-6-开始安装系统">3.2.6 开始安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="612" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-6.png" alt="" class="wp-image-19715" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-6.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-6-300x239.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：6）</figcaption></figure></div>



<h4 id="3-2-7-选择系统语言">3.2.7 选择系统语言</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-7.png" alt="" class="wp-image-19717" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-7.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-7-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：7）</figcaption></figure></div>



<h4 id="3-2-8-之后进行系统配置界面">3.2.8 之后进行系统配置界面</h4>



<p>（只在真机上执行以下步骤）</p>



<p>需要手动配置的地方有三个：<br>1) “INSTALLATION DESTINATION”<br>2) “KDUMP”<br>3) “SOFTWARE SELECTION”<br>分别点击以后就可以配置了</p>



<h4 id="3-2-8-1-通过-installation-destination-对硬盘进行分区">3.2.8.1 通过 “INSTALLATION DESTINATION” 对硬盘进行分区</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（补充：完成后点击左上角的 “DONE”）</p>



<p>（注意：只分一个分区，只设置一个挂载点挂载到根，使用标准硬盘类型，硬盘格式设置为 XFS）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-8.png" alt="" class="wp-image-19718" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-8.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-8-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：8）</figcaption></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-9.png" alt="" class="wp-image-19719" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-9.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-9-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：9）</figcaption></figure></div>



<h4 id="3-2-8-2-取消-kdump">3.2.8.2 取消 “KDUMP”</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（补充：完成后点击左上角的 “DONE”）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-10.png" alt="" class="wp-image-19720" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-10.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-10-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：10）</figcaption></figure></div>



<h4 id="3-2-8-3-选择最小化安装系统">3.2.8.3 选择最小化安装系统</h4>



<p>（只在真机上执行以下步骤）</p>



<p>（补充：完成后点击左上角的 “DONE”）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-11.png" alt="" class="wp-image-19721" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-11.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-11-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：11）</figcaption></figure></div>



<h4 id="3-2-9-之后点击右下角的-begin-installation">3.2.9 之后点击右下角的 “Begin installation”</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-12.png" alt="" class="wp-image-19722" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-12.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-12-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：12）</figcaption></figure></div>



<h4 id="3-2-10-在安装的过程中设置-root-密码-安装完成后重启">3.2.10 在安装的过程中设置 root 密码，安装完成后重启</h4>



<p>（只在真机上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-13.png" alt="" class="wp-image-19723" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-13.png 768w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/KVM-template-CentOS-8-13-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：13）</figcaption></figure></div>



<h4 id="3-2-11-在安装系统的过程中需要注意的内容总结">3.2.11 在安装系统的过程中需要注意的内容总结</h4>



<p>（只在真机上执行以下步骤）</p>



<p>1) 一定要使用刚刚创建的 /var/lib/libvirt/images/template_centos_8_10g.qcow2 作为安装虚拟机的硬件文件<br>2) 虚拟机网络 “vlan001” 要提前创建好<br>3) 只分一个分区，只设置一个挂载点挂载到根，使用标准硬盘，硬盘格式是 XFS<br>4) 取消 “KDUMP”<br>5) 选择最小化安装系统</p>



<h4 id="步骤四-进入新创建虚拟机修改配置4-1-修改网卡个性化设置4-1-1-修改网卡配置文件">步骤四：进入新创建虚拟机修改配置<br>4.1 修改网卡个性化设置<br>4.1.1 修改网卡配置文件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/sysconfig/network-scripts/ifcfg-ens3</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code>TYPE=Ethernet
BOOTPROTO=dhcp
NAME=ens3
DEVICE=ens3
ONBOOT=yes</code></pre>



<h4 id="4-1-2-使修改的网卡配置生效">4.1.2 使修改的网卡配置生效</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># reboot</code></pre>



<h4 id="4-2-禁用-selinux">4.2 禁用 SELinux</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/selinux/config</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code># This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=disabled
# SELINUXTYPE= can take one of three values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected.
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted</code></pre>



<h4 id="4-3-禁用空路由">4.3 禁用空路由</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/sysconfig/network</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code># Created by anaconda
NOZEROCONF="yes"</code></pre>



<h4 id="4-4-添加-console-配置4-4-1-修改-grub-内核配置文件">4.4 添加 Console 配置<br>4.4.1 修改 grub 内核配置文件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/default/grub</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code>GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL="serial console"
GRUB_SERIAL_COMMAND="serial --unit=1 --speed=115200"
GRUB_CMDLINE_LINUX="biosdevname=0 net.ifnames=0 console=tty0 console=ttyS0,115200n8"
GRUB_DISABLE_LINUX_UUID="true"
GRUB_ENABLE_LINUX_LABEL="true"
GRUB_DISABLE_RECOVERY="true"</code></pre>



<h4 id="4-4-2-使修改的-grub-内核配置生效">4.4.2 使修改的 grub 内核配置生效</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># grub2-mkconfig -o grub</code></pre>



<h4 id="4-5-将系统自动挂载的硬盘从使用-uuid-换成硬件路径4-5-1-显示根分区的-uuid">4.5 将系统自动挂载的硬盘从使用 UUID 换成硬件路径<br>4.5.1 显示根分区的 UUID</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># blkid
/dev/sda1: UUID="e76ed189-6d0f-49d5-8586-c5aae4bdc9b5" TYPE="xfs" PARTUUID="3d8377ef-01"</code></pre>



<p>（补充：这里的 UUID 是： e76ed189-6d0f-49d5-8586-c5aae4bdc9b5）</p>



<h4 id="4-5-2-在自动挂载文件里将根分区的-uuid-换成硬件路径">4.5.2 在自动挂载文件里将根分区的 UUID 换成硬件路径</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/fstab</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
UUID=e76ed189-6d0f-49d5-8586-c5aae4bdc9b5 /                   xfs     defaults        0 0</code></pre>



<p>（补充：这里的 UUID 是： e76ed189-6d0f-49d5-8586-c5aae4bdc9b5）</p>



<p>修改为：</p>



<pre class="wp-block-code"><code>/dev/sda1 /                   xfs     defaults        0 0</code></pre>



<h4 id="4-6-删除不用的程序">4.6 删除不用的程序</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y remove firewalld-* python-firewall</code></pre>



<h4 id="4-7-配置虚拟系统的-yum-源4-7-1-备份旧-yum-源4-7-1-1-创建备份目录">4.7 配置虚拟系统的 yum 源<br>4.7.1 备份旧 yum 源<br>4.7.1.1 创建备份目录</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># mkdir /etc/yum.repos.d/backup</code></pre>



<h4 id="4-7-1-2-备份旧-yum-源">4.7.1.2 备份旧 yum 源</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup</code></pre>



<h4 id="4-7-2-创建新的-yum-源文件">4.7.2 创建新的 yum 源文件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/yum.repos.d/lan.repo</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>&#91;CentOS8BaseOS]
name=CentOS8BaseOS
baseurl=http://192.168.100.254/CentOS8/BaseOS/
enabled=1
gpgcheck=0

&#91;CentOS8AppStream]
name=CentOS8AppStream
baseurl=http://192.168.100.254/CentOS8/AppStream/
enabled=1
gpgcheck=0</code></pre>



<p>(注意：http://192.168.1.250/centos8/ 需要根据真实环境的情况进行更改)</p>



<h4 id="4-7-3-删除旧的-yum-源数据">4.7.3 删除旧的 yum 源数据</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum clean all</code></pre>



<h4 id="4-7-4-刷新新的-yum-源">4.7.4 刷新新的 yum 源</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum repolist</code></pre>



<h4 id="4-8-对虚拟系统进行升级">4.8 对虚拟系统进行升级</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y update</code></pre>



<h4 id="4-9-进行分区扩展4-9-1-安装分区扩展软件">4.9 进行分区扩展<br>4.9.1 安装分区扩展软件</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum install -y cloud-utils-growpart</code></pre>



<h4 id="4-9-2-给开机自启配置文件相应的权限">4.9.2 给开机自启配置文件相应的权限</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod 755 /etc/rc.local</code></pre>



<h4 id="4-9-3-设置开机自动扩容根目录">4.9.3 设置开机自动扩容根目录</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/rc.local</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
/usr/bin/growpart /dev/sda1
/usr/sbin/xfs_growfs /</code></pre>



<h4 id="4-10-修改虚拟机系统的名称">4.10 修改虚拟机系统的名称</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/hostname</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code>template_centos_8_10g
</code></pre>



<h4 id="4-11-启用-serial-服务实现通过-virsh-console-命令控制虚拟机">4.11 启用 serial 服务实现通过 virsh console 命令控制虚拟机</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl start serial-getty@ttyS0
# systemctl enable serial-getty@ttyS0</code></pre>



<h4 id="4-12-清除虚拟系统的历史命令">4.12 清除虚拟系统的历史命令</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># history -c</code></pre>



<h4 id="4-13-关闭虚拟机">4.13 关闭虚拟机</h4>



<p>（只在虚拟机上执行以下步骤）</p>



<pre class="wp-block-code"><code># poweroff</code></pre>



<h4 id="步骤五-在真机上对虚拟机进行清理优化">步骤五：在真机上对虚拟机进行清理优化</h4>



<p>（只在真机上执行以下步骤）</p>



<pre class="wp-block-code"><code># sudo virt-sysprep -d template_centos_8_10g</code></pre>



<p>（补充：这里以清理 template_centos_8_10g 虚拟机为例）</p>



<p>（<br>注意：如果此命令不存在<br>1) CentOS 系统的话需要安装 libguestfs-tools<br>2) openSUSE 系统的话需要安装 guestfs-tools<br>）</p>



<h4 id="步骤六-此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了">步骤六：此时就可以将此虚拟机的硬件文件作为模板进行批量克隆虚拟机了</h4>



<p>（只在真机上执行以下步骤）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Hadoop 大数据平台三种部署模式的简介</title>
		<link>https://eternalcenter-now.github.io/hadoop-info/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 20 Sep 2019 08:13:41 +0000</pubDate>
				<category><![CDATA[Big Data (大数据)]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Hadoop]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=5829</guid>

					<description><![CDATA[模式一：单机模式 1) 所有 Hadoop 角色都在一台物理机上2) 只有一个物理节点3) 一般用来学习和测试 模式二：伪分布模式 1) 所有 Hadoop 角色都在一台物理机上2) 有多虚拟个节点3) 一般用来学习和测试 模式三：完全分布式模式 1) 所有 Hadoop 角色在多台物理机上2) 有多个物理节点3) 一般用在生产环境4) 有高可用和高性能的特点]]></description>
										<content:encoded><![CDATA[
<h4>模式一：单机模式</h4>



<p>1) 所有 Hadoop 角色都在一台物理机上<br>2) 只有一个物理节点<br>3) 一般用来学习和测试</p>



<h4>模式二：伪分布模式</h4>



<p>1) 所有 Hadoop 角色都在一台物理机上<br>2) 有多虚拟个节点<br>3) 一般用来学习和测试</p>



<h4>模式三：完全分布式模式</h4>



<p>1) 所有 Hadoop 角色在多台物理机上<br>2) 有多个物理节点<br>3) 一般用在生产环境<br>4) 有高可用和高性能的特点</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
