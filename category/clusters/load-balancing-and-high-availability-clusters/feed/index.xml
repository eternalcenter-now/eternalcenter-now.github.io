<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Load Balancing and High Availability Clusters (负载均衡加高可用集群) &#8211; Eternal Center</title>
	<atom:link href="https://eternalcenter-now.github.io/category/clusters/load-balancing-and-high-availability-clusters/feed/" rel="self" type="application/rss+xml" />
	<link>https://eternalcenter-now.github.io/</link>
	<description></description>
	<lastBuildDate>Thu, 03 Feb 2022 09:05:46 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>分布式存储算法介绍</title>
		<link>https://eternalcenter-now.github.io/introduction-to-distributed-storage-algorithm/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 20 Aug 2021 07:45:22 +0000</pubDate>
				<category><![CDATA[Ceph]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[Distributed Cloud Storage Clusters (分布式云存储集群)]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[OpenStack]]></category>
		<category><![CDATA[Virtualization Clouds (虚拟化云)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=17540</guid>

					<description><![CDATA[章节一：传统的 Hash 存储算法1.1 传统的 Hash 存储算法简介 　　将数据进行切片，对每份切片进行 Hash 取值，并对获取的 Hash 值除以存储节点的数量以取余，余数是多少就将此切片存在第几个 OSD 节点里，主要是 Swift 在使用。 1.2 传统的 Hash 存储算法的缺点 　　如果要增加存或减少存储节点，需要对所有已存储数据切片的 Hash 值重新取余，大概 90% 的数据需要重新均衡数据（rebalance）。 章节二：一致性 Hash 算法2.1 一致性 Hash 算法简介 　　1) 给电脑也计算 Hash 值（可以是给电脑名计算 Hash 值，也可以给 IP 地址计算 Hash 值）　　2) 再给数据也计算 Hash 值，将数据存到比它的 Hash 值大，且与它的差值最小的一台电脑上，如果没有 Hash 值比它大的电脑就直接将数据存在 Hash 值最小的电脑上　　3) 整个架构类似一个环 2.2 一致性 Hash 算法的缺点 　　1) &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/introduction-to-distributed-storage-algorithm/" class="more-link">Continue reading<span class="screen-reader-text"> "分布式存储算法介绍"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4>章节一：传统的 Hash 存储算法<br>1.1 传统的 Hash 存储算法简介</h4>



<p>　　将数据进行切片，对每份切片进行 Hash 取值，并对获取的 Hash 值除以存储节点的数量以取余，余数是多少就将此切片存在第几个 OSD 节点里，主要是 Swift 在使用。</p>



<h4>1.2 传统的 Hash 存储算法的缺点</h4>



<p>　　如果要增加存或减少存储节点，需要对所有已存储数据切片的 Hash 值重新取余，大概 90% 的数据需要重新均衡数据（rebalance）。</p>



<h4>章节二：一致性 Hash 算法<br>2.1 一致性 Hash 算法简介</h4>



<p>　　1) 给电脑也计算 Hash 值（可以是给电脑名计算 Hash 值，也可以给 IP 地址计算 Hash 值）<br>　　2) 再给数据也计算 Hash 值，将数据存到比它的 Hash 值大，且与它的差值最小的一台电脑上，如果没有 Hash 值比它大的电脑就直接将数据存在 Hash 值最小的电脑上<br>　　3) 整个架构类似一个环</p>



<h4>2.2 一致性 Hash 算法的缺点</h4>



<p>　　1) 电脑太少时切换数据也会有较大的数据量，但是可以多设置几个虚拟节点，给以后新增加的节点使用，虚拟节点里的数据会影射到对应的物理节点里面去<br>　　2) 电脑太少时，两台电脑的 Hash 值比较接近导致，数据分配极度不平均</p>



<p>（注意：在开始创建数据架构时，要评估未来数据的规模，如果最后要添加的电脑数量超过了虚拟节点数量，那么这个架构就不能使用了。此时只能备份数据，然后新建一个架构出来）</p>



<h4>章节三：CRUSH<br>3.1 CRUSH 简介</h4>



<p>　　CRUSH（Controlled Replication Under Scalable Hashing）算法，在可扩展 Hash 算法下的可控制复制，主要是 Ceph 在使用。</p>



<h4>3.2 CRUSH 算法<br>3.2.1 CRUSH 算法的第一层</h4>



<p>　　由 Ceph 的 OSD（Object Storage Deivces）组成。</p>



<h4>3.2.2 CRUSH 算法的第二层<br>3.2.3 CRUSH 算法的第二层的组成</h4>



<p>　　由 Ceph 的 PG（Placement Group）归置组组成。</p>



<h4>3.2.4 CRUSH 算法的第二层的由来</h4>



<p>　　在 OSD 节点上虚拟出多个 PG，每个 PG 默认会被指定对应 3 个 OSD 节点（每个 OSD 节点同时可以属于多个 PG），其中第一个 OSD 节点为主要（primary）的硬盘，其他两 OSD 节点为从（second）硬盘，PG 会对应几个 OSD 节点取决于 Ceph 的存储副本被设置了几份。</p>



<h4>3.2.5 CRUSH 算法的第二层的算法</h4>



<p>　　1) 给每个 OSD 节点设置一个权重值，OSD 节点的容量越大则其权重值越大<br>　　2) 主要（primary）硬盘的 OSD 节点：将 PG 的 ID 值和 OSD 的 ID 值组合在一起并计算 Hash 值，将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时，此 PG 就和此 OSD 绑定在一起<br>　　3) 第一个从（second）硬盘的 OSD 节点：将 PG 的 ID 值逐一和 OSD 的 ID 值和一个随机的常数组合在一起并计算 Hash 值（这个值在 Ceph 的代码里被叫做 draw），将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时（这个值在 Ceph 的源代码里叫做 straw）则此 PG 就和此 OSD 绑定在一起<br>　　4) 第二个从（second）硬盘的 OSD 节点：将 PG 的 ID 值逐一和 OSD 的 ID 值和上一个随机常数加 1 的和组合在一起并计算 Hash 值（这个值在 Ceph 的代码里被叫做 draw），将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时（这个值在 Ceph 的源代码里叫做 straw），则此 PG 就和此 OSD 绑定在一起（如果找到的 OSD 节点和前面的 OSD 节点重复，则将这个随机常数再加 1 并进行重复操作，最终获得和前面不通的 OSD 节点为止）<br>……</p>



<h4>3.3 CRUSH 算法的第三层<br>3.3.1 CRUSH 算法的第三层的组成</h4>



<p>　　由池组成。</p>



<h4>3.3.2 CRUSH 算法的第三层的由来</h4>



<p>　　1) 在 PG 上虚拟出多个池，每个池对应多个 PG，数据可以存储到指定的池里<br>　　2) 总硬盘容量有多大，每个池最大可以使用的容量就有多大，但是如果如果一个池使用了一部分容量，其他的池就要少使用一部分容量</p>



<h4>3.4 CRUSH 算法的第四层<br>3.4.1 CRUSH 算法的第四层的组成</h4>



<p>　　由数据组成。</p>



<h4>3.4.2 CRUSH 算法的第四层的算法</h4>



<p>　　1) 对要放入某个池里的数据进行切片，默认每片 4M<br>　　2) 对每份切片进行 Hash 取值，并对获取的 Hash 值除以这个池里 PG 节点的数量以取余，余数是多少就存在第几个 OSD 节点里</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Ceph 介绍</title>
		<link>https://eternalcenter-now.github.io/introduction-of-ceph/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 20 Aug 2021 07:13:01 +0000</pubDate>
				<category><![CDATA[Ceph]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[Distributed Cloud Storage Clusters (分布式云存储集群)]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[OpenStack]]></category>
		<category><![CDATA[Virtualization Clouds (虚拟化云)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=17526</guid>

					<description><![CDATA[内容一：Ceph 简介 Ceph 是一种分布式存储架构和技术。此项目是 2004 年由 Sage Weil 在加州大学 Santa Cruz 分校攻读博士期间的创建和研究的课题，并于 2006 年将其开源，同时成立 Inktank 公司专注 Ceph 的研发。2014 年 5 月 Inktank 公司被 Red Hat 收购。 内容二：Ceph 的特点 1) 高性能（硬盘越多性能越高，所有硬盘可以同时读写）2) 高可用（硬盘越多高可用越高） 内容三：Ceph 使用的方式 1) 自己写程序：通过 C C++ Java Python Ruby PHP 等语言写程序调用 Ceph 底层存储 LIBRADOS，此方法性能最高2) 自己写脚本：写对象脚本，通过 RGW（RADOSGW）对象存储网关的 Rest API 接口去访问 Ceph 的底层存储 LIBRADOS，此方法性能第二高3) 挂载块存储：通过 Linux &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/introduction-of-ceph/" class="more-link">Continue reading<span class="screen-reader-text"> "[内容] Ceph 介绍"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4>内容一：Ceph 简介</h4>



<p>Ceph 是一种分布式存储架构和技术。此项目是 2004 年由 Sage Weil 在加州大学 Santa Cruz 分校攻读博士期间的创建和研究的课题，并于 2006 年将其开源，同时成立 Inktank 公司专注 Ceph 的研发。2014 年 5 月 Inktank 公司被 Red Hat 收购。</p>



<h4>内容二：Ceph 的特点</h4>



<p>1) 高性能（硬盘越多性能越高，所有硬盘可以同时读写）<br>2) 高可用（硬盘越多高可用越高）</p>



<h4>内容三：Ceph 使用的方式</h4>



<p>1) 自己写程序：通过 C C++ Java Python Ruby PHP 等语言写程序调用 Ceph 底层存储 LIBRADOS，此方法性能最高<br>2) 自己写脚本：写对象脚本，通过 RGW（RADOSGW）对象存储网关的 Rest API 接口去访问 Ceph 的底层存储 LIBRADOS，此方法性能第二高<br>3) 挂载块存储：通过 Linux 内核或者 KVM 等虚拟机存储驱动访问 Ceph 的块存储，此方法性能第三高<br>4) 挂载文件系统：通过 Linux 内核（POSIX 命令）挂载 Ceph 的文件系统存储，此方法性能最弱</p>



<h4>内容四：Ceph 的组成</h4>



<p>1) OSD（Object Storage Deivces）：负责存储、复制、恢复数据等，默认要有 3 台以上才能实现高可用，因为 Ceph 默认有三副本<br>2) MON（Monitor）：负责监控集群状态制作和更新存储地图（map），供客户端从下载，在生产环境里必须要有 3 台以上，且最好是奇数台，因为必须遵循过半原则<br>3) MDS（Metadata Servers）：实现文件系统存储，允许客户端通过 Linux 内核（POSIX 命令）挂载 Ceph 的文件系统存储<br>4) RGW（RADOSGW）：实现对象存储网关，允许客户端通过 RGW（RADOSGW）对象存储网关的 Rest API 接口去访问 Ceph 的底层存储 LIBRADOS<br>5) 客户端：使用从 MON 下载和更新的存储地图，通过算法，直接从 OSD 访问数据</p>



<h4>内容五：Ceph 架构<br>5.1 Ceph 使用架构<br>5.1.1 Ceph 的上层</h4>



<p>自己写程序、自己写脚本、挂载块存储、挂载文件系统 4 种使用方式。</p>



<h4>5.1.2 Ceph 的下层</h4>



<p>RADOS，基于对象的存储（比我们平时所说的对象存储更原始，更底层），通过软件实现自我检查、自我备份和自我修复的功能。</p>



<h4>5.2 Ceph 组成架构</h4>



<pre class="wp-block-code"><code>                                  File

                  Cut1(Objects1) Cut2(Objects2) Cut3(Objects3)......

                              choice Pool

              Pool1                                   Pool2
     PG1                PG2                  PG2               PG3
OSD1 OSD2 OSD3    OSD2 OSD5 OSD3        OSD1 OSD4 OSD3    OSD4 OSD5 OSD3
Disk Disk Disk    Disk Disk Disk        Disk Disk Disk    Disk Disk Disk</code></pre>



<h4>内容六：Ceph 的算法：CRUSH<br>6.1 CRUSH 简介</h4>



<p>CRUSH（Controlled Replication Under Scalable Hashing）算法，在可扩展 Hash 算法下的可控制复制</p>



<h4>6.2 CRUSH 算法的第一层</h4>



<p>由 OSD（Object Storage Deivces）组成。</p>



<h4>6.3 CRUSH 算法的第二层<br>6.3.1 CRUSH 算法的第二层的组成</h4>



<p>由 PG（Placement Group）归置组组成。</p>



<h4>6.3.2 CRUSH 算法的第二层的由来</h4>



<p>在 OSD 节点上虚拟出多个 PG，每个 PG 默认会被指定对应 3 个 OSD 节点（每个 OSD 节点同时可以属于多个 PG），其中第一个 OSD 节点为主要（primary）的硬盘，其他两 OSD 节点为从（second）硬盘，PG 会对应几个 OSD 节点取决于 Ceph 的存储副本被设置了几份。</p>



<h4>6.3.3 CRUSH 算法的第二层的算法</h4>



<p>1) 给每个 OSD 节点设置一个权重值，OSD 节点的容量越大则其权重值越大<br>2) 主要（primary）硬盘的 OSD 节点：将 PG 的 ID 值和 OSD 的 ID 值组合在一起并计算 Hash 值，将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时，此 PG 就和此 OSD 绑定在一起<br>3) 第一个从（second）硬盘的 OSD 节点：将 PG 的 ID 值逐一和 OSD 的 ID 值和一个随机的常数组合在一起并计算 Hash 值（这个值在 Ceph 的代码里被叫做 draw），将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时（这个值在 Ceph 的源代码里叫做 straw）则此 PG 就和此 OSD 绑定在一起<br>4) 第二个从（second）硬盘的 OSD 节点：将 PG 的 ID 值逐一和 OSD 的 ID 值和上一个随机常数加 1 的和组合在一起并计算 Hash 值（这个值在 Ceph 的代码里被叫做 draw），将得到的 Hash 值乘以此 OSD 节点的权重，当最终获得的值最大时（这个值在 Ceph 的源代码里叫做 straw），则此 PG 就和此 OSD 绑定在一起（如果找到的 OSD 节点和前面的 OSD 节点重复，则将这个随机常数再加 1 并进行重复操作，最终获得和前面不通的 OSD 节点为止）<br>5) 第三个从（second）硬盘的 OSD 节点：仿照第二个从（second）硬盘的 OSD 节点方式以此类推</p>



<h4>6.4 CRUSH 算法的第三层<br>6.4.1 CRUSH 算法的第三层的组成</h4>



<p>由池组成。</p>



<h4>6.4.2 CRUSH 算法的第三层的由来</h4>



<p>1) 在 PG 上虚拟出多个池，每个池对应多个 PG，数据可以存储到指定的池里<br>2) 总硬盘容量有多大，每个池最大可以使用的容量就有多大，但是如果如果一个池使用了一部分容量，其他的池就要少使用一部分容量</p>



<h4>6.5 CRUSH 算法的第四层<br>6.5.1 CRUSH 算法的第四层的组成</h4>



<p>由数据组成。</p>



<h4>6.5.2 CRUSH 算法的第四层的算法</h4>



<p>1) 对要放入某个池里的数据进行切片，默认每片 4M<br>2) 对每份切片进行 Hash 取值，并对获取的 Hash 值除以这个池里 PG 节点的数量以取余，余数是多少就存在第几个 OSD 节点里</p>



<h4>内容七：Ceph 的工作流程</h4>



<p>1) 客户端从 MON 上下载最新的存储地图（map）<br>2) 存储地图（map）把集群里所有 MON、OSD 和 MDS 的信息告诉客户端，但是客户端依然不知道想要找的数据存放在哪<br>3) 客户端通过 CRUSH 计算出所需要读写的数据存放的 OSD 节点位置<br>4) 客户端直接在 OSD 节点位置上读写数据<br>5) 用户只需要把数据数据写入主要 OSD 节点硬盘上，然后 Ceph 自动同步给其他的从 OSD 节点硬盘上</p>



<h4>内容八：Ceph 的维护</h4>



<p>1) PG 的个数肯定要大于 OSD 节点的数量，在生产的环境中 PG 设计的数量往往会远远大于 OSD 节点的数量，以满足未来可能几年的需求，可能会在 3 个硬盘上添加上百个 PG<br>2) 当增加存或减少存储节点时，PG 的数量不会发生变化，只有 PG 对应 OSD 节点有变化的数据才会需要重新均衡数据（rebalance）的数据<br>3) 当增加存或减少 PG 数量时，就需要像传统的 Hash 存储算法那样，对所有已存储数据切片的 Hash 值重新取余，大概 90 % 的数据需要重新均衡数据（rebalance）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Linux 格式化特点</title>
		<link>https://eternalcenter-now.github.io/linux-formatting-features/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Thu, 19 Aug 2021 12:02:18 +0000</pubDate>
				<category><![CDATA[Ceph]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[Distributed Cloud Storage Clusters (分布式云存储集群)]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[System Hardware (系统硬件)]]></category>
		<category><![CDATA[System Storage (系统存储)]]></category>
		<category><![CDATA[System Storage & System Directory & System File (系统存储 & 系统目录 & 系统文件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=17520</guid>

					<description><![CDATA[内容一：格式化后会产生的分区 格式化会格式出 inode 区和 block 区 内容二：inode 区和 block 区的作用 inode 区默认一格大小是 512 个字节，存储哪一份数据存在了哪些 block 里以及数据的所属者、权限创建时间等 metadata 元数据block 区默认一格大小是 4k，只存储数据本身 内容三：Linux 文件格式的特点 ext3 和 ext4 的 inode 区每一格较小，而 xfs 的 inode 区每一格更大，可以存储更多种类，例如快照等 metadata 元数据]]></description>
										<content:encoded><![CDATA[
<h4>内容一：格式化后会产生的分区</h4>



<p>格式化会格式出 inode 区和 block 区</p>



<h4>内容二：inode 区和 block 区的作用</h4>



<p>inode 区默认一格大小是 512 个字节，存储哪一份数据存在了哪些 block 里以及数据的所属者、权限创建时间等 metadata 元数据<br>block 区默认一格大小是 4k，只存储数据本身</p>



<h4>内容三：Linux 文件格式的特点</h4>



<p>ext3 和 ext4 的 inode 区每一格较小，而 xfs 的 inode 区每一格更大，可以存储更多种类，例如快照等 metadata 元数据</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[实验] 通过 Nginx + Keepalived 实现网站负载均衡加高可用</title>
		<link>https://eternalcenter-now.github.io/nginx-keepalived-web/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 19 Feb 2021 09:24:24 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cluster High Availability Tools (集群高可用工具)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[High Availability Clusters (高可用集群)]]></category>
		<category><![CDATA[Keepalived]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[Nginx]]></category>
		<category><![CDATA[Nginx + Keepalived]]></category>
		<category><![CDATA[Nginx Function (功能)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[Website Service Redundant Agent or Redundant Dispatch Clusters (网站服务冗余代理或冗余调度集群)]]></category>
		<category><![CDATA[Website Services (网站服务)]]></category>
		<category><![CDATA[纪念 Anniversary]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=13543</guid>

					<description><![CDATA[纪念：站主于 2021 年 2 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程 步骤目录： 步骤一：拓扑图1.1 服务器列表1.2 拓扑图1.3 拓扑图简介 步骤二： 系统环境要求 步骤三：搭建网站服务3.1 在 web1 上搭建网站服务3.1.1 在 web1 上安装 Nginx3.1.2 给 web1 制定网页3.1.3 启动 Nginx 并将它设置为开机自启3.2 在 web2 上搭建网站服务3.2.1 在 web2 上安装 Apache3.2.2 给 web2 制定网页3.2.3 启动 Apache 并将它设置为开机自启 步骤四：搭建代理服务4.1 安装 Nginx4.2 修改 Nginx 配置文件4.3 启动 Nginx 并将它设置为开机自启 步骤五：搭建高可用服务5.1 安装 Keepalived5.2 创建 Keepalived 检查脚本5.3 修改 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/nginx-keepalived-web/" class="more-link">Continue reading<span class="screen-reader-text"> "[实验] 通过 Nginx + Keepalived 实现网站负载均衡加高可用"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<p class="has-vivid-red-color has-text-color has-medium-font-size"><strong>纪念：站主于 2021 年 2 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程</strong></p>



<h2>步骤目录：</h2>



<h4>步骤一：拓扑图<br>1.1 服务器列表<br>1.2 拓扑图<br>1.3 拓扑图简介</h4>



<h4>步骤二： 系统环境要求</h4>



<h4>步骤三：搭建网站服务<br>3.1 在 web1 上搭建网站服务<br>3.1.1 在 web1 上安装 Nginx<br>3.1.2 给 web1 制定网页<br>3.1.3 启动 Nginx 并将它设置为开机自启<br>3.2 在 web2 上搭建网站服务<br>3.2.1 在 web2 上安装 Apache<br>3.2.2 给 web2 制定网页<br>3.2.3 启动 Apache 并将它设置为开机自启</h4>



<h4>步骤四：搭建代理服务<br>4.1 安装 Nginx<br>4.2 修改 Nginx 配置文件<br>4.3 启动 Nginx 并将它设置为开机自启</h4>



<h4>步骤五：搭建高可用服务<br>5.1 安装 Keepalived<br>5.2 创建 Keepalived 检查脚本<br>5.3 修改 proxy1 上的 Keepalived 配置文件<br>5.4 修改 proxy2 上的 Keepalived 配置文件<br>5.5 启动 Keepalived 并将它设置为开机自启</h4>



<h4>步骤六：测试 web 负载均衡加高可用<br>6.1 正常情况下测试网站服务<br>6.2 在单节点故障的情况下测试网站服务<br>6.2.1 关闭 proxy1、proxy2、web1、web2 中的任意一台服务器<br>6.2.2 测试网站服务</h4>



<h2>具体的操作步骤：</h2>



<h4>步骤一：拓扑图<br>1.1 服务器列表</h4>



<p>client enp1s0: 172.16.1.99</p>



<p>proxy1 enp1s0: 172.16.0.101<br>enp7s0: 172.16.1.101<br>virtual IP: 172.16.1.100</p>



<p>proxy2 enp1s0: 172.16.0.102<br>enp7s0: 172.16.1.102</p>



<p>web1 enp1s0: 172.16.0.11</p>



<p>web2 enp1s0: 172.16.0.12</p>



<h4>1.2 拓扑图</h4>



<pre class="wp-block-code"><code>                      proxy1                                       web1
                      enp7s0:172.16.1.101 enp1s0:172.16.0.101      enp1s0:172.16.0.11
                      virtual IP:172.16.1.100
client
enp1s0:172.16.1.99
                      proxy2                                       web2
                      enp7s0:172.16.1.102 enp1s0:172.16.0.102      enp1s0:172.16.0.12</code></pre>



<h4>1.3 拓扑图简介</h4>



<p>1) web1 安装 Nginx，web2 安装 Apache 实现网站服务<br>2) proxy1 和 proxy2 安装 Nginx 实现网站代理，轮询代理 web1、web2 上的网站服务实现负载均衡<br>3) 虚拟 IP 172.16.1.90 通过 Keepalived 默认放在 proxy1 的 enp7s0 网卡上，如果 proxy1 宕机或者检测到自己 Nginx 代理进程死掉，则虚拟 IP 172.16.1.90 则挂在 proxy2 的 enp7s0 网卡上实现高可用<br>4) 如果 web1 和 web2 中有一台服务器宕机，则 proxy1 和 proxy2 会自动不再向这台服务器请求网站服务，直到它恢复正常<br>5) 最终达到的效果是 client 向虚拟 IP 请求网站服务，此时如果 proxy1 正常就代表虚拟 IP 轮询调度 web1 和 web2 上的网站服务，再返回给 client。如果 proxy1 宕机则由 proxy2 代表虚拟 IP 完成次操作</p>



<h4>步骤二： 系统环境要求</h4>



<p>1) 所有服务器的系统都需要是 CentOS 8 版本<br>2) 所有服务器都要关闭防火墙<br>3) 所有服务器都要关闭 SELinux<br>4) 所有服务器系统都要配置好可用的软件源<br>5) 需要按照拓扑图给对应的服务器配置好 IP 地址和主机名<br>6) client 的 enp1s0 网卡、proxy1 的 enp7s0 网卡和 proxy2 的 enp7s0 网卡要可以相互 ping 通自己和对方的 IP<br>7) proxy1 的 enp1s0 网卡、proxy2 的 enp1s0 网卡、web1 的 enp1s0 网卡和 web2 的 enp1s0 网卡要可以相互 ping 通自己和对方的 IP 地址</p>



<h4>步骤三：搭建网站服务<br>3.1 在 web1 上搭建网站服务<br>3.1.1 在 web1 上安装 Nginx</h4>



<p>（只在 web1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install nginx</code></pre>



<h4>3.1.2 给 web1 制定网页</h4>



<p>（只在 web1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># echo web1 &gt; /usr/share/nginx/html/index.html</code></pre>



<h4>3.1.3 启动 Nginx 并将它设置为开机自启</h4>



<p>（只在 web1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl enable --now nginx</code></pre>



<h4>3.2 在 web2 上搭建网站服务<br>3.2.1 在 web2 上安装 Apache</h4>



<p>（只在 web2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install httpd</code></pre>



<h4>3.2.2 给 web2 制定网页</h4>



<p>（只在 web2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># echo web2 &gt; /var/www/html/index.html</code></pre>



<h4>3.2.3 启动 Apache 并将它设置为开机自启</h4>



<p>（只在 web2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl enable --now httpd</code></pre>



<h4>步骤四：搭建代理服务<br>4.1 安装 Nginx</h4>



<p>（分别在 proxy1 和 proxy2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install nginx</code></pre>



<h4>4.2 修改 Nginx 配置文件</h4>



<p>（分别在 proxy1 和 proxy2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/nginx/nginx.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
http {
    upstream webserver {
        server 172.16.0.11:80;
        server 172.16.0.12:80;
    }
......
    server {
        listen       80;

        location / {
        proxy_pass http://webserver;/
        }
    }
......
}</code></pre>



<h4>4.3 启动 Nginx 并将它设置为开机自启</h4>



<p>（分别在 proxy1 和 proxy2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl enable --now nginx</code></pre>



<h4>步骤五：搭建高可用服务<br>5.1 安装 Keepalived</h4>



<p>（分别在 proxy1 和 proxy2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install keepalived</code></pre>



<h4>5.2 创建 Keepalived 检查脚本</h4>



<p>（分别在 proxy1 和 proxy2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /etc/keepalived/nginx_check.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash

if &#91; `ps -C nginx --no-header | wc -l` -eq 0 ];then
    systemctl stop nginx
    sleep 5
    if &#91; `ps -C nginx --no-header | wc -l` -eq 0 ];then
        systemctl stop keepalived
    fi
fi</code></pre>



<p>（补充：这里以检测 Nginx 没启动就启动 Nginx，5 秒后 Nginx 要是还没有启动就关闭 keepalived 为例）</p>



<h4>5.3 修改 proxy1 上的 Keepalived 配置文件</h4>



<p>（只在 proxy1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/keepalived/keepalived.conf</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code>! Configuration File for keepalived

global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id proxy1
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}

vrrp_script chk_nginx {
script "/etc/keepalived/nginx_check.sh"
interval 2
weight 20
}

vrrp_instance VI_1 {
    state MASTER
    interface enp7s0
    virtual_router_id 90
    priority 101
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
    chk_nginx
    }
    virtual_ipaddress {
        172.16.1.100
    }
}</code></pre>



<p>（<br>补充：<br>1) script &#8220;/etc/keepalived/nginx_check.sh&#8221; 代表使用的检测脚本是 /etc/keepalived/nginx_check.sh<br>2) interface enp7s0 代表虚拟 IP 将挂载在 enp7s0 网卡上<br>3) priority 代表修建级是 101，数字越大优先级越高<br>4) 172.16.1.100 代表虚拟 IP 是 172.16.1.100<br>）</p>



<h4>5.4 修改 proxy2 上的 Keepalived 配置文件</h4>



<p>（只在 proxy2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/keepalived/keepalived.conf</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code>! Configuration File for keepalived

global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id proxy1
   vrrp_skip_check_adv_addr
   vrrp_strict
   vrrp_garp_interval 0
   vrrp_gna_interval 0
}

vrrp_script chk_nginx {
script "/etc/keepalived/nginx_check.sh"
interval 2
weight 20
}

vrrp_instance VI_1 {
    state MASTER
    interface enp7s0
    virtual_router_id 90
    priority 99
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
    chk_nginx
    }
    virtual_ipaddress {
        172.16.1.100
    }
}</code></pre>



<p>（<br>补充：<br>1) script &#8220;/etc/keepalived/nginx_check.sh&#8221; 代表使用的检测脚本是 /etc/keepalived/nginx_check.sh<br>2) interface enp7s0 代表虚拟 IP 将挂载在 enp7s0 网卡上<br>3) priority 代表修建级是 99，数字越大优先级越高<br>4) 172.16.1.100 代表虚拟 IP 是 172.16.1.100<br>）</p>



<h4>5.5 启动 Keepalived 并将它设置为开机自启</h4>



<p>（分别在 proxy1 和 proxy2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl enable --now keepalived.service</code></pre>



<h4>步骤六：测试网站负载均衡加高可用<br>6.1 正常情况下测试网站服务</h4>



<p>（只在 client 上执行以下步骤）</p>



<pre class="wp-block-code"><code># curl 172.16.1.100</code></pre>



<p>（补充：重复以上命令会发现重复显示 web1 和 web2）</p>



<h4>6.2 在单节点故障的情况下测试网站服务<br>6.2.1 关闭 proxy1、proxy2、web1、web2 中的任意一台服务器</h4>



<p>（只在 proxy1、proxy2、web1、web2 中的任意一台服务器上执行以下步骤）</p>



<pre class="wp-block-code"><code># poweroff</code></pre>



<h4>6.2.2 测试网站服务</h4>



<p>（只在 client 上执行以下步骤）</p>



<pre class="wp-block-code"><code># curl 172.16.1.100</code></pre>



<p>（补充：重复以上命令会发现重复显示 web1 和 web2）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[实验] Redis 数据库集群 Redis 数据库的添加和删除</title>
		<link>https://eternalcenter-now.github.io/redis-cluster-node/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 03 Dec 2019 13:37:46 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[Database Load Balancing and High Availability Clusters (数据库负载均衡加高可用集群)]]></category>
		<category><![CDATA[Databases (数据库)]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[Non Relational Databases (NoSQL) (非关系型数据库)]]></category>
		<category><![CDATA[Redis]]></category>
		<category><![CDATA[Redis Load Balancing and High Availability (负载均衡加高可用)]]></category>
		<category><![CDATA[纪念 Anniversary]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=7234</guid>

					<description><![CDATA[纪念：站主于 2019 年 11 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程 注意： 在给 Redis 数据库集群添加和删除 Redis 数据库之前要先搭建 Redis 数据库集群 软件准备： 在 Redis 的官网上下载软件 Redis： https://redis.io/ 在 rubygems 的官网上下载软件 rubygems https://rubygems.org/ 正文： 步骤目录： 步骤一：规划拓扑1.1 服务器列表1.2 服务器列表简介 步骤二：系统环境要求 步骤三：所有数据库服务器安装 Redis 数据库3.1 安装 Redis 数据库的相关依赖包3.2 安装 Redis 数据库3.2.1 解压安装包3.2.2 进入安装包目录3.2.3 编译安装包3.2.4 安装软件包3.2.5 进入配置目录3.2.6 安装软件包 步骤四：将 Redis 数据库添加到别的集群4.1 修改所有服务器上的 Redis 数据库配置文件4.2 重启所有服务器上的 Redis 数据库4.2.1 关闭 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/redis-cluster-node/" class="more-link">Continue reading<span class="screen-reader-text"> "[实验] Redis 数据库集群 Redis 数据库的添加和删除"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<p class="has-text-align-left has-vivid-red-color has-text-color has-medium-font-size"><strong><strong>纪念：站主于 2019 年 11 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程</strong></strong></p>



<h2 id="注意">注意：</h2>



<p>在给 Redis 数据库集群添加和删除 Redis 数据库之前要先搭建 Redis 数据库集群</p>



<div class="wp-container-1 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/redis-cluster/">Redis 数据库集群的搭建</a></div>
</div>



<h2 id="软件准备">软件准备：</h2>



<p>在 Redis 的官网上下载软件 Redis：</p>



<p class="has-text-align-center"><a href="https://redis.io/" target="_blank" rel="noreferrer noopener">https://redis.io/</a></p>



<p>在 rubygems 的官网上下载软件 rubygems</p>



<p class="has-text-align-center"><a href="https://rubygems.org/" target="_blank" rel="noreferrer noopener">https://rubygems.org/</a></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表1-2-服务器列表简介">步骤一：规划拓扑<br>1.1 服务器列表<br>1.2 服务器列表简介</h4>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<h4 id="步骤三-所有数据库服务器安装-redis-数据库3-1-安装-redis-数据库的相关依赖包3-2-安装-redis-数据库3-2-1-解压安装包3-2-2-进入安装包目录3-2-3-编译安装包3-2-4-安装软件包3-2-5-进入配置目录3-2-6-安装软件包">步骤三：所有数据库服务器安装 Redis 数据库<br>3.1 安装 Redis 数据库的相关依赖包<br>3.2 安装 Redis 数据库<br>3.2.1 解压安装包<br>3.2.2 进入安装包目录<br>3.2.3 编译安装包<br>3.2.4 安装软件包<br>3.2.5 进入配置目录<br>3.2.6 安装软件包</h4>



<h4 id="步骤四-将-redis-数据库添加到别的集群4-1-修改所有服务器上的-redis-数据库配置文件4-2-重启所有服务器上的-redis-数据库4-2-1-关闭-redis-数据库4-2-2-开启-redis-数据库4-3-将-redis7-和-redis8-添加到现有的-redis-集群中4-3-1-显示现有集群的状况4-3-2-添加-redis7-并将其视为主数据库4-3-3-添加-redis8-并将其视为从数据库4-3-4-确认-redis7-和-redis8-已经加入到了集群中4-4-让新加入的-redis-数据库也能存储数据4-4-1-重新分配集群的存储块4-4-2-确认集群的存储块已经覆盖所有主数据库">步骤四：将 Redis 数据库添加到别的集群<br>4.1 修改所有服务器上的 Redis 数据库配置文件<br>4.2 重启所有服务器上的 Redis 数据库<br>4.2.1 关闭 Redis 数据库<br>4.2.2 开启 Redis 数据库<br>4.3 将 redis7 和 redis8 添加到现有的 Redis 集群中<br>4.3.1 显示现有集群的状况<br>4.3.2 添加 redis7 并将其视为主数据库<br>4.3.3 添加 redis8 并将其视为从数据库<br>4.3.4 确认 redis7 和 redis8 已经加入到了集群中<br>4.4 让新加入的 redis 数据库也能存储数据<br>4.4.1 重新分配集群的存储块<br>4.4.2 确认集群的存储块已经覆盖所有主数据库</h4>



<h4 id="步骤五-将部分-redis-数据库从集群中删除5-1-将存储块从要被删除的-redis-主数据库里拿走5-2-将部分-redis-数据库从集群中删除5-2-1-将作为主库的-redis-数据库从集群中删除5-2-2-将作为从库的-redis-数据库从集群中删除5-3-确认部分-redis-数据库已经从集群中删除">步骤五：将部分 Redis 数据库从集群中删除<br>5.1 将存储块从要被删除的 redis 主数据库里拿走<br>5.2 将部分 Redis 数据库从集群中删除<br>5.2.1 将作为主库的 Redis 数据库从集群中删除<br>5.2.2 将作为从库的 Redis 数据库从集群中删除<br>5.3 确认部分 Redis 数据库已经从集群中删除</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表">步骤一：规划拓扑<br>1.1 服务器列表</h4>



<p>现有的 Redis 集群<br>redis7 IP 地址:192.168.1.57 端口号：1057<br>redis8 IP 地址:192.168.1.58 端口号：1058</p>



<p>（补充：在本次实验中现有的 redis 集群管理服务器是 redis1，IP 地址是 192.168.1.57，端口号是 1057）</p>



<h4 id="1-2-服务器列表简介">1.2 服务器列表简介</h4>



<p>redis7 作为主库 redis8 作为从库加入到一个现有的 Redis 集群中</p>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<p>1) 所有服务器的系统都需要是 CentOS 7 版本<br>2) 所有服务器都要关闭防火墙<br>3) 所有服务器都要关闭 SELinux<br>4) 所有服务器系统都要配置好可用的软件源<br>5) 需要按照拓扑图给对应的服务器配置好 IP 地址和主机名<br>6) 所有服务器都要可以相互 ping 通自己和对方的 IP 地址和主机名</p>



<p>（注意：现有的 Redis 集群因为已经是创建好了的，所以不用执行以上操作）</p>



<h4 id="步骤三-所有数据库服务器安装-redis-数据库3-1-安装-redis-数据库的相关依赖包">步骤三：所有数据库服务器安装 Redis 数据库<br>3.1 安装 Redis 数据库的相关依赖包</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install gcc gcc-c++ make</code></pre>



<h4 id="3-2-安装-redis-数据库3-2-1-解压安装包">3.2 安装 Redis 数据库<br>3.2.1 解压安装包</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># tar -zxf redis-5.0.5.tar.gz</code></pre>



<p>（补充：这里要安装的 Redis 版本是 5.0.5）</p>



<h4 id="3-2-2-进入安装包目录">3.2.2 进入安装包目录</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># cd redis-5.0.5/</code></pre>



<p>（补充：这里要安装的 Redis 版本是 5.0.5）</p>



<h4 id="3-2-3-编译安装包">3.2.3 编译安装包</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># make</code></pre>



<h4 id="3-2-4-安装软件包">3.2.4 安装软件包</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># make install</code></pre>



<h4 id="3-2-5-进入配置目录">3.2.5 进入配置目录</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># cd utils/</code></pre>



<h4 id="3-2-6-安装软件包">3.2.6 安装软件包</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># ./install_server.sh
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: &#91;6379] 
Selecting default: 6379
Please select the redis config file name &#91;/etc/redis/6379.conf] 
Selected default - /etc/redis/6379.conf
Please select the redis log file name &#91;/var/log/redis_6379.log] 
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance &#91;/var/lib/redis/6379] 
Selected default - /var/lib/redis/6379
Please select the redis executable path &#91;/usr/local/bin/redis-server] 
Selected config:
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf =&gt; /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...
Installation successful!</code></pre>



<h4 id="步骤四-将-redis-数据库添加到别的集群4-1-修改所有服务器上的-redis-数据库配置文件">步骤四：将 Redis 数据库添加到别的集群<br>4.1 修改所有服务器上的 Redis 数据库配置文件</h4>



<p>（只在 redis7 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/redis/6379.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
#bind 127.0.0.1
bind 192.168.1.57
......
port 1057
......
daemonize yes
......
pidfile /var/run/redis_1057.pid
......
cluster-enabled yes
......
cluster-config-file nodes-1057.conf
......
cluster-node-timeout 5000
......</code></pre>



<p>（<br>补充：<br>1) 这里的 #bind 127.0.0.1 代表取消数据库可以被本地登录<br>2) 这里的 bind 192.168.1.57 是本机的 IP 地址<br>3) 这里的 port 1057 代表数据库使用到的端口是 1057，集群里的各个数据库端口号不能一样<br>4) 这里的 daemonize yes 代表以进程的形式启动<br>5) 这里的 pidfile /var/run/redis_1057.pid 代表使用的 PID 文件是 /var/run/redis_1057.pid，集群里的各个数据库 PID 文件不能一样<br>6) 这里的 cluster-enabled yes 代表启用集群，但是前面的 daemonize 必须也启用<br>7) 这里的 cluster-config-file nodes-1057.conf 代表使用的数据库配置文件是 nodes-1057.conf，集群里的各个数据库的配置文件不能一样<br>8) 这里的 cluster-node-timeout 5000 代表集群通信超时时间为 5000<br>）</p>



<p>（只在 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/redis/6379.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
#bind 127.0.0.1
bind 192.168.1.58
......
port 1058
......
daemonize yes
......
pidfile /var/run/redis_1058.pid
......
cluster-enabled yes
......
cluster-config-file nodes-1058.conf
......
cluster-node-timeout 5000
......</code></pre>



<p>（<br>补充：<br>1) 这里的 #bind 127.0.0.1 代表取消数据库可以被本地登录<br>2) 这里的 bind 192.168.1.58 是本机的 IP 地址<br>3) 这里的 port 1058 代表数据库使用到的端口是 1058，集群里的各个数据库端口号不能一样<br>4) 这里的 daemonize yes 代表以进程的形式启动<br>5) 这里的 pidfile /var/run/redis_1058.pid 代表使用的 PID 文件是 /var/run/redis_1058.pid，集群里的各个数据库 PID 文件不能一样<br>6) 这里的 cluster-enabled yes 代表启用集群，但是前面的 daemonize 必须也启用<br>7) 这里的 cluster-config-file nodes-1058.conf 代表使用的数据库配置文件是 nodes-1058.conf，集群里的各个数据库的配置文件不能一样<br>8) 这里的 cluster-node-timeout 5000 代表集群通信超时时间为 5000<br>）</p>



<h4 id="4-2-重启所有服务器上的-redis-数据库4-2-1-关闭-redis-数据库">4.2 重启所有服务器上的 Redis 数据库<br>4.2.1 关闭 Redis 数据库</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli shutdown</code></pre>



<h4 id="4-2-2-开启-redis-数据库">4.2.2 开启 Redis 数据库</h4>



<p>（分别在 redis7 和 redis8 上执行以下步骤）</p>



<pre class="wp-block-code"><code># /etc/init.d/redis_6379 start</code></pre>



<h4 id="4-3-将-redis7-和-redis8-添加到现有的-redis-集群中4-3-1-显示现有集群的状况">4.3 将 redis7 和 redis8 添加到现有的 Redis 集群中<br>4.3.1 显示现有集群的状况</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster check 192.168.1.51:1051</code></pre>



<h4 id="4-3-2-添加-redis7-并将其视为主数据库">4.3.2 添加 redis7 并将其视为主数据库</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster add-node 192.168.1.57:1057 192.168.1.51:1051</code></pre>



<h4 id="4-3-3-添加-redis8-并将其视为从数据库">4.3.3 添加 redis8 并将其视为从数据库</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster add-node 192.168.1.58:1058 192.168.1.51:1051 --cluster-slave</code></pre>



<h4 id="4-3-4-确认-redis7-和-redis8-已经加入到了集群中">4.3.4 确认 redis7 和 redis8 已经加入到了集群中</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster check 192.168.1.51:1051
192.168.1.51:1051 (5d030ec0...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.1.53:1053 (c4f884e7...) -&gt; 2 keys | 5461 slots | 1 slaves.
192.168.1.52:1052 (7477c04d...) -&gt; 1 keys | 5462 slots | 1 slaves.
192.168.1.57:1057 (10bb6a57...) -&gt; 0 keys | 0 slots | 1 slaves.
&#91;OK] 4 keys in 4 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.1.51:1051)
M: 5d030ec05f9de86ebeedc1b035b2122addaa61d8 192.168.1.51:1051
   slots:&#91;0-5460] (5461 slots) master
   1 additional replica(s)
S: eac6a0586ad00375bea9aa352951c784be57e9ad 192.168.1.55:1055
   slots: (0 slots) slave
   replicates 5d030ec05f9de86ebeedc1b035b2122addaa61d8
S: 93d8988475c754a3b58d5172522163664c391da2 192.168.1.58:1058
   slots: (0 slots) slave
   replicates 10bb6a5732f629ee62801417cb44ddb670e99e86
S: a5cddda6c1bc7c6d3397e17e1ba29571bb7a1657 192.168.1.54:1054
   slots: (0 slots) slave
   replicates c4f884e7e4ce6adb4f5bc4f6eb398680beb26089
M: c4f884e7e4ce6adb4f5bc4f6eb398680beb26089 192.168.1.53:1053
   slots:&#91;10923-16383] (5461 slots) master
   1 additional replica(s)
M: 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30 192.168.1.52:1052
   slots:&#91;5461-10922] (5462 slots) master
   1 additional replica(s)
M: 10bb6a5732f629ee62801417cb44ddb670e99e86 192.168.1.57:1057
   slots: (0 slots) master
   1 additional replica(s)
S: fd973bbcc376bfccf5888ba06dba97feb9ef1273 192.168.1.56:1056
   slots: (0 slots) slave
   replicates 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30
&#91;OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
&#91;OK] All 16384 slots covered.</code></pre>



<h4 id="4-4-让新加入的-redis-数据库也能存储数据4-4-1-重新分配集群的存储块">4.4 让新加入的 redis 数据库也能存储数据<br>4.4.1 重新分配集群的存储块</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster reshard 192.168.1.51:1051
......
How many slots do you want to move (from 1 to 16384)? 4096
What is the receiving node ID? 10bb6a5732f629ee62801417cb44ddb670e99e86
......
Source node #1: all
......
Do you want to proceed with the proposed reshard plan (yes/no)? yes
......</code></pre>



<h4 id="4-4-2-确认集群的存储块已经覆盖所有主数据库">4.4.2 确认集群的存储块已经覆盖所有主数据库</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster check 192.168.1.51:1051
192.168.1.51:1051 (5d030ec0...) -&gt; 0 keys | 4096 slots | 1 slaves.
192.168.1.53:1053 (c4f884e7...) -&gt; 1 keys | 4096 slots | 1 slaves.
192.168.1.52:1052 (7477c04d...) -&gt; 1 keys | 4096 slots | 1 slaves.
192.168.1.57:1057 (10bb6a57...) -&gt; 2 keys | 4096 slots | 1 slaves.
&#91;OK] 4 keys in 4 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.1.51:1051)
M: 5d030ec05f9de86ebeedc1b035b2122addaa61d8 192.168.1.51:1051
   slots:&#91;1365-5460] (4096 slots) master
   1 additional replica(s)
S: eac6a0586ad00375bea9aa352951c784be57e9ad 192.168.1.55:1055
   slots: (0 slots) slave
   replicates 5d030ec05f9de86ebeedc1b035b2122addaa61d8
S: 93d8988475c754a3b58d5172522163664c391da2 192.168.1.58:1058
   slots: (0 slots) slave
   replicates 10bb6a5732f629ee62801417cb44ddb670e99e86
S: a5cddda6c1bc7c6d3397e17e1ba29571bb7a1657 192.168.1.54:1054
   slots: (0 slots) slave
   replicates c4f884e7e4ce6adb4f5bc4f6eb398680beb26089
M: c4f884e7e4ce6adb4f5bc4f6eb398680beb26089 192.168.1.53:1053
   slots:&#91;12288-16383] (4096 slots) master
   1 additional replica(s)
M: 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30 192.168.1.52:1052
   slots:&#91;6827-10922] (4096 slots) master
   1 additional replica(s)
M: 10bb6a5732f629ee62801417cb44ddb670e99e86 192.168.1.57:1057
   slots:&#91;0-1364],&#91;5461-6826],&#91;10923-12287] (4096 slots) master
   1 additional replica(s)
S: fd973bbcc376bfccf5888ba06dba97feb9ef1273 192.168.1.56:1056
   slots: (0 slots) slave
   replicates 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30
&#91;OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
&#91;OK] All 16384 slots covered.</code></pre>



<h4 id="步骤五-将部分-redis-数据库从集群中删除">步骤五：将部分 Redis 数据库从集群中删除</h4>



<p>（这里以删除 redis7 和 redis8 为例）</p>



<h4 id="5-1-将存储块从要被删除的-redis-主数据库里拿走">5.1 将存储块从要被删除的 redis 主数据库里拿走</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster reshard 192.168.1.51:1051
......
How many slots do you want to move (from 1 to 16384)? 4096
What is the receiving node ID? 5d030ec05f9de86ebeedc1b035b2122addaa61d8
......
Source node #1: 10bb6a5732f629ee62801417cb44ddb670e99e86
Source node #2: done
......
Do you want to proceed with the proposed reshard plan (yes/no)? yes
......</code></pre>



<h4 id="5-2-将部分-redis-数据库从集群中删除5-2-1-将作为主库的-redis-数据库从集群中删除">5.2 将部分 Redis 数据库从集群中删除<br>5.2.1 将作为主库的 Redis 数据库从集群中删除</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster del-node 192.168.1.57:1057 10bb6a5732f629ee62801417cb44ddb670e99e86
&gt;&gt;&gt; Removing node 10bb6a5732f629ee62801417cb44ddb670e99e86 from cluster 192.168.1.57:1057
&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</code></pre>



<h4 id="5-2-2-将作为从库的-redis-数据库从集群中删除">5.2.2 将作为从库的 Redis 数据库从集群中删除</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster del-node 192.168.1.58:1058 023abbc600cd4fb1ca8bb7ce8c45099e186041f8
&gt;&gt;&gt; Removing node 023abbc600cd4fb1ca8bb7ce8c45099e186041f8 from cluster 192.168.1.58:1058
&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...
&gt;&gt;&gt; SHUTDOWN the node.</code></pre>



<h4 id="5-3-确认部分-redis-数据库已经从集群中删除">5.3 确认部分 Redis 数据库已经从集群中删除</h4>



<pre class="wp-block-code"><code># redis-cli --cluster check 192.168.1.51:1051
192.168.1.51:1051 (5d030ec0...) -&gt; 0 keys | 4096 slots | 1 slaves.
192.168.1.53:1053 (c4f884e7...) -&gt; 1 keys | 4096 slots | 1 slaves.
192.168.1.52:1052 (7477c04d...) -&gt; 1 keys | 4096 slots | 1 slaves.
&#91;OK] 4 keys in 3 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.1.51:1051)
M: 5d030ec05f9de86ebeedc1b035b2122addaa61d8 192.168.1.51:1051
   slots:&#91;0-6826],&#91;10923-12287] (4096 slots) master
   1 additional replica(s)
S: eac6a0586ad00375bea9aa352951c784be57e9ad 192.168.1.55:1055
   slots: (0 slots) slave
   replicates 5d030ec05f9de86ebeedc1b035b2122addaa61d8
   replicates 10bb6a5732f629ee62801417cb44ddb670e99e86
S: a5cddda6c1bc7c6d3397e17e1ba29571bb7a1657 192.168.1.54:1054
   slots: (0 slots) slave
   replicates c4f884e7e4ce6adb4f5bc4f6eb398680beb26089
M: c4f884e7e4ce6adb4f5bc4f6eb398680beb26089 192.168.1.53:1053
   slots:&#91;12288-16383] (4096 slots) master
   1 additional replica(s)
M: 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30 192.168.1.52:1052
   slots:&#91;6827-10922] (4096 slots) master
   1 additional replica(s)
S: fd973bbcc376bfccf5888ba06dba97feb9ef1273 192.168.1.56:1056
   slots: (0 slots) slave
   replicates 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30
&#91;OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
&#91;OK] All 16384 slots covered.</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[实验] Redis 数据库集群的搭建</title>
		<link>https://eternalcenter-now.github.io/redis-cluster/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 27 Nov 2019 14:55:52 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[Databases (数据库)]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[Non Relational Databases (NoSQL) (非关系型数据库)]]></category>
		<category><![CDATA[Redis]]></category>
		<category><![CDATA[Redis Load Balancing and High Availability (负载均衡加高可用)]]></category>
		<category><![CDATA[纪念 Anniversary]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=6867</guid>

					<description><![CDATA[纪念：站主于 2019 年 11 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程 软件准备： 在 Redis 的官网上下载软件 Redis： https://redis.io/ 在 rubygems 的官网上下载软件 rubygems https://rubygems.org/ 正文： 步骤目录： 步骤一：规划拓扑1.1 服务器列表1.2 服务器列表简介 步骤二：系统环境要求 步骤三：所有数据库服务器安装 Redis 数据库3.1 安装 Redis 数据库的相关依赖包3.2 安装 Redis 数据库3.2.1 解压安装包3.2.2 进入安装包目录3.2.3 编译安装包3.2.4 安装软件包3.2.5 进入配置目录3.2.6 配置软件包 步骤四：搭建 Redis 数据库集群4.1 修改所有服务器上的 Redis 数据库配置文件4.2 重启所有服务器上的 Redis 数据库4.2.1 关闭 Redis 数据库4.2.2 开启 Redis 数据库4.3 显示目前的集群信息4.3.1 进入数据库4.3.2 显示数据库是否可用4.3.3 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/redis-cluster/" class="more-link">Continue reading<span class="screen-reader-text"> "[实验] Redis 数据库集群的搭建"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<p class="has-vivid-red-color has-text-color has-medium-font-size"><strong>纪念：站主于 2019 年 11 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程</strong></p>



<h2 id="软件准备">软件准备：</h2>



<p>在 Redis 的官网上下载软件 Redis：</p>



<p class="has-text-align-center"><a rel="noreferrer noopener" href="https://redis.io/" target="_blank">https://redis.io/</a></p>



<p>在 rubygems 的官网上下载软件 rubygems</p>



<p class="has-text-align-center"><a href="https://rubygems.org/" target="_blank" rel="noreferrer noopener">https://rubygems.org/</a></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表1-2-服务器列表简介">步骤一：规划拓扑<br>1.1 服务器列表<br>1.2 服务器列表简介</h4>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<h4 id="步骤三-所有数据库服务器安装-redis-数据库3-1-安装-redis-数据库的相关依赖包3-2-安装-redis-数据库3-2-1-解压安装包3-2-2-进入安装包目录3-2-3-编译安装包3-2-4-安装软件包3-2-5-进入配置目录3-2-6-配置软件包">步骤三：所有数据库服务器安装 Redis 数据库<br>3.1 安装 Redis 数据库的相关依赖包<br>3.2 安装 Redis 数据库<br>3.2.1 解压安装包<br>3.2.2 进入安装包目录<br>3.2.3 编译安装包<br>3.2.4 安装软件包<br>3.2.5 进入配置目录<br>3.2.6 配置软件包</h4>



<h4 id="步骤四-搭建-redis-数据库集群4-1-修改所有服务器上的-redis-数据库配置文件4-2-重启所有服务器上的-redis-数据库4-2-1-关闭-redis-数据库4-2-2-开启-redis-数据库4-3-显示目前的集群信息4-3-1-进入数据库4-3-2-显示数据库是否可用4-3-3-显示集群信息4-4-部署-redis-集群环境4-4-1-部署-ruby-脚本运行环境4-4-1-1-安装-ruby4-4-1-2-升级-ruby4-4-1-2-1-解压-ruby-安装包4-4-1-2-2-进入-ruby-安装包目录4-4-1-2-3-升级-ruby4-4-1-3-安装-redis-模块4-4-2-部署-redis-集群文件4-4-2-1-创建-redis-集群文件的目录4-4-2-2-复制-redis-集群文件4-4-2-3-给-redis-集群文件添加执行权限4-5-创建-redis-集群4-6-显示集群中主机状态信息的方法4-6-1-方法一4-6-1-1-进入数据库4-6-1-2-显示集群整体信息4-6-1-3-显示集群主从关系4-6-1-4-退出数据库4-6-2-方法二4-6-2-1-显示集群整体信息4-6-2-2-显示集群主从关系">步骤四：搭建 Redis 数据库集群<br>4.1 修改所有服务器上的 Redis 数据库配置文件<br>4.2 重启所有服务器上的 Redis 数据库<br>4.2.1 关闭 Redis 数据库<br>4.2.2 开启 Redis 数据库<br>4.3 显示目前的集群信息<br>4.3.1 进入数据库<br>4.3.2 显示数据库是否可用<br>4.3.3 显示集群信息<br>4.4 部署 Redis 集群环境<br>4.4.1 部署 ruby 脚本运行环境<br>4.4.1.1 安装 ruby<br>4.4.1.2 升级 ruby<br>4.4.1.2.1 解压 ruby 安装包<br>4.4.1.2.2 进入 ruby 安装包目录<br>4.4.1.2.3 升级 ruby<br>4.4.1.3 安装 Redis 模块<br>4.4.2 部署 Redis 集群文件<br>4.4.2.1 创建 Redis 集群文件的目录<br>4.4.2.2 复制 Redis 集群文件<br>4.4.2.3 给 Redis 集群文件添加执行权限<br>4.5 创建 Redis 集群<br>4.6 显示集群中主机状态信息的方法<br>4.6.1 方法一<br>4.6.1.1 进入数据库<br>4.6.1.2 显示集群整体信息<br>4.6.1.3 显示集群主从关系<br>4.6.1.4 退出数据库<br>4.6.2 方法二<br>4.6.2.1 显示集群整体信息<br>4.6.2.2 显示集群主从关系</h4>



<h4 id="步骤五-redis-集群创建失败的解决办法5-1-关闭所有-redis服务器的-redis-服务5-2-删除所有原来的-redis-数据5-3-重启-redis-数据库5-4-按照前面的步骤重新执行创建集群">步骤五：Redis 集群创建失败的解决办法<br>5.1 关闭所有 Redis服务器的 Redis 服务<br>5.2 删除所有原来的 Redis 数据<br>5.3 重启 Redis 数据库<br>5.4 按照前面的步骤重新执行创建集群</h4>



<h4 id="步骤六-测试-redis-集群6-1-数据同步测试6-1-1-进入数据库6-1-2-确认现在的-redis-数据库都是空的6-1-3-在主-redis-数据库上插入数据6-1-4-查看刚插入的数据6-2-高可用测试6-2-1-模拟此时主库宕机后-对应的从库会自动升级为主库但需要-5-分钟的时间6-2-2-等待-5-分钟后显示集群主从关系6-2-3-主库恢复后会成为新主库的从库6-2-4-再次显示集群主从关系">步骤六：测试 Redis 集群<br>6.1 数据同步测试<br>6.1.1 进入数据库<br>6.1.2 确认现在的 Redis 数据库都是空的<br>6.1.3 在主 Redis 数据库上插入数据<br>6.1.4 查看刚插入的数据<br>6.2 高可用测试<br>6.2.1 模拟此时主库宕机后，对应的从库会自动升级为主库但需要 5 分钟的时间<br>6.2.2 等待 5 分钟后显示集群主从关系<br>6.2.3 主库恢复后会成为新主库的从库<br>6.2.4 再次显示集群主从关系</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表">步骤一：规划拓扑<br>1.1 服务器列表</h4>



<p>redis1 IP 地址:192.168.1.51 端口号：1051<br>redis2 IP 地址:192.168.1.52 端口号：1052<br>redis3 IP 地址:192.168.1.53 端口号：1053<br>redis4 IP 地址:192.168.1.54 端口号：1054<br>redis5 IP 地址:192.168.1.55 端口号：1055<br>redis6 IP 地址:192.168.1.56 端口号：1056</p>



<h4 id="1-2-服务器列表简介">1.2 服务器列表简介</h4>



<p>1) 总共 6 个数据库，3 个为主库，3 个为从库<br>2) 如果 1 个主库宕掉则它的从库自动成为主库<br>3) 宕掉的主库修复好后会成为新主库的从库<br>4) 如果半数或者半数以上的主库宕掉，集群则无法使用</p>



<p>（注意： Redis 集群最少要有 3 个主库）</p>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<p>1) 所有服务器的系统都需要是 CentOS 7 版本<br>2) 所有服务器都要关闭防火墙<br>3) 所有服务器都要关闭 SELinux<br>4) 所有服务器系统都要配置好可用的软件源<br>5) 需要按照拓扑图给对应的服务器配置好 IP 地址和主机名<br>6) 所有服务器都要可以相互 ping 通自己和对方的 IP 地址和主机名<br>7) 至少要有一台服务器可以访问外网</p>



<h4 id="步骤三-所有数据库服务器安装-redis-数据库3-1-安装-redis-数据库的相关依赖包">步骤三：所有数据库服务器安装 Redis 数据库<br>3.1 安装 Redis 数据库的相关依赖包</h4>



<p>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install gcc gcc-c++ make</code></pre>



<h4 id="3-2-安装-redis-数据库3-2-1-解压安装包">3.2 安装 Redis 数据库<br>3.2.1 解压安装包</h4>



<p>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># tar -zxf redis-5.0.5.tar.gz</code></pre>



<p>（补充：这里要安装的 Redis 版本是 5.0.5）</p>



<h4 id="3-2-2-进入安装包目录">3.2.2 进入安装包目录</h4>



<p>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># cd redis-5.0.5/</code></pre>



<p>（补充：这里要安装的 Redis 版本是 5.0.5）</p>



<h4 id="3-2-3-编译安装包">3.2.3 编译安装包</h4>



<p>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># make</code></pre>



<h4 id="3-2-4-安装软件包">3.2.4 安装软件包</h4>



<pre class="wp-block-code"><code>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</code></pre>



<pre class="wp-block-code"><code># make install</code></pre>



<h4 id="3-2-5-进入配置目录">3.2.5 进入配置目录</h4>



<pre class="wp-block-code"><code>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</code></pre>



<pre class="wp-block-code"><code># cd utils/</code></pre>



<h4 id="3-2-6-配置软件包">3.2.6 配置软件包</h4>



<p>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># ./install_server.sh
Welcome to the redis service installer
This script will help you easily set up a running redis server
Please select the redis port for this instance: &#91;6379] 
Selecting default: 6379
Please select the redis config file name &#91;/etc/redis/6379.conf] 
Selected default - /etc/redis/6379.conf
Please select the redis log file name &#91;/var/log/redis_6379.log] 
Selected default - /var/log/redis_6379.log
Please select the data directory for this instance &#91;/var/lib/redis/6379] 
Selected default - /var/lib/redis/6379
Please select the redis executable path &#91;/usr/local/bin/redis-server] 
Selected config:
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /var/log/redis_6379.log
Data dir       : /var/lib/redis/6379
Executable     : /usr/local/bin/redis-server
Cli Executable : /usr/local/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf =&gt; /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...
Installation successful!</code></pre>



<h4 id="步骤四-搭建-redis-数据库集群4-1-修改所有服务器上的-redis-数据库配置文件">步骤四：搭建 Redis 数据库集群<br>4.1 修改所有服务器上的 Redis 数据库配置文件</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/redis/6379.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
#bind 127.0.0.1
bind 192.168.1.51
......
port 1051
......
daemonize yes
......
pidfile /var/run/redis_1051.pid
......
cluster-enabled yes
......
cluster-config-file nodes-1051.conf
......
cluster-node-timeout 5000
......</code></pre>



<p>（<br>补充：<br>1) 这里的 #bind 127.0.0.1 代表取消数据库可以被本地登录<br>2) 这里的 bind 192.168.1.51 是本机的 IP 地址<br>3) 这里的 port 1051 代表数据库使用到的端口是 1051，集群里的各个数据库端口号不能一样<br>4) 这里的 daemonize yes 代表以进程的形式启动<br>5) 这里的 pidfile /var/run/redis_1051.pid 代表使用的 PID 文件是 /var/run/redis_1051.pid，集群里的各个数据库 PID 文件不能一样<br>6) 这里的 cluster-enabled yes 代表启用集群，但是前面的 daemonize 必须也启用<br>7) 这里的 cluster-config-file nodes-1051.conf 代表使用的数据库配置文件是 nodes-1051.conf，集群里的各个数据库的配置文件不能一样<br>8) 这里的 cluster-node-timeout 5000 代表集群通信超时时间为 5000<br>）</p>



<p>（只在 redis2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/redis/6379.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
#bind 127.0.0.1
bind 192.168.1.52
......
port 1052
......
daemonize yes
......
pidfile /var/run/redis_1052.pid
......
cluster-enabled yes
......
cluster-config-file nodes-1052.conf
......
cluster-node-timeout 5000
......</code></pre>



<p>（<br>补充：<br>1) 这里的 #bind 127.0.0.1 代表取消数据库可以被本地登录<br>2) 这里的 bind 192.168.1.52 是本机的 IP 地址<br>3) 这里的 port 1052 代表数据库使用到的端口是 1052，集群里的各个数据库端口号不能一样<br>4) 这里的 daemonize yes 代表以进程的形式启动<br>5) 这里的 pidfile /var/run/redis_1052.pid 代表使用的 PID 文件是 /var/run/redis_1052.pid，集群里的各个数据库 PID 文件不能一样<br>6) 这里的 cluster-enabled yes 代表启用集群，但是前面的 daemonize 必须也启用<br>7) 这里的 cluster-config-file nodes-1052.conf 代表使用的数据库配置文件是 nodes-1052.conf，集群里的各个数据库的配置文件不能一样<br>8) 这里的 cluster-node-timeout 5000 代表集群通信超时时间为 5000<br>）</p>



<p>（只在 redis3 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/redis/6379.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
#bind 127.0.0.1
bind 192.168.1.53
......
port 1053
......
daemonize yes
......
pidfile /var/run/redis_1053.pid
......
cluster-enabled yes
......
cluster-config-file nodes-1053.conf
......
cluster-node-timeout 5000
......</code></pre>



<p>（<br>补充：<br>1) 这里的 #bind 127.0.0.1 代表取消数据库可以被本地登录<br>2) 这里的 bind 192.168.1.53 是本机的 IP 地址<br>3) 这里的 port 1053 代表数据库使用到的端口是 1053，集群里的各个数据库端口号不能一样<br>4) 这里的 daemonize yes 代表以进程的形式启动<br>5) 这里的 pidfile /var/run/redis_1053.pid 代表使用的 PID 文件是 /var/run/redis_1053.pid，集群里的各个数据库 PID 文件不能一样<br>6) 这里的 cluster-enabled yes 代表启用集群，但是前面的 daemonize 必须也启用<br>7) 这里的 cluster-config-file nodes-1053.conf 代表使用的数据库配置文件是 nodes-1053.conf，集群里的各个数据库的配置文件不能一样<br>8) 这里的 cluster-node-timeout 5000 代表集群通信超时时间为 5000<br>）</p>



<p>（只在 redis4 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/redis/6379.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
#bind 127.0.0.1
bind 192.168.1.54
......
port 1054
......
daemonize yes
......
pidfile /var/run/redis_1054.pid
......
cluster-enabled yes
......
cluster-config-file nodes-1054.conf
......
cluster-node-timeout 5000
......</code></pre>



<p>（<br>补充：<br>1) 这里的 #bind 127.0.0.1 代表取消数据库可以被本地登录<br>2) 这里的 bind 192.168.1.54 是本机的 IP 地址<br>3) 这里的 port 1054 代表数据库使用到的端口是 1054，集群里的各个数据库端口号不能一样<br>4) 这里的 daemonize yes 代表以进程的形式启动<br>5) 这里的 pidfile /var/run/redis_1054.pid 代表使用的 PID 文件是 /var/run/redis_1054.pid，集群里的各个数据库 PID 文件不能一样<br>6) 这里的 cluster-enabled yes 代表启用集群，但是前面的 daemonize 必须也启用<br>7) 这里的 cluster-config-file nodes-1054.conf 代表使用的数据库配置文件是 nodes-1054.conf，集群里的各个数据库的配置文件不能一样<br>8) 这里的 cluster-node-timeout 5000 代表集群通信超时时间为 5000<br>）</p>



<p>（只在 redis5 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/redis/6379.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
#bind 127.0.0.1
bind 192.168.1.55
......
port 1055
......
daemonize yes
......
pidfile /var/run/redis_1055.pid
......
cluster-enabled yes
......
cluster-config-file nodes-1055.conf
......
cluster-node-timeout 5000
......</code></pre>



<p>（<br>补充：<br>1) 这里的 #bind 127.0.0.1 代表取消数据库可以被本地登录<br>2) 这里的 bind 192.168.1.55 是本机的 IP 地址<br>3) 这里的 port 1055 代表数据库使用到的端口是 1055，集群里的各个数据库端口号不能一样<br>4) 这里的 daemonize yes 代表以进程的形式启动<br>5) 这里的 pidfile /var/run/redis_1055.pid 代表使用的 PID 文件是 /var/run/redis_1055.pid，集群里的各个数据库 PID 文件不能一样<br>6) 这里的 cluster-enabled yes 代表启用集群，但是前面的 daemonize 必须也启用<br>7) 这里的 cluster-config-file nodes-1055.conf 代表使用的数据库配置文件是 nodes-1055.conf，集群里的各个数据库的配置文件不能一样<br>8) 这里的 cluster-node-timeout 5000 代表集群通信超时时间为 5000<br>）</p>



<p>（只在 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/redis/6379.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
#bind 127.0.0.1
bind 192.168.1.56
......
port 1056
......
daemonize yes
......
pidfile /var/run/redis_1056.pid
......
cluster-enabled yes
......
cluster-config-file nodes-1056.conf
......
cluster-node-timeout 5000
......</code></pre>



<p>（<br>补充：<br>1) 这里的 #bind 127.0.0.1 代表取消数据库可以被本地登录<br>2) 这里的 bind 192.168.1.56 是本机的 IP 地址<br>3) 这里的 port 1056 代表数据库使用到的端口是 1056，集群里的各个数据库端口号不能一样<br>4) 这里的 daemonize yes 代表以进程的形式启动<br>5) 这里的 pidfile /var/run/redis_1056.pid 代表使用的 PID 文件是 /var/run/redis_1056.pid，集群里的各个数据库 PID 文件不能一样<br>6) 这里的 cluster-enabled yes 代表启用集群，但是前面的 daemonize 必须也启用<br>7) 这里的 cluster-config-file nodes-1056.conf 代表使用的数据库配置文件是 nodes-1056.conf，集群里的各个数据库的配置文件不能一样<br>8) 这里的 cluster-node-timeout 5000 代表集群通信超时时间为 5000<br>）</p>



<h4 id="4-2-重启所有服务器上的-redis-数据库4-2-1-关闭-redis-数据库">4.2 重启所有服务器上的 Redis 数据库<br>4.2.1 关闭 Redis 数据库</h4>



<p>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli shutdown</code></pre>



<h4 id="4-2-2-开启-redis-数据库">4.2.2 开启 Redis 数据库</h4>



<p>（分别在 redis1、redis2、redis3、redis4、redis5 和 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># /etc/init.d/redis_6379 start</code></pre>



<h4 id="4-3-显示目前的集群信息">4.3 显示目前的集群信息</h4>



<p>（此步骤可以在任意服务器上操作，这里以在 redis1 上操作为例）</p>



<h4 id="4-3-1-进入数据库">4.3.1 进入数据库</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h 192.168.1.51 -p 1051</code></pre>



<h4 id="4-3-2-显示数据库是否可用">4.3.2 显示数据库是否可用</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1051&gt; ping
PONG</code></pre>



<h4 id="4-3-3-显示集群信息">4.3.3 显示集群信息</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1051&gt; cluster info
cluster_state:fail
cluster_slots_assigned:0
cluster_slots_ok:0
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:1
cluster_size:0
cluster_current_epoch:0
cluster_my_epoch:0
cluster_stats_messages_sent:0
cluster_stats_messages_received:0</code></pre>



<h4 id="4-4-部署-redis-集群环境4-4-1-部署-ruby-脚本运行环境">4.4 部署 Redis 集群环境<br>4.4.1 部署 ruby 脚本运行环境</h4>



<p>（此步骤可以在任意服务器上操作，但是这台服务器必须要可以访问外网，这里以在 redisA 上操作为例）</p>



<h4 id="4-4-1-1-安装-ruby">4.4.1.1 安装 ruby</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install ruby rubygems ruby-devel</code></pre>



<h4 id="4-4-1-2-升级-ruby4-4-1-2-1-解压-ruby-安装包">4.4.1.2 升级 ruby<br>4.4.1.2.1 解压 ruby 安装包</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># tar -xvf rubygems-3.0.6.tgz </code></pre>



<p>（补充：这里要安装的 rubygems 版本是 3.0.6）</p>



<h4 id="4-4-1-2-2-进入-ruby-安装包目录">4.4.1.2.2 进入 ruby 安装包目录</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># cd rubygems-3.0.6</code></pre>



<p>（补充：这里要安装的 rubygems 版本是 3.0.6）</p>



<h4 id="4-4-1-2-3-升级-ruby">4.4.1.2.3 升级 ruby</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># ruby setup.rb</code></pre>



<h4 id="4-4-1-3-安装-redis-模块">4.4.1.3 安装 Redis 模块</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># gem install redis -v 3.3.5
Fetching: redis-3.3.5.gem (100%)
Successfully installed redis-3.3.5
Parsing documentation for redis-3.3.5
Installing ri documentation for redis-3.3.5
1 gem installed</code></pre>



<h4 id="4-4-2-部署-redis-集群文件4-4-2-1-创建-redis-集群文件的目录">4.4.2 部署 Redis 集群文件<br>4.4.2.1 创建 Redis 集群文件的目录</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># mkdir /root/bin</code></pre>



<h4 id="4-4-2-2-复制-redis-集群文件">4.4.2.2 复制 Redis 集群文件</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># cp redis-5.0.5/src/redis-trib.rb /root/bin</code></pre>



<h4 id="4-4-2-3-给-redis-集群文件添加执行权限">4.4.2.3 给 Redis 集群文件添加执行权限</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod +x /root/bin/redis-trib.rb</code></pre>



<h4 id="4-5-创建-redis-集群">4.5 创建 Redis 集群</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster create 192.168.1.51:1051 192.168.1.52:1052 192.168.1.53:1053 192.168.1.54:1054 192.168.1.55:1055 192.168.1.56:1056 --cluster-replicas 1
&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...
Master&#91;0] -&gt; Slots 0 - 5460
Master&#91;1] -&gt; Slots 5461 - 10922
Master&#91;2] -&gt; Slots 10923 - 16383
Adding replica 192.168.1.55:1055 to 192.168.1.51:1051
Adding replica 192.168.1.56:1056 to 192.168.1.52:1052
Adding replica 192.168.1.54:1054 to 192.168.1.53:1053
M: 5d030ec05f9de86ebeedc1b035b2122addaa61d8 192.168.1.51:1051
   slots:&#91;0-5460] (5461 slots) master
M: 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30 192.168.1.52:1052
   slots:&#91;5461-10922] (5462 slots) master
M: c4f884e7e4ce6adb4f5bc4f6eb398680beb26089 192.168.1.53:1053
   slots:&#91;10923-16383] (5461 slots) master
S: a5cddda6c1bc7c6d3397e17e1ba29571bb7a1657 192.168.1.54:1054
   replicates c4f884e7e4ce6adb4f5bc4f6eb398680beb26089
S: eac6a0586ad00375bea9aa352951c784be57e9ad 192.168.1.55:1055
   replicates 5d030ec05f9de86ebeedc1b035b2122addaa61d8
S: fd973bbcc376bfccf5888ba06dba97feb9ef1273 192.168.1.56:1056
   replicates 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30
Can I set the above configuration? (type 'yes' to accept): yes
&gt;&gt;&gt; Nodes configuration updated
&gt;&gt;&gt; Assign a different config epoch to each node
&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join
...
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.1.51:1051)
M: 5d030ec05f9de86ebeedc1b035b2122addaa61d8 192.168.1.51:1051
   slots:&#91;0-5460] (5461 slots) master
   1 additional replica(s)
S: eac6a0586ad00375bea9aa352951c784be57e9ad 192.168.1.55:1055
   slots: (0 slots) slave
   replicates 5d030ec05f9de86ebeedc1b035b2122addaa61d8
M: c4f884e7e4ce6adb4f5bc4f6eb398680beb26089 192.168.1.53:1053
   slots:&#91;10923-16383] (5461 slots) master
   1 additional replica(s)
M: 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30 192.168.1.52:1052
   slots:&#91;5461-10922] (5462 slots) master
   1 additional replica(s)
S: fd973bbcc376bfccf5888ba06dba97feb9ef1273 192.168.1.56:1056
   slots: (0 slots) slave
   replicates 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30
S: a5cddda6c1bc7c6d3397e17e1ba29571bb7a1657 192.168.1.54:1054
   slots: (0 slots) slave
   replicates c4f884e7e4ce6adb4f5bc4f6eb398680beb26089
&#91;OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
&#91;OK] All 16384 slots covered.</code></pre>



<h4 id="4-6-显示集群中主机状态信息的方法4-6-1-方法一4-6-1-1-进入数据库">4.6 显示集群中主机状态信息的方法<br>4.6.1 方法一<br>4.6.1.1 进入数据库</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h 192.168.1.51 -p 1051</code></pre>



<h4 id="4-6-1-2-显示集群整体信息">4.6.1.2 显示集群整体信息</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1051&gt; cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:30858
cluster_stats_messages_pong_sent:29942
cluster_stats_messages_sent:60800
cluster_stats_messages_ping_received:29937
cluster_stats_messages_pong_received:30858
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:60800</code></pre>



<h4 id="4-6-1-3-显示集群主从关系">4.6.1.3 显示集群主从关系</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.53:1053&gt; cluster nodes
eac6a0586ad00375bea9aa352951c784be57e9ad 192.168.1.55:1055@11055 slave 5d030ec05f9de86ebeedc1b035b2122addaa61d8 0 1574754846521 5 connected
a5cddda6c1bc7c6d3397e17e1ba29571bb7a1657 192.168.1.54:1054@11054 slave c4f884e7e4ce6adb4f5bc4f6eb398680beb26089 0 1574754846000 4 connected
fd973bbcc376bfccf5888ba06dba97feb9ef1273 192.168.1.56:1056@11056 slave 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30 0 1574754845819 6 connected
5d030ec05f9de86ebeedc1b035b2122addaa61d8 192.168.1.51:1051@11051 master - 0 1574754846822 1 connected 0-5460
7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30 192.168.1.52:1052@11052 master - 0 1574754846000 2 connected 5461-10922
c4f884e7e4ce6adb4f5bc4f6eb398680beb26089 192.168.1.53:1053@11053 myself,master - 0 1574754844000 3 connected 10923-16383</code></pre>



<h4 id="4-6-1-4-退出数据库">4.6.1.4 退出数据库</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1051&gt; quit</code></pre>



<h4 id="4-6-2-方法二4-6-2-1-显示集群整体信息">4.6.2 方法二<br>4.6.2.1 显示集群整体信息</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster info 192.168.1.51 1051
192.168.1.51:1051 (5d030ec0...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.1.53:1053 (c4f884e7...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.1.52:1052 (7477c04d...) -&gt; 1 keys | 5462 slots | 1 slaves.
&#91;OK] 3 keys in 3 masters.
0.00 keys per slot on average.</code></pre>



<h4 id="4-6-2-2-显示集群主从关系">4.6.2.2 显示集群主从关系</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster check 192.168.1.51 1051
192.168.1.51:1051 (5d030ec0...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.1.53:1053 (c4f884e7...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.1.52:1052 (7477c04d...) -&gt; 1 keys | 5462 slots | 1 slaves.
&#91;OK] 3 keys in 3 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.1.51:1051)
M: 5d030ec05f9de86ebeedc1b035b2122addaa61d8 192.168.1.51:1051
   slots:&#91;0-5460] (5461 slots) master
   1 additional replica(s)
S: eac6a0586ad00375bea9aa352951c784be57e9ad 192.168.1.55:1055
   slots: (0 slots) slave
   replicates 5d030ec05f9de86ebeedc1b035b2122addaa61d8
M: c4f884e7e4ce6adb4f5bc4f6eb398680beb26089 192.168.1.53:1053
   slots:&#91;10923-16383] (5461 slots) master
   1 additional replica(s)
M: 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30 192.168.1.52:1052
   slots:&#91;5461-10922] (5462 slots) master
   1 additional replica(s)
S: fd973bbcc376bfccf5888ba06dba97feb9ef1273 192.168.1.56:1056
   slots: (0 slots) slave
   replicates 7477c04d8ebf9d498ed5586d5f4e6d513fdb3c30
S: a5cddda6c1bc7c6d3397e17e1ba29571bb7a1657 192.168.1.54:1054
   slots: (0 slots) slave
   replicates c4f884e7e4ce6adb4f5bc4f6eb398680beb26089
&#91;OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
&#91;OK] All 16384 slots covered.</code></pre>



<h4 id="步骤五-redis-集群创建失败的解决办法5-1-关闭所有-redis服务器的-redis-服务">步骤五：Redis 集群创建失败的解决办法<br>5.1 关闭所有 Redis服务器的 Redis 服务</h4>



<p>（只在加入集群失败的服务器上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h &lt;IP address of this server&gt; -p &lt;port number used by redis of this server&gt; shutdowm</code></pre>



<h4 id="5-2-删除所有原来的-redis-数据">5.2 删除所有原来的 Redis 数据</h4>



<p>（只在加入集群失败的服务器上执行以下步骤）</p>



<pre class="wp-block-code"><code># rm -rf /var/lib/redis/6379/*</code></pre>



<h4 id="5-3-重启-redis-数据库">5.3 重启 Redis 数据库</h4>



<p>（只在加入集群失败的服务器上执行以下步骤）</p>



<pre class="wp-block-code"><code># /etc/init.d/redis_6379 start</code></pre>



<h4 id="5-4-按照前面的步骤重新执行创建集群">5.4 按照前面的步骤重新执行创建集群</h4>



<p>（只在加入集群失败的服务器上执行以下步骤）</p>



<p>（步骤略）</p>



<h4 id="步骤六-测试-redis-集群6-1-数据同步测试6-1-1-进入数据库">步骤六：测试 Redis 集群<br>6.1 数据同步测试<br>6.1.1 进入数据库</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h 192.168.1.51 -p 1051</code></pre>



<p>（只在 redis2 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h 192.168.1.52 -p 1052</code></pre>



<p>（只在 redis3 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h 192.168.1.53 -p 1053</code></pre>



<p>（只在 redis4 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h 192.168.1.54 -p 1054</code></pre>



<p>（只在 redis5 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h 192.168.1.55 -p 1055</code></pre>



<p>（只在 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h 192.168.1.56 -p 1056</code></pre>



<h4 id="6-1-2-确认现在的-redis-数据库都是空的">6.1.2 确认现在的 Redis 数据库都是空的</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1051&gt; keys *</code></pre>



<p>（只在 redis2 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1052&gt; keys *</code></pre>



<p>（只在 redis3 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1053&gt; keys *</code></pre>



<p>（只在 redis4 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1054&gt; keys *</code></pre>



<p>（只在 redis5 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1055&gt; keys *</code></pre>



<p>（只在 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1056&gt; keys *</code></pre>



<h4 id="6-1-3-在主-redis-数据库上插入数据">6.1.3 在主 Redis 数据库上插入数据</h4>



<p>（补充：本次的主数据库是 redis1、redis2、redis3）</p>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1051&gt; set aa 101
-&gt; Redirected to slot &#91;15495] located at 192.168.1.53:1053
OK</code></pre>



<p>（只在 redis2 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.52:1052&gt; set bb 102
-&gt; Redirected to slot &#91;3300] located at 192.168.1.51:1051
OK</code></pre>



<p>（只在 redis3 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.53:1053&gt; set ff 103
-&gt; Redirected to slot &#91;7365] located at 192.168.1.52:1052
OK</code></pre>



<h4 id="6-1-4-查看刚插入的数据">6.1.4 查看刚插入的数据</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1051&gt; keys *
1) "aa"</code></pre>



<p>（只在 redis2 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1052&gt; keys *
1) "bb"</code></pre>



<p>（只在 redis3 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1053&gt; keys *
1) "ff"</code></pre>



<p>（只在 redis4 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1054&gt; keys *
1) "ff"</code></pre>



<p>（只在 redis5 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1055&gt; keys *
1) "aa"</code></pre>



<p>（只在 redis6 上执行以下步骤）</p>



<pre class="wp-block-code"><code>192.168.1.51:1056&gt; keys *
1) "bb"</code></pre>



<p>（<br>补充：<br>1) 对应的从库会自动同步主库的数据<br>2) 本次的主数据库是 redis1（从库是 redis5）、redis2（从库是 redis6）、redis3（从库是 redis4)<br>)</p>



<h4 id="6-2-高可用测试6-2-1-模拟此时主库宕机后-对应的从库会自动升级为主库但需要-5-分钟的时间">6.2 高可用测试<br>6.2.1 模拟此时主库宕机后，对应的从库会自动升级为主库但需要 5 分钟的时间</h4>



<p>（只在模拟宕机的主库服务器上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli -h &lt;IP address of this server&gt; -p &lt;port number used by redis of this server&gt; shutdown</code></pre>



<h4 id="6-2-2-等待-5-分钟后显示集群主从关系">6.2.2 等待 5 分钟后显示集群主从关系</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster check 192.168.1.51 1051</code></pre>



<h4 id="6-2-3-主库恢复后会成为新主库的从库">6.2.3 主库恢复后会成为新主库的从库</h4>



<p>（只在模拟宕机的主库服务器上执行以下步骤）</p>



<pre class="wp-block-code"><code># /etc/init.d/redis_6379 start</code></pre>



<h4 id="6-2-4-再次显示集群主从关系">6.2.4 再次显示集群主从关系</h4>



<p>（只在 redis1 上执行以下步骤）</p>



<pre class="wp-block-code"><code># redis-cli --cluster check 192.168.1.51 1051</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] 实现数据存储高可用的思路</title>
		<link>https://eternalcenter-now.github.io/data-ha/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 20 Sep 2019 08:32:03 +0000</pubDate>
				<category><![CDATA[Big Data (大数据)]]></category>
		<category><![CDATA[Ceph]]></category>
		<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cluster High Availability Tools (集群高可用工具)]]></category>
		<category><![CDATA[Clusters (集群)]]></category>
		<category><![CDATA[Distributed Cloud Storage Clusters (分布式云存储集群)]]></category>
		<category><![CDATA[Distributed Replicated Block Device (DRBD)]]></category>
		<category><![CDATA[DRBD + Keepalived + NFS + Shell]]></category>
		<category><![CDATA[DRBD + Pacemaker + NFS]]></category>
		<category><![CDATA[Hadoop]]></category>
		<category><![CDATA[High Availability Clusters (高可用集群)]]></category>
		<category><![CDATA[Inotifywait + Rsync]]></category>
		<category><![CDATA[Keepalived]]></category>
		<category><![CDATA[Load Balancing and High Availability Clusters (负载均衡加高可用集群)]]></category>
		<category><![CDATA[Project (项目)]]></category>
		<category><![CDATA[Project Ideas (项目思路)]]></category>
		<category><![CDATA[Storage Services Highly Availability Clusters (存储服务高可用集群)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=5832</guid>

					<description><![CDATA[方法一：以目录级数据同步工具 rsync 为核心的同步方法 通过 inotify + rsync 实现两个目录的数据实时同步特点：如果数据量太大就不合适了，数据量最好小于 10G，如果文件多最好要小于 5G 甚至小于 3G 方法二：以硬盘级数据同步工具 drbd 为核心的同步方法 drbd + heartbeat 或者 drbd + keepalive + shell 实现两个数据存储节点的主从同步、主从切换特点：最好用于小于 300G 的数据同步 方法三：分布式云存储 通过 hdfs 或者 ceph 实现分布式云存储特点：可以用于大于 300G 的数据同步]]></description>
										<content:encoded><![CDATA[
<h4>方法一：以目录级数据同步工具 rsync 为核心的同步方法</h4>



<p>通过 inotify + rsync 实现两个目录的数据实时同步<br>特点：如果数据量太大就不合适了，数据量最好小于 10G，如果文件多最好要小于 5G 甚至小于 3G</p>



<h4>方法二：以硬盘级数据同步工具 drbd 为核心的同步方法</h4>



<p>drbd + heartbeat 或者 drbd + keepalive + shell 实现两个数据存储节点的主从同步、主从切换<br>特点：最好用于小于 300G 的数据同步</p>



<h4>方法三：分布式云存储</h4>



<p>通过 hdfs 或者 ceph 实现分布式云存储<br>特点：可以用于大于 300G 的数据同步</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
