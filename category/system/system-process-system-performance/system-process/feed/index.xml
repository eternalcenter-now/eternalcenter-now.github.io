<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>System Process (系统进程) &#8211; Eternal Center</title>
	<atom:link href="https://eternalcenter-now.github.io/category/system/system-process-system-performance/system-process/feed/" rel="self" type="application/rss+xml" />
	<link>https://eternalcenter-now.github.io/</link>
	<description></description>
	<lastBuildDate>Fri, 29 Apr 2022 13:43:00 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>[排错] 解决 Linux 运行时报错 “watchdog: Bug: soft lockup &#8211; CPU&#8230;&#8230;” （CPU 软锁）</title>
		<link>https://eternalcenter-now.github.io/debug-watchdog-bug-soft-lockup-cpu/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 15 Feb 2022 07:35:47 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[System Hardware (系统硬件)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Setting (系统设置)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=21928</guid>

					<description><![CDATA[报错代码： 分析： 当 CPU 的负载过高时，一个 CPU 在运行某一个进程时，在内核模式下超过 20 秒没有回应，则看门狗程序会将系统所有 CPU 软锁住，然后会让这些 CPU 显示各自正在运行的进程堆栈跟踪 缓解方法： 延长看门狗等待 CPU 内核模式下的回应时间 方法一：通过 /proc/sys/kernel/watchdog_thresh 文件提高看门狗软所 CPU 的时间 （补充：这里以将看门狗的值提高到为 20 为例，也可以根据自己的需求提高更多，默认值为 10） 方法二：通过新建文件提高看门狗软所 CPU 的时间2.1 通过新建文件提高看门狗软所 CPU 的时间 （补充：这里以将看门狗的值提高到为 20 为例，也可以根据自己的需求提高更多，默认值为 10） 2.2 让新建文件立刻生效 深究方法： 开启 Kdump，等此报错再次发生时分析 Kdump 在内核崩溃时搜集信息 vmcore]]></description>
										<content:encoded><![CDATA[
<h2 id="报错代码">报错代码：</h2>



<pre class="wp-block-code"><code>watchdog: Bug: soft lockup - CPU......</code></pre>



<h2 id="分析">分析：</h2>



<p>当 CPU 的负载过高时，一个 CPU 在运行某一个进程时，在内核模式下超过 20 秒没有回应，则看门狗程序会将系统所有 CPU 软锁住，然后会让这些 CPU 显示各自正在运行的进程堆栈跟踪</p>



<h2 id="缓解方法">缓解方法：</h2>



<p>延长看门狗等待 CPU 内核模式下的回应时间</p>



<h4 id="方法一-通过-proc-sys-kernel-watchdog-thresh-文件提高看门狗软所-cpu-的时间">方法一：通过 /proc/sys/kernel/watchdog_thresh 文件提高看门狗软所 CPU 的时间</h4>



<pre class="wp-block-code"><code># echo 20 &gt; /proc/sys/kernel/watchdog_thresh</code></pre>



<p>（补充：这里以将看门狗的值提高到为 20 为例，也可以根据自己的需求提高更多，默认值为 10）</p>



<h4 id="方法二-通过新建文件提高看门狗软所-cpu-的时间2-1-通过新建文件提高看门狗软所-cpu-的时间">方法二：通过新建文件提高看门狗软所 CPU 的时间<br>2.1 通过新建文件提高看门狗软所 CPU 的时间</h4>



<pre class="wp-block-code"><code># echo "kernel.watchdog_thresh=20" &gt; /etc/sysctl.d/99-watchdog_thresh.conf</code></pre>



<p>（补充：这里以将看门狗的值提高到为 20 为例，也可以根据自己的需求提高更多，默认值为 10）</p>



<h4 id="2-2-让新建文件立刻生效">2.2 让新建文件立刻生效</h4>



<pre class="wp-block-code"><code># sysctl -p  /etc/sysctl.d/99-watchdog_thresh.conf</code></pre>



<h2 id="深究方法">深究方法：</h2>



<p>开启 Kdump，等此报错再次发生时分析 Kdump 在内核崩溃时搜集信息 vmcore</p>



<div class="wp-container-1 wp-block-buttons">
<div class="wp-block-button aligncenter is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/kdump/">Linux Kdump 的开启 <br>（用于收集内核崩溃时的信息）</a></div>



<div class="wp-block-button is-style-outline"><a class="wp-block-button__link" href="https://eternalcenter-now.github.io/kdump-analysis/" style="border-radius:0px">Linux Kdump 内核奔溃信息的分析</a></div>
</div>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[工具] Shell 批量比较服务器所有正在运行进程的变化</title>
		<link>https://eternalcenter-now.github.io/shell-process-compare/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Thu, 20 Jan 2022 13:38:56 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Monitor (监控)]]></category>
		<category><![CDATA[Shell Tool (工具)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=21341</guid>

					<description><![CDATA[介绍： 作者：朱明宇名称：批量比较服务器所有正在运行进程的变化作用：批量比较服务器所有正在运行进程的变化 使用方法：1. 服务器清单 $server_list 每一台服务器占用一行2. 在此脚本的分割线内写入相应的内容，并和此脚本放在同一目录下3. 给此脚本添加执行权限4. 执行此脚本5. 此脚本执行完成后，会将运行结果写入当前目录下的 $compare_file 里 脚本分割线里的变量：server_list=server_list.txt #服务器清单first_time=first_time #存储第一次检结果的目录second_time=second_time #存储第二次检查结果的目录compare_file=comparison_results.txt #存储比较结果的文件 注意：此脚本执行前必须要先保证执行本脚本的用户能无密码 ssh 远程这些远程服务器 脚本：]]></description>
										<content:encoded><![CDATA[
<h2 id="介绍">介绍：</h2>



<p>作者：朱明宇<br>名称：批量比较服务器所有正在运行进程的变化<br>作用：批量比较服务器所有正在运行进程的变化</p>



<p>使用方法：<br>1. 服务器清单 $server_list 每一台服务器占用一行<br>2. 在此脚本的分割线内写入相应的内容，并和此脚本放在同一目录下<br>3. 给此脚本添加执行权限<br>4. 执行此脚本<br>5. 此脚本执行完成后，会将运行结果写入当前目录下的 $compare_file 里</p>



<p>脚本分割线里的变量：<br>server_list=server_list.txt #服务器清单<br>first_time=first_time #存储第一次检结果的目录<br>second_time=second_time #存储第二次检查结果的目录<br>compare_file=comparison_results.txt #存储比较结果的文件</p>



<p>注意：<br>此脚本执行前必须要先保证执行本脚本的用户能无密码 ssh 远程这些远程服务器</p>



<h2 id="脚本">脚本：</h2>



<pre class="wp-block-code"><code>#!/bin/bash

####################### Separator ########################

server_list=server_list.txt
first_time=first_time
second_time=second_time
compare_file=comparison_results.txt

####################### Separator ########################

mkdir $first_time &amp;&gt; /dev/null
mkdir $second_time &amp;&gt; /dev/null
echo &gt; $compare_file

read -p "Please input first second or compare now: " choice

check(){
        for server_name in `cat $1`
        do
                ssh -t $server_name "ps -A" | awk '{print $4}' &gt; $2/$server_name
        done
}

compare(){
        for server_name in `cat $1`
        do
                echo $server_name &gt;&gt; $4
                for process in `cat $2/$server_name`
                        do
                        grep $process $3/$server_name &amp;&gt; /dev/null
                        if &#91; $? -ne 0 ];then
                                echo $process &gt;&gt; $4
                        fi
                done
                echo &gt;&gt; $4
        done
}

if &#91; $choice == first ];then
        check $server_list $first_time
fi

if &#91; $choice == second ];then
        check $server_list $second_time
fi

if &#91; $choice == compare ];then
        compare $server_list $first_time $second_time $compare_file
fi</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Linux 进程修正值 （nice 值） 的设置</title>
		<link>https://eternalcenter-now.github.io/nice/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Thu, 04 Nov 2021 15:38:02 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=18158</guid>

					<description><![CDATA[内容目录： 内容一：进程优先级和修正值（nice 值）的关系1.1 进程优先级的作用1.2 进程优先级和修正值（nice 值）的关系1.3 修正值（nice 值）的范围 内容二：修正值（nice 值）的设置2.1 设置修正值（nice 值）的格式2.2 设置修正值（nice 值）的案例 内容三：显示进程的修正值 具体的内容： 内容一：进程优先级和修正值（nice 值）的关系1.1 进程优先级的作用 进程的真正优先级越小，则此进程则越能优先被执行 1.2 进程优先级和修正值（nice 值）的关系 进程的真正优先级 = 进程默认优先级 + 修正值（nice 值） 1.3 修正值（nice 值）的范围 从 -20 到 +19 内容二：修正值（nice 值）的设置2.1 设置修正值（nice 值）的格式 或者： 或者： 2.2 设置修正值（nice 值）的案例 或者： 或者： （注意：这里的 -10 不是指负数 10 而是指正数 10） （补充：这里以修正值为 10 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/nice/" class="more-link">Continue reading<span class="screen-reader-text"> "[内容] Linux 进程修正值 （nice 值） 的设置"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="内容目录">内容目录：</h2>



<h4 id="内容一-进程优先级和修正值-nice-值-的关系-1-1-进程优先级的作用-1-2-进程优先级和修正值-nice-值-的关系-1-3-修正值-nice-值-的范围">内容一：进程优先级和修正值（nice 值）的关系<br>1.1 进程优先级的作用<br>1.2 进程优先级和修正值（nice 值）的关系<br>1.3 修正值（nice 值）的范围</h4>



<h4 id="内容二-修正值-nice-值-的设置-2-1-设置修正值-nice-值-的格式-2-2-设置修正值-nice-值-的案例">内容二：修正值（nice 值）的设置<br>2.1 设置修正值（nice 值）的格式<br>2.2 设置修正值（nice 值）的案例</h4>



<h4 id="内容三-显示进程的修正值">内容三：显示进程的修正值</h4>



<h2 id="具体的内容">具体的内容：</h2>



<h4 id="内容一-进程优先级和修正值-nice-值-的关系-1-1-进程优先级的作用">内容一：进程优先级和修正值（nice 值）的关系<br>1.1 进程优先级的作用</h4>



<p>进程的真正优先级越小，则此进程则越能优先被执行</p>



<h4 id="1-2-进程优先级和修正值-nice-值-的关系">1.2 进程优先级和修正值（nice 值）的关系</h4>



<p>进程的真正优先级 = 进程默认优先级 + 修正值（nice 值）</p>



<h4 id="1-3-修正值-nice-值-的范围">1.3 修正值（nice 值）的范围</h4>



<p>从 -20 到 +19</p>



<h4 id="内容二-修正值-nice-值-的设置-2-1-设置修正值-nice-值-的格式">内容二：修正值（nice 值）的设置<br>2.1 设置修正值（nice 值）的格式</h4>



<pre class="wp-block-code"><code># nice -n &lt;correction value&gt; &lt;command&gt;</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># nice --adjustment=&lt;correction value&gt; &lt;command&gt;</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># nice -&lt;correction value&gt; &lt;command&gt;</code></pre>



<h4 id="2-2-设置修正值-nice-值-的案例">2.2 设置修正值（nice 值）的案例</h4>



<pre class="wp-block-code"><code># nice -n 10 top</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># nice --adjustment=10 top</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># nice -10 top</code></pre>



<p>（注意：这里的 -10 不是指负数 10 而是指正数 10）</p>



<p>（补充：这里以修正值为 10 启动 top 命令为例）</p>



<h4 id="内容三-显示进程的修正值-1">内容三：显示进程的修正值</h4>



<pre class="wp-block-code"><code># top</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># ps -ef</code></pre>



<p>（<br>补充：<br>1) PRI 代表进程默认的优先级<br>2) NI 代表进程的修正值（nice 值）<br>3) 进程的真正优先级 = PRI + NI<br>4) 如果多个进程的真正优先级一样，则 root 用户的进程被优先执行<br>）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Linux 脚本的管理 （通过 systemd 实现）</title>
		<link>https://eternalcenter-now.github.io/systemctl-script/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 04 Nov 2020 10:17:39 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=11652</guid>

					<description><![CDATA[步骤一：要被管理的脚本 创建以下内容： （补充：这里以创建 /etc/root/for.sh 脚本为例） 步骤二：创建 systemctl 的管理文件 创建以下内容： （补充：这里以创建 /etc/systemd/system/12456.service 来管理 ExecStart=/root/12456.sh 为例） 步骤三：加载刚刚创建的 systemctl 管理文件 步骤四：给 systemctl 的管理文件添加执行权限 步骤五：通过 systemd 管理脚本5.1 启动脚本 5.2 关闭脚本 5.3 重启脚本 5.4 让脚本开机自启]]></description>
										<content:encoded><![CDATA[
<h4>步骤一：要被管理的脚本</h4>



<pre class="wp-block-code"><code># vim /root/12456.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash
for i in {1..5}
do
echo $i
done</code></pre>



<p>（补充：这里以创建 /etc/root/for.sh 脚本为例）</p>



<h4>步骤二：创建 systemctl 的管理文件</h4>



<pre class="wp-block-code"><code># vim /etc/systemd/system/12456.service</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>&#91;Unit]
Description=12345
After=default.target

&#91;Service]
Type=oneshot
ExecStart=/root/12456.sh

&#91;Install]
WantedBy=default.target</code></pre>



<p>（补充：这里以创建 /etc/systemd/system/12456.service 来管理 ExecStart=/root/12456.sh 为例）</p>



<h4>步骤三：加载刚刚创建的 systemctl 管理文件</h4>



<pre class="wp-block-code"><code># systemctl daemon-reload</code></pre>



<h4>步骤四：给 systemctl 的管理文件添加执行权限</h4>



<pre class="wp-block-code"><code># chmod u+x /etc/systemd/system/12456.service</code></pre>



<h4>步骤五：通过 systemd 管理脚本<br>5.1 启动脚本</h4>



<pre class="wp-block-code"><code># systemctl start 12456.service</code></pre>



<h4>5.2 关闭脚本</h4>



<pre class="wp-block-code"><code># systemctl stop 12456.service</code></pre>



<h4>5.3 重启脚本</h4>



<pre class="wp-block-code"><code># systemctl restart 12456.service</code></pre>



<h4>5.4 让脚本开机自启</h4>



<pre class="wp-block-code"><code># systemctl enable 12456.service</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 service （管理程序单元）</title>
		<link>https://eternalcenter-now.github.io/service-command/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 21 Jul 2020 09:14:32 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=10158</guid>

					<description><![CDATA[内容一：列出所有受 systemctl 管理的单元 内容二：启动某一个单元 内容三：停止某一个单元]]></description>
										<content:encoded><![CDATA[
<h4>内容一：列出所有受 systemctl 管理的单元</h4>



<pre class="wp-block-code"><code># service -–status-all</code></pre>



<h4>内容二：启动某一个单元</h4>



<pre class="wp-block-code"><code># service &lt;unit&gt; start</code></pre>



<h4>内容三：停止某一个单元</h4>



<pre class="wp-block-code"><code># service &lt;unit&gt; stop</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Linux 进程状态介绍</title>
		<link>https://eternalcenter-now.github.io/process-status/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 17 Jul 2020 02:53:57 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=10079</guid>

					<description><![CDATA[内容一：Linux 的第一进程状态 （1）R 处于运行状态或者等待运行状态（2）S 处于休眠状态（3）T 处于停止状态或者处于被追踪的状态（4）Z 处于僵尸进程的状态（5）W 处于进入内存交换的状态（6）X 处于被杀死进程的状态（7）D 处于不可中断的休眠状态 （注意：D 状态通常由存储进程中断导致，无法被 kill 命令杀死，但可以通过重启系统清除） 内容二：Linux 的第二进程状态 （1）&#60; 代表此进程具有高优先级（2）N 代表此进程具有低优先级（3）L 代表此进程有些部分被所进了内存（4）s 代表此进程包含子进程（5）+ 代表此进程处于后台的状态（6）l 代表此进程是被克隆出来的多线程 内容三：Linux 显示进程状态的命令]]></description>
										<content:encoded><![CDATA[
<h4 id="内容一-linux-的第一进程状态">内容一：Linux 的第一进程状态</h4>



<p>（1）R 处于运行状态或者等待运行状态<br>（2）S 处于休眠状态<br>（3）T 处于停止状态或者处于被追踪的状态<br>（4）Z 处于僵尸进程的状态<br>（5）W 处于进入内存交换的状态<br>（6）X 处于被杀死进程的状态<br>（7）D 处于不可中断的休眠状态</p>



<p>（注意：D 状态通常由存储进程中断导致，无法被 kill 命令杀死，但可以通过重启系统清除）</p>



<h4 id="内容二-linux-的第二进程状态">内容二：Linux 的第二进程状态</h4>



<p>（1）&lt; 代表此进程具有高优先级<br>（2）N 代表此进程具有低优先级<br>（3）L 代表此进程有些部分被所进了内存<br>（4）s 代表此进程包含子进程<br>（5）+ 代表此进程处于后台的状态<br>（6）l 代表此进程是被克隆出来的多线程</p>



<h4 id="内容三-linux-显示进程状态的命令">内容三：Linux 显示进程状态的命令</h4>



<pre class="wp-block-code"><code># ps -aux</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] CentOS Linux &#038; RHEL 网页图形化管理工具 cockpit</title>
		<link>https://eternalcenter-now.github.io/cockpit/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 06 Jun 2020 09:07:39 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Firewall (系统防火墙)]]></category>
		<category><![CDATA[System General Log (系统普通日志)]]></category>
		<category><![CDATA[System Log (系统日志)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network (系统网络)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Port Security (系统端口安全)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Security Log (系统安全日志)]]></category>
		<category><![CDATA[System Setting (系统设置)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<category><![CDATA[System Statistic Log (系统统计日志)]]></category>
		<category><![CDATA[System User (系统用户)]]></category>
		<category><![CDATA[System User & System Privilege (系统用户 & 系统权限)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=9718</guid>

					<description><![CDATA[步骤一：系统环境要求 服务器系统配置好可用的软件源 步骤二：安装 cockpit （补充：cockpit 是管理单台主机的程序，cockpit-dashaboard 是管理多台主机的程序） 步骤三：启动 cockpit 步骤四：登录 cockpit 使用浏览器登录：https://&/#60;服务器的 IP 地址&#62;:9090]]></description>
										<content:encoded><![CDATA[
<h4>步骤一：系统环境要求</h4>



<p>服务器系统配置好可用的软件源</p>



<h4>步骤二：安装 cockpit</h4>



<pre class="wp-block-code"><code># yum -y install cockpit cockpit-dashaboard</code></pre>



<p>（补充：cockpit 是管理单台主机的程序，cockpit-dashaboard 是管理多台主机的程序）</p>



<h4>步骤三：启动 cockpit</h4>



<pre class="wp-block-code"><code># systemctl start cockpit</code></pre>



<h4>步骤四：登录 cockpit</h4>



<p>使用浏览器登录：https://&lt;服务器的/ IP 地址&gt;:9090</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 ps （显示进程） （转载）</title>
		<link>https://eternalcenter-now.github.io/ps/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 05 Jun 2020 07:46:58 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=9679</guid>

					<description><![CDATA[注明：所有转载内容皆直接从被转载文章网页的标题和内容的文本和图片中复制而来]]></description>
										<content:encoded><![CDATA[
<pre class="wp-block-code"><code>ps 命令的使用

Ps命令是Linux中最常使用的进程查看工具，主要用于显示包含当前运行的各进程完整信息的静态快照（查看静态的进程统计信息）。通过不同的命令选项可以有选择性的查看进程信息。

a：显示当前终端下的所有进行信息，包括其他用户的进程。与x选项结合时将显示系统中所有的进程信息。

u：使用以用户为主的格式输出进程信息。

x：显示当前用户在所有终端下的进程信息。

-e：显示系统内的所有进程信息。

-l：使用长格式显示进程信息。

-f：使用完整的格式显示进程信息。</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img width="622" height="170" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/ps-1.png" alt="" class="wp-image-19781" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/ps-1.png 622w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/ps-1-300x82.png 300w" sizes="(max-width: 622px) 100vw, 622px" /></figure></div>



<pre class="wp-block-code"><code># ps aux

解释:

USER：启动该进程的用户账号名称

PID：该进程在系统中的数字ID号，在当前系统中是唯一的。

TTY：表明该进程在哪个终端上运行。“？”表示未知或者不需要终端。

STAT：显示了进程当前的状态，如S（休眠）、R（运行）、Z（僵死）、&lt;（高优先级）、N（低优先级）、s（父进程）、+（前台进程）。对于僵死的进程，应该手动处理掉。（问：为什么？）

START：启动该进程的时间

TIME：该进程占用CPU的时间

COMMAND：启用该进程的命令名称

%CPU：CPU占用百分比

%MEM：内存占用百分比

VSZ：占用虚拟内存（swap空间）大小

RSS：占用常驻空间（物理内存）的大小</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="706" height="150" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/ps-2.png" alt="" class="wp-image-19782" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/ps-2.png 706w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/ps-2-300x64.png 300w" sizes="(max-width: 706px) 100vw, 706px" /></figure></div>



<pre class="wp-block-code"><code>————————————————
版权声明：本文为CSDN博主「秃头阿鑫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_47763101/java/article/details/106391154</code></pre>



<p>注明：所有转载内容皆直接从被转载文章网页的标题和内容的文本和图片中复制而来</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="1010" height="161" src="https://eternalcenter-now.github.io/wp-content/uploads/2020/06/版权申明证明-ps.png" alt="" class="wp-image-9682" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2020/06/版权申明证明-ps.png 1010w, https://eternalcenter-now.github.io/wp-content/uploads/2020/06/版权申明证明-ps-300x48.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2020/06/版权申明证明-ps-768x122.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>CC 4.0 BY-SA 版权协议网址：https://creativecommons.org/licenses/by-sa/4.0/deed.z</figcaption></figure></div>



<pre class="wp-block-code"><code>站主补充：
补充一：D 状态的进程
D 状态的进程代表处于不可以被杀死的休眠状态。D 状态的进程就算是用 kill -9 命令也无法杀死

补充二：将 ps 的输出工整
# ps -T </code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 kill （进程杀死）</title>
		<link>https://eternalcenter-now.github.io/kill/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 30 May 2020 05:19:38 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=9614</guid>

					<description><![CDATA[内容目录： 内容一：显示 kill 所有可用的选项 内容二：kill 的常用案例2.1 案例一：强杀某一个 pid 号2.2 案例二：正常退出某一个 pid 号2.3 案例三：杀死某一个进程名称下的所有 pid 号 具体的内容： 内容一：显示 kill 所有可用的选项 内容二：kill 的常用案例2.1 案例一：强杀某一个 pid 号 或者： 2.2 案例二：正常退出某一个 pid 号 2.3 案例三：杀死某一个进程名称下的所有 pid 号]]></description>
										<content:encoded><![CDATA[
<h2 id="内容目录">内容目录：</h2>



<h4 id="内容一-查看-kill-所有可用的选项">内容一：显示 kill 所有可用的选项</h4>



<h4 id="内容二-kill-的常用案例2-1-案例一-强杀某一个-pid-号2-2-案例二-正常退出某一个-pid-号2-3-案例三-杀死某一个进程名称下的所有-pid-号">内容二：kill 的常用案例<br>2.1 案例一：强杀某一个 pid 号<br>2.2 案例二：正常退出某一个 pid 号<br>2.3 案例三：杀死某一个进程名称下的所有 pid 号</h4>



<h2 id="具体的内容">具体的内容：</h2>



<h4 id="内容一-查看-kill-所有可用的选项">内容一：显示 kill 所有可用的选项</h4>



<h4 id="内容二-kill-的常用案例2-1-案例一-强杀某一个-pid-号">内容二：kill 的常用案例<br>2.1 案例一：强杀某一个 pid 号</h4>



<pre class="wp-block-code"><code># kill -9 &lt;pid number&gt;</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># kill -&lt;kill option&gt; &lt;pid number&gt;</code></pre>



<h4 id="2-2-案例二-正常退出某一个-pid-号">2.2 案例二：正常退出某一个 pid 号</h4>



<pre class="wp-block-code"><code># kill -15 &lt;pid number&gt;</code></pre>



<h4 id="2-3-案例三-杀死某一个进程名称下的所有-pid-号">2.3 案例三：杀死某一个进程名称下的所有 pid 号</h4>



<pre class="wp-block-code"><code># killall &lt;process name&gt;</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 pstree （显示进程树）</title>
		<link>https://eternalcenter-now.github.io/pstreee/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 30 May 2020 05:13:26 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=9612</guid>

					<description><![CDATA[内容一：系统环境要求 服务器系统配置好可用的软件源 内容二：如果系统中没有此命令，则需要先安装此命令 （补充：这里以 CentOS&#38;RHEL 安装 psmisc 为例） 内容三：使用此命令]]></description>
										<content:encoded><![CDATA[
<h4 id="内容一-系统环境要求">内容一：系统环境要求</h4>



<p>服务器系统配置好可用的软件源</p>



<h4 id="内容二-如果系统中没有此命令-则需要先安装此命令">内容二：如果系统中没有此命令，则需要先安装此命令</h4>



<pre class="wp-block-code"><code># yum -y install psmisc</code></pre>



<p>（补充：这里以 CentOS&amp;RHEL 安装 psmisc 为例）</p>



<h4 id="内容三-使用此命令">内容三：使用此命令</h4>



<pre class="wp-block-code"><code># pstree</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Linux 后台进程的管理</title>
		<link>https://eternalcenter-now.github.io/background-process/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 30 May 2020 04:01:08 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=9608</guid>

					<description><![CDATA[内容目录： 内容一：将进程放入后台1.1 直接将一个进程放到后台1.2 将一个目前正在前台运行的进程放到后台 内容二：显示放入后台的进程2.1 显示所有放入后台的进程2.2 显示某一个放入后台的进程 内容三：管理放入后台的进程3.1 在后台启动放入后台的进程3.1.1 在后台启动放入后台的进程（通过后台进程号）3.1.2 在后台启动放入后台的进程（通过后台进程名）3.2 在前台启动放入后台的进程3.2.1 在前台启动放入后台的进程（通过后台进程号）3.2.2 在前台启动放入后台的进程（通过后台进程名）3.3 杀死放入后台的进程3.3.1 杀死放入后台的进程（通过后台进程号）3.3.2 杀死放入后台的进程（通过后台进程名） 具体的内容： 内容一：将进程放入后台1.1 直接将一个进程放到后台 1.2 将一个目前正在前台运行的进程放到后台 按下 “ctrl” 键和 “z” 键 内容二：显示放入后台的进程2.1 显示所有放入后台的进程 2.2 显示某一个放入后台的进程2.2.1 显示某一个放入后台进程（通过后台进程号） 2.2.2 显示某一个放入后台进程（通过后台进程名） （注意：只有后台进程名唯一时此操作才有效） 内容三：管理放入后台的进程3.1 在后台启动放入后台的进程3.1.1 在后台启动放入后台的进程（通过后台进程号） （注意：只有可以在后台启动的进程才能在后台启动） 3.1.2 在后台启动放入后台的进程（通过后台进程名） （注意：只有可以在后台启动的进程才能在后台启动，且只有后台进程名唯一时此操作才有效） 3.2 在前台启动放入后台的进程3.2.1 在前台启动放入后台的进程（通过后台进程号） 3.2.2 在前台启动放入后台的进程（通过后台进程名） （注意：只有后台进程名唯一时此操作才有效） 3.3 杀死放入后台的进程3.3.1 杀死放入后台的进程（通过后台进程号） （补充：这里可以配合各种 kill 选项进行操作，例如 kill &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/background-process/" class="more-link">Continue reading<span class="screen-reader-text"> "[内容] Linux 后台进程的管理"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="内容目录">内容目录：</h2>



<h4 id="内容一-将进程放入后台1-1-直接将一个进程放到后台1-2-将一个目前正在前台运行的进程放到后台">内容一：将进程放入后台<br>1.1 直接将一个进程放到后台<br>1.2 将一个目前正在前台运行的进程放到后台</h4>



<h4 id="内容二-显示放入后台的进程2-1-显示所有放入后台的进程2-2-显示某一个放入后台的进程">内容二：显示放入后台的进程<br>2.1 显示所有放入后台的进程<br>2.2 显示某一个放入后台的进程</h4>



<h4 id="内容三-管理放入后台的进程3-1-在后台启动放入后台的进程3-1-1-在后台启动放入后台的进程-通过后台进程号-3-1-2-在后台启动放入后台的进程-通过后台进程名-3-2-在前台启动放入后台的进程3-2-1-在前台启动放入后台的进程-通过后台进程号-3-2-2-在前台启动放入后台的进程-通过后台进程名-3-3-杀死放入后台的进程3-3-1-杀死放入后台的进程-通过后台进程号-3-3-2-杀死放入后台的进程-通过后台进程名">内容三：管理放入后台的进程<br>3.1 在后台启动放入后台的进程<br>3.1.1 在后台启动放入后台的进程（通过后台进程号）<br>3.1.2 在后台启动放入后台的进程（通过后台进程名）<br>3.2 在前台启动放入后台的进程<br>3.2.1 在前台启动放入后台的进程（通过后台进程号）<br>3.2.2 在前台启动放入后台的进程（通过后台进程名）<br>3.3 杀死放入后台的进程<br>3.3.1 杀死放入后台的进程（通过后台进程号）<br>3.3.2 杀死放入后台的进程（通过后台进程名）</h4>



<h2 id="具体的内容">具体的内容：</h2>



<h4 id="内容一-将进程放入后台1-1-直接将一个进程放到后台">内容一：将进程放入后台<br>1.1 直接将一个进程放到后台</h4>



<pre class="wp-block-code"><code># firefox&amp;</code></pre>



<h4 id="1-2-将一个目前正在前台运行的进程放到后台">1.2 将一个目前正在前台运行的进程放到后台</h4>



<p>按下 “ctrl” 键和 “z” 键</p>



<h4 id="内容二-显示放入后台的进程2-1-显示所有放入后台的进程">内容二：显示放入后台的进程<br>2.1 显示所有放入后台的进程</h4>



<pre class="wp-block-code"><code># jobs</code></pre>



<h4 id="2-2-显示某一个放入后台的进程2-2-1-显示某一个放入后台进程-通过后台进程号">2.2 显示某一个放入后台的进程<br>2.2.1 显示某一个放入后台进程（通过后台进程号）</h4>



<pre class="wp-block-code"><code># jobs %&lt;background process number&gt;</code></pre>



<h4 id="2-2-2-显示某一个放入后台进程-通过后台进程名">2.2.2 显示某一个放入后台进程（通过后台进程名）</h4>



<pre class="wp-block-code"><code># jobs %&lt;background process name&gt;</code></pre>



<p>（注意：只有后台进程名唯一时此操作才有效）</p>



<h4 id="内容三-管理放入后台的进程3-1-在后台启动放入后台的进程3-1-1-在后台启动放入后台的进程-通过后台进程号">内容三：管理放入后台的进程<br>3.1 在后台启动放入后台的进程<br>3.1.1 在后台启动放入后台的进程（通过后台进程号）</h4>



<pre class="wp-block-code"><code># bg %&lt;background process number&gt;</code></pre>



<p>（注意：只有可以在后台启动的进程才能在后台启动）</p>



<h4 id="3-1-2-在后台启动放入后台的进程-通过后台进程名">3.1.2 在后台启动放入后台的进程（通过后台进程名）</h4>



<pre class="wp-block-code"><code># bg %&lt;background process name&gt;</code></pre>



<p>（注意：只有可以在后台启动的进程才能在后台启动，且只有后台进程名唯一时此操作才有效）</p>



<h4 id="3-2-在前台启动放入后台的进程3-2-1-在前台启动放入后台的进程-通过后台进程号">3.2 在前台启动放入后台的进程<br>3.2.1 在前台启动放入后台的进程（通过后台进程号）</h4>



<pre class="wp-block-code"><code># fg %&lt;background process number&gt;</code></pre>



<h4 id="3-2-2-在前台启动放入后台的进程-通过后台进程名">3.2.2 在前台启动放入后台的进程（通过后台进程名）</h4>



<pre class="wp-block-code"><code># fg %&lt;background process name&gt;</code></pre>



<p>（注意：只有后台进程名唯一时此操作才有效）</p>



<h4 id="3-3-杀死放入后台的进程3-3-1-杀死放入后台的进程-通过后台进程号">3.3 杀死放入后台的进程<br>3.3.1 杀死放入后台的进程（通过后台进程号）</h4>



<pre class="wp-block-code"><code># kill %&lt;background process number&gt;</code></pre>



<p>（补充：这里可以配合各种 kill 选项进行操作，例如 kill -9）</p>



<h4 id="3-3-2-杀死放入后台的进程-通过后台进程名">3.3.2 杀死放入后台的进程（通过后台进程名）</h4>



<pre class="wp-block-code"><code># kill %&lt;background process name&gt;</code></pre>



<p>（注意：只有后台进程名唯一时此操作才有效）</p>



<p>（补充：这里可以配合各种 kill 选项进行操作，例如 kill -9）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 systemctl （程序单元启动和管理）</title>
		<link>https://eternalcenter-now.github.io/systemctl/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 13 Mar 2020 06:59:07 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=8658</guid>

					<description><![CDATA[内容目录： 内容一：受 systemctl 管理的单元列表1.1 列出所有 systemctl 可用单元1.2 列出所有 systemctl 正在运行的单元1.3 列出所有 systemctl 运行失败的单元1.4 列出所有受 systemctl 管理的服务单元1.5 列出所有受 systemctl 管理的目标单元 内容二：单元的状态显示 内容三：单元的启动管理3.1 启动某一个单元3.2 停止某一个单元3.3 重启某一个单元3.4 启动并将一个单元设置为开机自启 内容四：单元的开机自启管理4.1 让某一个单元开机自启4.2 取消某一个单元的开机自启4.3 显示某一个单元是否是开机自启 内容五：单元的锁定管理5.1 锁定某一个单元（禁止其启动）5.2 取消某一个单元的锁定（让它可以启动） 内容六：重新加载某 systemctl 的配置文件 具体的内容： 内容一：受 systemctl 管理的单元列表1.1 列出所有 systemctl 可用单元 （补充：所有受 systemctl 管理单元的文件都是放在 /usr/lib/systemd/system 目录下的） 1.2 列出所有 systemctl 正在运行的单元 （补充：所有受 systemctl 管理单元的文件都是放在 /usr/lib/systemd/system &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/systemctl/" class="more-link">Continue reading<span class="screen-reader-text"> "[命令] Linux 命令 systemctl （程序单元启动和管理）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="内容目录">内容目录：</h2>



<h4 id="内容一-受-systemctl-管理的单元列表1-1-列出所有-systemctl-可用单元1-2-列出所有-systemctl-正在运行的单元1-3-列出所有-systemctl-运行失败的单元1-4-列出所有受-systemctl-管理的服务单元1-5-列出所有受-systemctl-管理的目标单元">内容一：受 systemctl 管理的单元列表<br>1.1 列出所有 systemctl 可用单元<br>1.2 列出所有 systemctl 正在运行的单元<br>1.3 列出所有 systemctl 运行失败的单元<br>1.4 列出所有受 systemctl 管理的服务单元<br>1.5 列出所有受 systemctl 管理的目标单元</h4>



<h4 id="内容二-单元的状态查看">内容二：单元的状态显示</h4>



<h4 id="内容三-单元的启动管理3-1-启动某一个单元3-2-停止某一个单元3-3-重启某一个单元3-4-启动并将一个单元设置为开机自启">内容三：单元的启动管理<br>3.1 启动某一个单元<br>3.2 停止某一个单元<br>3.3 重启某一个单元<br>3.4 启动并将一个单元设置为开机自启</h4>



<h4 id="内容四-单元的开机自启管理4-1-让某一个单元开机自启4-2-取消某一个单元的开机自启4-3-显示某一个单元是否是开机自启">内容四：单元的开机自启管理<br>4.1 让某一个单元开机自启<br>4.2 取消某一个单元的开机自启<br>4.3 显示某一个单元是否是开机自启</h4>



<h4 id="内容五-单元的锁定管理5-1-锁定某一个单元-禁止其启动-5-2-取消某一个单元的锁定-让它可以启动">内容五：单元的锁定管理<br>5.1 锁定某一个单元（禁止其启动）<br>5.2 取消某一个单元的锁定（让它可以启动）</h4>



<h4 id="内容六-重新加载某-systemctl-的配置文件">内容六：重新加载某 systemctl 的配置文件</h4>



<h2 id="具体的内容">具体的内容：</h2>



<h4 id="内容一-受-systemctl-管理的单元列表1-1-列出所有-systemctl-可用单元">内容一：受 systemctl 管理的单元列表<br>1.1 列出所有 systemctl 可用单元</h4>



<pre class="wp-block-code"><code># systemctl list-unit-files</code></pre>



<p>（补充：所有受 systemctl 管理单元的文件都是放在 /usr/lib/systemd/system 目录下的）</p>



<h4 id="1-2-列出所有-systemctl-正在运行的单元">1.2 列出所有 systemctl 正在运行的单元</h4>



<pre class="wp-block-code"><code># systemctl list-units</code></pre>



<p>（补充：所有受 systemctl 管理单元的文件都是放在 /usr/lib/systemd/system 目录下的）</p>



<h4 id="1-3-列出所有-systemctl-运行失败的单元">1.3 列出所有 systemctl 运行失败的单元</h4>



<pre class="wp-block-code"><code># systemctl --failed</code></pre>



<p>（补充：所有受 systemctl 管理单元的文件都是放在 /usr/lib/systemd/system 目录下的）</p>



<h4 id="1-4-列出所有受-systemctl-管理的服务单元">1.4 列出所有受 systemctl 管理的服务单元</h4>



<pre class="wp-block-code"><code># systemctl list-units --type service</code></pre>



<p>（<br>补充：<br>1) 所有受 systemctl 管理单元的文件都是放在 /usr/lib/systemd/system 目录下的<br>2) service 是一个个单独的服务<br>3) target 是包含很多个单独服务（service）的一组服务<br>）</p>



<h4 id="1-5-列出所有受-systemctl-管理的目标单元">1.5 列出所有受 systemctl 管理的目标单元</h4>



<pre class="wp-block-code"><code># systemctl list-units --type target</code></pre>



<p>（<br>补充：<br>1) 所有受 systemctl 目标管理单元的文件都是放在 /usr/lib/systemd/system 目录下的<br>2) service 是一个个单独的服务<br>3) target 是包含很多个单独服务（service）的一组服务<br>）</p>



<h4 id="内容二-单元的状态查看">内容二：单元的状态显示</h4>



<pre class="wp-block-code"><code># systemctl status &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) systemctl 的主要状态项有：<br>     Loaded 单元是否已被内存加载<br>     Active 单元是否已成功运行<br>     Main PID 单元主进程的 PID 号<br>     Status 单元的其他相关信息</p>



<p>2) Active 状态项的参数有：<br>     loaded 单元文件已经处理<br>     active（running） 单元正在运行<br>     active（exited）已完成单元的一次性配置<br>     active（waiting）正在等待启动<br>     inactive 没有启动<br>     enabled 将在系统启动时自动启动<br>     disabled 不会在系统启动时自动启动<br>     static 可以被其他单元启动</p>



<p>3) 单元既可以是服务单元也可以是目标单元<br>）</p>



<h4 id="内容三-单元的启动管理3-1-启动某一个单元">内容三：单元的启动管理<br>3.1 启动某一个单元</h4>



<pre class="wp-block-code"><code># systemctl start &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="3-2-停止某一个单元">3.2 停止某一个单元</h4>



<pre class="wp-block-code"><code># systemctl stop &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="3-3-重启某一个单元">3.3 重启某一个单元</h4>



<pre class="wp-block-code"><code># systemctl restart &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="3-3-显示某一个单元是否正在运行">3.3 显示某一个单元是否正在运行</h4>



<pre class="wp-block-code"><code># systemctl is-active &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="3-4-启动并将一个单元设置为开机自启">3.4 启动并将一个单元设置为开机自启</h4>



<pre class="wp-block-code"><code># systemctl enable --now &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="内容四-单元的开机自启管理4-1-让某一个单元开机自启">内容四：单元的开机自启管理<br>4.1 让某一个单元开机自启</h4>



<pre class="wp-block-code"><code># systemctl enable &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="4-2-取消某一个单元的开机自启">4.2 取消某一个单元的开机自启</h4>



<pre class="wp-block-code"><code># systemctl disable &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="4-3-显示某一个单元是否是开机自启">4.3 显示某一个单元是否是开机自启</h4>



<pre class="wp-block-code"><code># systemctl is-enabled &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="内容五-单元的锁定管理5-1-锁定某一个单元-禁止其启动">内容五：单元的锁定管理<br>5.1 锁定某一个单元（禁止其启动）</h4>



<pre class="wp-block-code"><code># systemctl mask &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="5-2-取消某一个单元的锁定-让它可以启动">5.2 取消某一个单元的锁定（让它可以启动）</h4>



<pre class="wp-block-code"><code># systemctl umask &lt;unit&gt;</code></pre>



<p>（<br>补充：<br>1) service 是一个个单独的服务<br>2) target 是包含很多个单独服务（service）的一组服务<br>3) 单元既可以是服务单元（service）也可以是目标单元（target）<br>）</p>



<h4 id="内容六-重新加载某-systemctl-的配置文件">内容六：重新加载某 systemctl 的配置文件</h4>



<pre class="wp-block-code"><code># systemctl daemon-reload</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 iotop （显示某一个进程占用 IO 的情况） （转载）</title>
		<link>https://eternalcenter-now.github.io/iotop/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 13 Mar 2020 06:52:34 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=8655</guid>

					<description><![CDATA[注明：所有转载内容皆直接从被转载文章网页的标题和内容的文本中复制而来]]></description>
										<content:encoded><![CDATA[
<pre class="wp-block-code"><code>记一次iotop分析磁盘占用io问题

问题描述    

                 某一台服务器上面 程序在每小时内偶尔丢包 排查服务器所有性能瓶颈之后发现一个奇怪的问题 程序丢包前后 会有IO过高的情况 于是使用iotop命令排查是哪个程序偶尔占用过高的磁盘IO

所用命令  

                 iotop

相关参数 

    -o：只显示有io操作的进程

    -b：批量显示，无交互，主要用作记录到文件

    -n NUM：显示NUM次，主要用于非交互式模式

    -d SEC：间隔SEC秒显示一次

    -p PID：监控的进程pid

    -u USER：监控的进程用户

排查方法

        iostat命令 只能看出每个盘符的IO情况 不能看到是具体哪个进程使用的IO 所以 我们需要使用iotop命令 但是这次的IO情况并不是一直出现 而是偶尔不规律出现 如果用肉眼去一直盯着终端看 显然不可行 于是我们可以用iotop的-b参数 让结果以非交互的方式输出 这样我们便可以用awk去处理 打印出我们需要的IO列以及相应的进程

命令

iotop -b | awk -F'%' '{if($(NF-1) &gt; 0.2 &amp;&amp; $(NF-1) ~ /&#91;0-9]/ &amp;&amp; $0 !~ /DISK/)printf "TIME: %s,IO:%s%,COMMAND:%s\n",strftime("%F %T"),$(NF-1),$NF}'

输出结果

&#91;root@localhost ~]# iotop -b | awk -F'%' '{if($(NF-1) &gt; 0.2 &amp;&amp; $(NF-1) ~ /&#91;0-9]/ &amp;&amp; $0 !~ /DISK/)printf "TIME: %s,IO:%s%,COMMAND:%s\n",strftime("%F %T"),$(NF-1),$NF}'
TIME: 2018-03-21 18:04:23,IO:  0.23 %,COMMAND: &#91;kworker/0:2]
TIME: 2018-03-21 18:04:35,IO:  0.44 %,COMMAND: &#91;kworker/0:2]
TIME: 2018-03-21 18:04:47,IO:  0.22 %,COMMAND: &#91;kworker/0:2]
TIME: 2018-03-21 18:04:58,IO:  0.39 %,COMMAND: &#91;kworker/0:2]
TIME: 2018-03-21 18:05:08,IO:  0.68 %,COMMAND: &#91;kworker/0:2]
TIME: 2018-03-21 18:05:22,IO:  0.52 %,COMMAND: &#91;kworker/0:2]
TIME: 2018-03-21 18:05:34,IO:  0.24 %,COMMAND: &#91;kworker/0:2]
TIME: 2018-03-21 18:05:45,IO:  0.26 %,COMMAND: &#91;kworker/0:2]

        输出结果类似上面 这里只是简单举个例子 打印出IO大于0.2%的进程 并根据客户需求打印除相应的时间 这里的时间打印 利用awk自己的函数 strftime()
————————————————
版权声明：本文为CSDN博主「why_me310」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/why_me310/article/details/79643352</code></pre>



<p>注明：所有转载内容皆直接从被转载文章网页的标题和内容的文本中复制而来</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="1013" height="203" src="https://eternalcenter-now.github.io/wp-content/uploads/2020/03/版权申明证明-iotop.png" alt="" class="wp-image-8656" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2020/03/版权申明证明-iotop.png 1013w, https://eternalcenter-now.github.io/wp-content/uploads/2020/03/版权申明证明-iotop-300x60.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2020/03/版权申明证明-iotop-768x154.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>CC 4.0 BY-SA 版权协议网址：https://creativecommons.org/licenses/by-sa/4.0/deed.z</figcaption></figure></div>



<pre class="wp-block-code"><code>站主补充：
 iotop 还有以下参数
-k, --kilobytes 在非交互的模式下，以 kb 为单位显示
-t, --time 在非交互的模式下，加上时间戳
-q, --quiet 在交互的模式下，禁止头几行，它有三种指定方式
    -q 只有在第一次显示时显示列名
    -qq 永远不显示列名
    -qqq 永远不显示 I/O 汇总的总量</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 sar （报告系统活动情况） （转载）</title>
		<link>https://eternalcenter-now.github.io/sar/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 13 Mar 2020 06:36:59 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Network (系统网络)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Storage (系统存储)]]></category>
		<category><![CDATA[System Storage & System Directory & System File (系统存储 & 系统目录 & 系统文件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=8644</guid>

					<description><![CDATA[注明：所有转载内容皆直接从被转载文章网页的标题和内容的文本和图片中复制而来]]></description>
										<content:encoded><![CDATA[
<pre class="wp-block-code"><code>sar

sar（SYstem ActivityReporter系统活动情况报告）是目前Linux上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况，系统调用的使用情况，磁盘I/O，CPU效率，内存使用状况，进程活动及IPC有关的活动；
sar命令有sysstat安装包安装
1.安装：&#91;root@admin ~]# yum -y install sysstat
2.参数：
-u :输出CPU使用情况和统计信息
-p:报告每个CPU的状态
-q:查看平均负载
-r:查看内存使用情况
-W :查看系统swap分区的统计信息
-x:显示给定进程的统计信息
-b:查看I/O和传递速率的统计信息
 -d:磁盘使用详细统计
 -v:进程，inode，文件和锁表状态
 -n:统计网络信息
-u :输出CPU使用情况和统计信息
-A：所有报告总和
-i:设置状态信息刷新的间隔时间
    &#91;root@admin ~]# sar -u 1 3  （每隔一秒总共统计三次；统计CPU的使用情况）</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="579" height="218" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-1.png" alt="" class="wp-image-19637" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-1.png 579w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-1-300x113.png 300w" sizes="(max-width: 579px) 100vw, 579px" /></figure></div>



<pre class="wp-block-code"><code>在以上的显示中，主要看%iowait和%idle，%iowait过高表示存在I/O瓶颈，即磁盘I/O无法满足业务需求，如果%idle过低表示CPU使用率比较严重，需要结合内存使用等情况半段CPU是否瓶颈。
2.2 -p:报告每个CPU的状态
    &#91;root@admin ~]# sar -p 1 3 （报告每个CPU的使用状态）</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="571" height="130" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-2.png" alt="" class="wp-image-19638" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-2.png 571w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-2-300x68.png 300w" sizes="(max-width: 571px) 100vw, 571px" /></figure></div>



<pre class="wp-block-code"><code>2.3 将统计结果保存在文件中，并从文件读取内容
        &#91;root@admin ~]# sar -u -o /servers/script/sar.txt 2 3 （保存之文件，保存后的文件是二进制的，无法使用vim和cat查看）
        &#91;root@admin ~]# sar -u -f /servers/script/sar.txt （从二进制文件读取）</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="579" height="262" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-3.png" alt="" class="wp-image-19639" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-3.png 579w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-3-300x136.png 300w" sizes="(max-width: 579px) 100vw, 579px" /></figure></div>



<pre class="wp-block-code"><code>注：将输出到文件(-o)和读取记录信息(-f)
2.4 -q:查看平均负载
        &#91;root@admin ~]# sar -q 1 3</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="566" height="227" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-4.png" alt="" class="wp-image-19640" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-4.png 566w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-4-300x120.png 300w" sizes="(max-width: 566px) 100vw, 566px" /></figure></div>



<pre class="wp-block-code"><code>2.5-r:查看内存使用情况
        &#91;root@admin ~]# sar -r</code></pre>



<figure class="wp-block-image size-full"><img loading="lazy" width="612" height="393" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-5.png" alt="" class="wp-image-19642" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-5.png 612w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-5-300x193.png 300w" sizes="(max-width: 612px) 100vw, 612px" /></figure>



<pre class="wp-block-code"><code>2.6 -W :查看系统swap分区的统计信息</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="369" height="232" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-6.png" alt="" class="wp-image-19643" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-6.png 369w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-6-300x189.png 300w" sizes="(max-width: 369px) 100vw, 369px" /></figure></div>



<pre class="wp-block-code"><code>2.7 -b:查看I/O和传递速率的统计信息
2.8 -d:磁盘使用详细统计
2.9 -v:进程，inode，文件和锁表状态
2.10 -n:统计网络信息
        1） DEV：网络接口统计信息
        2） EDEV：网络接口错误
        3）IP：IP数据报统计信息
        4)：EIP：IP错误统计信息
         5）TCP：TCP统计信息
          6）ETCP：TCP错误统计信息
         7）SOCK：套接字使用</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="556" height="246" src="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-7.png" alt="" class="wp-image-19644" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-7.png 556w, https://eternalcenter-now.github.io/wp-content/uploads/2021/12/sar-7-300x133.png 300w" sizes="(max-width: 556px) 100vw, 556px" /></figure></div>



<pre class="wp-block-code"><code>————————————————
版权声明：本文为CSDN博主「喵喵Amy」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/an1415/article/details/80761614</code></pre>



<p>注明：所有转载内容皆直接从被转载文章网页的标题和内容的文本和图片中复制而来</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="1014" height="202" src="https://eternalcenter-now.github.io/wp-content/uploads/2020/03/版权申明证明-sar.png" alt="" class="wp-image-8652" srcset="https://eternalcenter-now.github.io/wp-content/uploads/2020/03/版权申明证明-sar.png 1014w, https://eternalcenter-now.github.io/wp-content/uploads/2020/03/版权申明证明-sar-300x60.png 300w, https://eternalcenter-now.github.io/wp-content/uploads/2020/03/版权申明证明-sar-768x153.png 768w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>CC 4.0 BY-SA 版权协议网址：https://creativecommons.org/licenses/by-sa/4.0/deed.z</figcaption></figure></div>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Linux Nginx  源码安装包的管理 （通过 systemd 实现）</title>
		<link>https://eternalcenter-now.github.io/systemctl-service/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Thu, 17 Oct 2019 14:32:11 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Nginx]]></category>
		<category><![CDATA[Nginx Management (管理)]]></category>
		<category><![CDATA[Nginx Monitor (监控)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Software (系统软件)]]></category>
		<category><![CDATA[Website Services (网站服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=5912</guid>

					<description><![CDATA[注意：在通过 systemd 管理源码安装的软件或自制 rpm 包安装的软件（以 Nginx 为例）之前，先要源码安装 Nginx 或者自制 rpm 包安装 Nginx 正文： 步骤目录： 步骤一：创建 Nginx 的 systemd 文件 步骤二：导入新创建的 Nginx systemd 配置文件 步骤三：使用 systemd 管理 Ngixn3.1 使用 systemd 启动 Nginx3.2 使用 systemd 开机自启 Nginx3.3 使用 systemd 显示 Nginx 的状态 具体的操作步骤： 步骤一：创建 Nginx 的 systemd 文件 创建以下内容： 步骤二：导入新创建的 Nginx systemd 配置文件 步骤三：使用 systemd 管理 Ngixn3.1 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/systemctl-service/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Linux Nginx  源码安装包的管理 （通过 systemd 实现）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<p>注意：在通过 systemd 管理源码安装的软件或自制 rpm 包安装的软件（以 Nginx 为例）之前，先要源码安装 Nginx 或者自制 rpm 包安装 Nginx</p>



<div class="wp-container-2 wp-block-buttons">
<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/nginx-install-source/">Nginx 源码软件包的安装</a></div>



<div class="wp-block-button is-style-outline"><a class="wp-block-button__link no-border-radius" href="https://eternalcenter-now.github.io/rpm-make/">Linux rpm 软件包的制作<br>（通过 rpm-build 实现）<br>（Nginx 版）</a></div>
</div>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-创建-nginx-的-systemd-文件">步骤一：创建 Nginx 的 systemd 文件</h4>



<h4 id="步骤二-导入新创建的-nginx-systemd-配置文件">步骤二：导入新创建的 Nginx systemd 配置文件</h4>



<h4 id="步骤三-使用-systemd-管理-ngixn3-1-使用-systemd-启动-nginx3-2-使用-systemd-开机自启-nginx3-3-使用-systemd-显示-nginx-的状态">步骤三：使用 systemd 管理 Ngixn<br>3.1 使用 systemd 启动 Nginx<br>3.2 使用 systemd 开机自启 Nginx<br>3.3 使用 systemd 显示 Nginx 的状态</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-创建-nginx-的-systemd-文件">步骤一：创建 Nginx 的 systemd 文件</h4>



<pre class="wp-block-code"><code># vim /etc/systemd/system/nginx.service </code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>&#91;Unit]

Description=nginx server daemon

Documentation=man:nginx(8)

After=network.target

&#91;Service]

Type=forking

ExecStart=/usr/local/nginx/sbin/nginx

ExecReload=/usr/local/nginx/sbin/nginx -s reload

ExecStop=/usr/local/nginx/sbin/nginx -s stop

PrivateTmp=true

&#91;Install]

WantedBy=multi-user.target</code></pre>



<h4 id="步骤二-导入新创建的-nginx-systemd-配置文件">步骤二：导入新创建的 Nginx systemd 配置文件</h4>



<pre class="wp-block-code"><code># systemctl daemon-reload</code></pre>



<h4 id="步骤三-使用-systemd-管理-ngixn3-1-使用-systemd-启动-nginx">步骤三：使用 systemd 管理 Ngixn<br>3.1 使用 systemd 启动 Nginx</h4>



<pre class="wp-block-code"><code># systemctl start nginx.service</code></pre>



<h4 id="3-2-使用-systemd-开机自启-nginx">3.2 使用 systemd 开机自启 Nginx</h4>



<pre class="wp-block-code"><code># systemctl enable nginx.service</code></pre>



<h4 id="3-3-使用-systemd-显示-nginx-的状态">3.3 使用 systemd 显示 Nginx 的状态</h4>



<pre class="wp-block-code"><code># systemctl status nginx.service</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Linux 开机自启 （通过 chkconfig 实现）</title>
		<link>https://eternalcenter-now.github.io/chkconfig/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 24 Jul 2019 12:03:18 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System File (系统文件)]]></category>
		<category><![CDATA[System File Security (系统文件安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Setting (系统设置)]]></category>
		<category><![CDATA[System Storage & System Directory & System File (系统存储 & 系统目录 & 系统文件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=4889</guid>

					<description><![CDATA[案例一：添加一个受 chkconfig 管理的服务（脚本）1.1 编写一个脚本 创建以下内容： （补充：chkconfig:后面的 3 个含义为 httpd 的级别为 3、4 和 5，启动序号为 85，关闭序号为 15） 1.2 给脚本添加执行权限 1.3 将脚本添加到 chkconfig 中 1.4 显示刚刚添加到 chkconfig 的应用 案例二：通过 chkconfig 管理一个服务或脚本2.1 设定 start.sh 在 3 和 5 等级为 on 2.2 设定 start.sh 在各等级为 on，“各等级”包括 2、3、4、5 等级 2.3 设定 start.sh 在各等级为 off，“各等级”包括 2、3、4、5 等级]]></description>
										<content:encoded><![CDATA[
<h4 id="案例一-添加一个受-chkconfig-管理的服务-脚本-1-1-编写一个脚本">案例一：添加一个受 chkconfig 管理的服务（脚本）<br>1.1 编写一个脚本</h4>



<pre class="wp-block-code"><code># vim /etc/init.d/start.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash
systemctl start httpd

# chkconfig: 345 85 15
# description: This is a script of starting httpd</code></pre>



<p>（补充：chkconfig:后面的 3 个含义为 httpd 的级别为 3、4 和 5，启动序号为 85，关闭序号为 15）</p>



<h4 id="1-2-给脚本添加执行权限">1.2 给脚本添加执行权限</h4>



<pre class="wp-block-code"><code># chmod +x /etc/init.d/start.sh</code></pre>



<h4 id="1-3-将脚本添加到-chkconfig-中">1.3 将脚本添加到 chkconfig 中</h4>



<pre class="wp-block-code"><code># chkconfig --add start.sh</code></pre>



<h4 id="1-4-显示刚刚添加到-chkconfig-的应用">1.4 显示刚刚添加到 chkconfig 的应用</h4>



<pre class="wp-block-code"><code># chkconfig --list</code></pre>



<h4 id="案例二-通过-chkconfig-管理一个服务或脚本2-1-设定-start-sh-在-3-和-5-等级为-on">案例二：通过 chkconfig 管理一个服务或脚本<br>2.1 设定 start.sh 在 3 和 5 等级为 on</h4>



<pre class="wp-block-code"><code># chkconfig --level 35 start.sh on</code></pre>



<h4 id="2-2-设定-start-sh-在各等级为-on-各等级-包括-2-3-4-5-等级">2.2 设定 start.sh 在各等级为 on，“各等级”包括 2、3、4、5 等级</h4>



<pre class="wp-block-code"><code># chkconfig start.sh on</code></pre>



<h4 id="2-3-设定-start-sh-在各等级为-off-各等级-包括-2-3-4-5-等级">2.3 设定 start.sh 在各等级为 off，“各等级”包括 2、3、4、5 等级</h4>



<pre class="wp-block-code"><code># chkconfig start.sh off</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] openSUSE &#038; SLE 开机自启</title>
		<link>https://eternalcenter-now.github.io/auto-start-opensuse-sle/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 11 Jun 2019 03:02:48 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System File Security (系统文件安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[System Setting (系统设置)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=4785</guid>

					<description><![CDATA[内容一：openSUSE &#38; SLE 开机设置文档介绍 （补充：1) 其中的 boot.local 是在刚开机时，在所有其他的程序执行前执行的文件2) 其中的 after.local 是在刚开机后，在所有其他的程序执行后执行的文件） （注意：上面第三和第四个档案默认是不存在的，可以自己创建一个, 就像写个 shell 一样很简单） 内容二：设置 openSUSE &#38; SLE 开机自启命令的案例2.1 创建 after.local 文件 创建以下内容： （补充：这里以开机自启 httpd 程序为例） 2.2 给 after.local 文件执行权限]]></description>
										<content:encoded><![CDATA[
<h4>内容一：openSUSE &amp; SLE 开机设置文档介绍</h4>



<pre class="wp-block-code"><code>1) /etc/init.d/boot.local
2) /etc/init.d/halt.local
3) /etc/init.d/before.local
4) /etc/init.d/after.local</code></pre>



<p>（<br>补充：<br>1) 其中的 boot.local 是在刚开机时，在所有其他的程序执行前执行的文件<br>2) 其中的 after.local 是在刚开机后，在所有其他的程序执行后执行的文件<br>）</p>



<p>（注意：上面第三和第四个档案默认是不存在的，可以自己创建一个, 就像写个 shell 一样很简单）</p>



<h4>内容二：设置 openSUSE &amp; SLE 开机自启命令的案例<br>2.1 创建 after.local 文件</h4>



<pre class="wp-block-code"><code># vim /etc/init.d/after.local</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>sudo systemctl restart httpd</code></pre>



<p>（补充：这里以开机自启 httpd 程序为例）</p>



<h4>2.2 给 after.local 文件执行权限</h4>



<pre class="wp-block-code"><code># chmod u+x /etc/init.d/after.local</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 top （显示资源和进程）</title>
		<link>https://eternalcenter-now.github.io/top/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Mon, 06 May 2019 10:42:20 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[System Hardware (系统硬件)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Performance (系统性能)]]></category>
		<category><![CDATA[System Process (系统进程)]]></category>
		<category><![CDATA[System Process & System Performance (系统进程 & 系统性能)]]></category>
		<category><![CDATA[System Process Security (系统进程安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<guid isPermaLink="false">https://eternalcenter-now.github.io/?p=4676</guid>

					<description><![CDATA[内容目录： 内容一：top 命令解析1.1 top 命令输出结果1.2 top 命令输出结果简介1.2.1 top 命令输出结果分类1.2.2 统计信息说明1.2.2.1 第 1 行信息1.2.2.2 第 2 行信息1.2.2.3 第 3 行信息1.2.2.4 第 4 行信息1.2.2.5 第 5 行信息1.2.3 进程信息说明 内容二：top 非交互式命令选项 内容三：top 交互命令 （即是在键入了 top 命令之后再键入以下命令）3.1 基础操作3.2 设置操作3.3 显示操作3.4 排序操作 内容四：top 命令使用案例 具体的内容： 内容一：top 命令解析1.1 top 命令输出结果 1.2 top 命令输出结果简介1.2.1 top 命令输出结果分类 1) 前 5 行是整体的统计信息2) 后面的是具体的进程信息 1.2.2 &#8230; <p class="link-more"><a href="https://eternalcenter-now.github.io/top/" class="more-link">Continue reading<span class="screen-reader-text"> "[命令] Linux 命令 top （显示资源和进程）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="内容目录">内容目录：</h2>



<h4 id="内容一-top-命令解析1-1-top-命令输出结果1-2-top-命令输出结果简介1-2-1-top-命令输出结果分类1-2-2-统计信息说明1-2-2-1-第-1-行信息1-2-2-2-第-2-行信息1-2-2-3-第-3-行信息1-2-2-4-第-4-行信息1-2-2-5-第-5-行信息1-2-3-进程信息说明">内容一：top 命令解析<br>1.1 top 命令输出结果<br>1.2 top 命令输出结果简介<br>1.2.1 top 命令输出结果分类<br>1.2.2 统计信息说明<br>1.2.2.1 第 1 行信息<br>1.2.2.2 第 2 行信息<br>1.2.2.3 第 3 行信息<br>1.2.2.4 第 4 行信息<br>1.2.2.5 第 5 行信息<br>1.2.3 进程信息说明</h4>



<h4 id="内容二-top-非交互式命令选项">内容二：top 非交互式命令选项</h4>



<h4>内容三：top 交互命令 （即是在键入了 top 命令之后再键入以下命令）<br>3.1 基础操作<br>3.2 设置操作<br>3.3 显示操作<br>3.4 排序操作</h4>



<h4 id="内容四-top-命令使用案例">内容四：top 命令使用案例</h4>



<h2 id="具体的内容">具体的内容：</h2>



<h4 id="内容一-top-命令解析1-1-top-命令输出结果">内容一：top 命令解析<br>1.1 top 命令输出结果</h4>



<pre class="wp-block-code"><code># top
top - 14:16:16 up 6 days, 20:52,  4 users,  load average: 0.00, 0.00, 0.00
Tasks: 393 total,   1 running, 392 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   5848752 total,  5709944 used,   138808 free,     4960 buffers
KiB Swap:  2103292 total,        0 used,  2103292 free.  4507072 cached Mem

  PID USER      PR  NI    VIRT    RES    SHR S   %CPU  %MEM     TIME+ COMMAND                                      
    8 root      20   0       0      0      0 S  0.332 0.000   2:12.60 rcu_sched                                    
  716 z0042h2+  20   0   15484   2840   2132 R  0.332 0.049   0:00.09 top                                          
31993 root      20   0       0      0      0 S  0.332 0.000   0:00.08 kworker/u32:2                                
    1 root      20   0  189604   5892   4120 S  0.000 0.101   2:35.86 systemd                                      
    2 root      20   0       0      0      0 S  0.000 0.000   0:00.72 kthreadd                                     
    4 root       0 -20       0      0      0 S  0.000 0.000   0:00.00 kworker/0:0H</code></pre>



<h4 id="1-2-top-命令输出结果简介1-2-1-top-命令输出结果分类">1.2 top 命令输出结果简介<br>1.2.1 top 命令输出结果分类</h4>



<p>1) 前 5 行是整体的统计信息<br>2) 后面的是具体的进程信息</p>



<h4 id="1-2-2-统计信息说明1-2-2-1-第-1-行信息">1.2.2 统计信息说明<br>1.2.2.1 第 1 行信息</h4>



<p>1) 14:16:16 系统当前时间<br>2) 20:52 系统运行了多久<br>3) 4 users 系统当前登陆用户数<br>4) load average: 0.00, 0.00, 0.00 系统平均负载</p>



<p>（<br>补充：<br>其中的三个数值分别代表：1，5，15 分钟的系统平均负载<br>单核 CPU 的情况下：0.00 代表 0 负载，1.00 代表满载，超过 1 代表超负荷<br>理想情况是：CPU 的核心数 * 0.7 = 整个系统的理想负载<br>）</p>



<h4 id="1-2-2-2-第-2-行信息">1.2.2.2 第 2 行信息</h4>



<p>1) Tasks: 393 total 总进程数<br>2) 1 running 正在运行的进程数<br>3) 392 sleeping 睡眠进程数<br>4) 0 stopped 停止进程数<br>5) 0 zombie 僵尸进程数</p>



<h4 id="1-2-2-3-第-3-行信息">1.2.2.3 第 3 行信息</h4>



<p>（<br>注意：<br>1) 这一行默认是所有 CPU 核心加在一起的平均值，如果有 1 个核心那满值就是 100%，如果有 5 个核心那总值就是 500%<br>2) 如果此时输入数字 1 ，则可以切换至每个单核 CPU 的负载情况，再输入数字 1，则可以再切换回来<br>）</p>



<p>1) 0.0 us 用户空间占用 CPU 的百分比<br>2) 0.0 sy 内核空间占用 CPU 的百分比<br>3) 0.0 ni 非实时的进程的优先级，取值范围为从 -20 到 19，数值越小优先级越高<br>4) 100.0 id 空闲的 CPU 的百分比<br>5) 0.0 wa CPU 等待输入输出的时间百分比<br>6) 0.0 hi 服务因硬件中断所消耗的时间百分比<br>7) 0.0 si 服务因软件中断所消耗的时间百分比<br>8) 0.0 st 虚拟机被物理机偷去的 CPU 时间百分比</p>



<h4 id="1-2-2-4-第-4-行信息">1.2.2.4 第 4 行信息</h4>



<p>1) 5848752 total 总物理内存量<br>2) 5709944 used 已经使用的物理内存量<br>3) 138808 free 剩余的物理内存量<br>4) 4960 buffers 用作内核缓存的内存量</p>



<h4 id="1-2-2-5-第-5-行信息">1.2.2.5 第 5 行信息</h4>



<p>1) 2103292 total 总交换分区量<br>2) 0 used 已经使用的交换分区量<br>3) 2103292 free 剩余交换分区量<br>4) 4507072 cached Mem 用作缓存的交换分区量</p>



<h4 id="1-2-3-进程信息说明">1.2.3 进程信息说明</h4>



<p>（<br>补充：<br>1) 此时按下 “f” 键可以选择要显示的信息<br>2) 此时按下 “方向” 键翻看想查阅的内容<br>3) 此时按下 “s” 键可以开启显示这一信息<br>4) 此时按下 “d” 键可以关闭显示这一信息<br>4) 带 * 号的是已经选择要显示的信息<br>）</p>



<p>1) PID（Process Id） 进程的 id<br>2) USER（User Name） 进程所有者的用户<br>3) PR（Priority） 优先级<br>4) NI（Nice value） nice 值（负值表示高优先级，正值表示低优先级）<br>5) VIRT（Virtual Image （kb）） 进程使用的虚拟内存量，单位 kb<br>6) RES（Resident size （kb）） 进程使用的、未被换出的物理内存大小，单位 kb<br>7) SHR（Shared Mem size （kb）） 共享内存大小，单位 kb<br>8) S（Process Status） 进程状态，可以为 D R S T 和 Z</p>



<p>（补充：D 表示不可中断的睡眠状态，R 表示运行，S 表示睡眠，T 表示跟踪/停止，Z 表示僵尸进程）</p>



<p>9) %CPU（CPU usage） 上上次更新到上次更新时进程 CPU 占用平均百分比</p>



<p>（注意：此值可能会超过 100% ，但不会超过：CPU 总核心数 * 100% ）</p>



<p>10) %MEM（Memory usage （RES）） 上上次更新到上次更新时进程使用的物理内存百分比<br>11) TIME+（CPU Time, hundredths） 进上上次更新到上次更新时进程使用 CPU 的总时间，单位 1/100 秒<br>12) COMMAND（Command name/line） 命令名|命令行</p>



<h4 id="内容二-top-非交互式命令选项">内容二：top 非交互式命令选项</h4>



<p>1) -b 以批处理模式执行命令<br>2) -c &lt;command&gt; 在执行了 top 命令之后再直接执行交互命令<br>3) -d &lt;time&gt; 屏幕刷新间隔时间<br>4) -i 忽略僵尸进程<br>5) -s 以安全模式执行命令<br>6) -S 以累积模式执行命令<br>7) -i &lt;时间&gt; 设置间隔时间<br>8) -u &lt;用户&gt; 指定只显示某个用户的进程<br>9) -p &lt;进程号&gt; 指定只显示某个 PID 的进程<br>10) -n &lt;次数&gt; 指定显示循环的次数</p>



<h4>内容三：top 交互命令 （即是在键入了 top 命令之后再键入以下命令）<br>3.1 基础操作</h4>



<p>按 “h” 显示帮助</p>



<h4>3.2 设置操作</h4>



<p>1) 按下 “k” 键再按下 &#8220;&lt;pid&gt;&#8221; 再按下 “&lt;回车&gt;” 键，将某个 pid 为 &lt;pid&gt; 的进程删除<br>2) 按下 “r” 键再按下 &#8220;&lt;ni&gt;&#8221; 再按下 “&lt;回车&gt;” 键，将某个进程的 ni 设置为 &lt;ni&gt;，取值范围为从 -20 到 19，数值越小优先级越高</p>



<p>（注意：只有 root 的取值范围才是 -20 到 19 ，普通用户的取值范围是 0 到 19）</p>



<p>3) 按下 “esc” 键，退出 top 命令当前的子状态，如果没有子状态则不退出<br>4) 按下 “q” 键，退出 top</p>



<h4 id="3-2-面板隐藏显示">3.3 显示操作</h4>



<p>1) 按下 “d” 键再按 &lt;number&gt; 再按下 “回车” ，将刷新频率修改为 &lt;number&gt; 秒<br>2) 按下 “s” 键再按 &lt;number&gt; 再按下 “回车”，将刷新的延迟时间修改为 &lt;number&gt; 秒 （默认是 5S）<br>3) 按下 “n” 键再按 &lt;number&gt; 再按下 “回车”，将显示的行数修改为 &lt;number&gt; 行 （默认显示能满屏的行数）<br>4) 按下 “f” 键，选择要显示的信息<br>5) 按下 “i” 键，不显示闲置和僵死进程，再按下 “i” 键会取消<br>6) 按下 “S” 键，切换到累积模式，再按下 “S” 键会取消<br>7) 按下 “l” 键，隐藏第 1 行总负载信息，再按下 “l” 键会取消<br>8) 按下 “t” 键， 隐藏第 2~3 行 CPU 信息，再按下 “t” 键会取消<br>9) 按下 “m” 键，隐藏第 4~5 行内存信息，再按下 “m” 键会取消<br>10) 按下 “1” 键，显示 CPU 所有核心的信息，每核显示 1 行，再按下 “1” 键会取消</p>



<h4 id="3-3-进程列表排序">3.4 排序操作</h4>



<p>1) 按下 “M” 键，根据使用内存的大小进行排序<br>2) 按下 “P” 键，根据使用 CPU 的大小进行排序<br>3) 按下 “T” 键，根据开启的时间进行排序</p>



<h4 id="内容四-top-命令使用案例">内容四：top 命令使用案例<br>4.1 案例一：显示 top 命令运行 1 秒钟时的信息</h4>



<pre class="wp-block-code"><code># top -bn 1</code></pre>



<h4>4.2 案例二：显示 top 命令运行 1 秒钟时的 CPU 占用率最高的进程</h4>



<pre class="wp-block-code"><code># top -bn 1 -i -c</code></pre>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
